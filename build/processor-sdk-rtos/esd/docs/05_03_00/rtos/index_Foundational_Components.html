

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>4.1. TI-RTOS Kernel &mdash; Processor SDK RTOS Documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="Processor SDK RTOS Documentation" href="../index.html"/>
        <link rel="up" title="4. Foundational Components" href="Foundational_Components.html"/>
        <link rel="next" title="5. DSP Software" href="DSP_Software.html"/>
        <link rel="prev" title="4. Foundational Components" href="Foundational_Components.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">
  <header id="tiHeader">
    <div class="top">
      <ul>
        <li id="top_logo">
          <a href="http://www.ti.com">
            <img src="../_static/img/ti_logo.png"/>
          </a>
        </li>
      </ul>
    </div>
    <div class="nav"></div>
  </header>
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Processor SDK RTOS
          

          
          </a>

          
            
            
              <div class="version">
                05_03_00
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Overview.html">1. Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="Release_Specific.html">2. Release Specific</a></li>
<li class="toctree-l1"><a class="reference internal" href="Board_EVM_Abstration.html">3. Board/EVM Abstration</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Foundational_Components.html">4. Foundational Components</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="">4.1. TI-RTOS Kernel</a></li>
<li class="toctree-l2"><a class="reference internal" href="#xdais">4.2. XDAIS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fc">4.3. FC</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ipc">4.4. IPC</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ipc-examples">4.4.1. IPC Examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id1">4.4.1.1. IPC RTOS Examples</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#opencl">4.5. OpenCL</a></li>
<li class="toctree-l2"><a class="reference internal" href="#boot">4.6. Boot</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">4.6.1. Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#boot-modes">4.6.2. Boot Modes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#mmcsd">4.6.2.1. MMCSD</a></li>
<li class="toctree-l4"><a class="reference internal" href="#qspi">4.6.2.2. QSPI</a></li>
<li class="toctree-l4"><a class="reference internal" href="#uart">4.6.2.3. UART</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mcspi-spi">4.6.2.4. MCSPI/SPI</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nand">4.6.2.5. NAND</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#platforms">4.6.3. Platforms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#am335x-am437x">4.6.3.1. AM335x/AM437x</a></li>
<li class="toctree-l4"><a class="reference internal" href="#am57x">4.6.3.2. AM57x</a></li>
<li class="toctree-l4"><a class="reference internal" href="#am65x">4.6.3.3. AM65x</a></li>
<li class="toctree-l4"><a class="reference internal" href="#c66x">4.6.3.4. C66x</a></li>
<li class="toctree-l4"><a class="reference internal" href="#k2g">4.6.3.5. K2G</a></li>
<li class="toctree-l4"><a class="reference internal" href="#k2h-k2e-k2l">4.6.3.6. K2H/K2E/K2L</a></li>
<li class="toctree-l4"><a class="reference internal" href="#omapl137-omapl138-c6748">4.6.3.7. OMAPL137/OMAPL138/C6748</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#bootloader-debugging">4.6.4. Bootloader Debugging</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#common-steps-to-debug-application-boot">4.6.4.1. Common Steps to debug application boot</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#uart-apploader">4.6.5. UART AppLoader</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id64">4.6.5.1. Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#supported-platforms">4.6.5.2. Supported Platforms</a></li>
<li class="toctree-l4"><a class="reference internal" href="#apploader-load-address">4.6.5.3. Apploader Load Address</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pre-requisites">4.6.5.4. Pre-Requisites</a></li>
<li class="toctree-l4"><a class="reference internal" href="#apploader-usage">4.6.5.5. AppLoader Usage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rebuilding-apploader">4.6.5.6. Rebuilding AppLoader</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#mpm">4.7. MPM</a></li>
<li class="toctree-l2"><a class="reference internal" href="#openmp">4.8. OpenMP</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pktlib">4.9. PKTLIB</a></li>
<li class="toctree-l2"><a class="reference internal" href="#network">4.10. Network</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cclink">4.10.1. CCLink</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id69">4.10.1.1. Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#protocol-overview">4.10.1.2. Protocol Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#code-organization">4.10.1.3. Code Organization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#building-the-examples">4.10.1.4. Building the Examples</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ndk">4.10.2. NDK</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ndk-overview">4.10.2.1. NDK Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nimu-transport">4.10.2.2. NIMU Transport</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nimu-for-cpsw">4.10.2.3. NIMU for CPSW</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nimu-for-icss">4.10.2.4. NIMU for ICSS</a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples">4.10.2.5. Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cclink-example">4.10.2.6. CCLink Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="#faq">4.10.2.7. FAQ</a></li>
<li class="toctree-l4"><a class="reference internal" href="#additional-documentation-references">4.10.2.8. Additional Documentation References</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#transport">4.11. Transport</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#timesync-ptp">4.11.1. TimeSync (PTP)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id75">4.11.1.1. Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id78">4.11.1.2. Additional References</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#tools">4.12. Tools</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="DSP_Software.html">5. DSP Software</a></li>
<li class="toctree-l1"><a class="reference internal" href="Device_Drivers.html">6. Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="PRU_ICSS.html">7. PRU-ICSS Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="Compilers.html">8. Compilers</a></li>
<li class="toctree-l1"><a class="reference internal" href="Examples_and_Demonstrations.html">9. Examples and Demonstrations</a></li>
<li class="toctree-l1"><a class="reference internal" href="How_to_Guides.html">10. How to Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="FAQ.html">11. Frequently Asked Questions</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Processor SDK RTOS</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
          <li><a href="Foundational_Components.html">4. Foundational Components</a> &raquo;</li>
      
    <li>4.1. TI-RTOS Kernel</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="ti-rtos-kernel">
<h1>4.1. TI-RTOS Kernel<a class="headerlink" href="#ti-rtos-kernel" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference external" href="http://processors.wiki.ti.com/index.php?title=Category:SYSBIOS">SYSBIOS</a></li>
</ul>
</div>
<div class="section" id="xdais">
<h1>4.2. XDAIS<a class="headerlink" href="#xdais" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference external" href="http://processors.wiki.ti.com/index.php?title=Category:XDAIS">XDAIS</a></li>
</ul>
</div>
<div class="section" id="fc">
<h1>4.3. FC<a class="headerlink" href="#fc" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference external" href="http://processors.wiki.ti.com/index.php?title=Category:Framework_Components">Framework Components</a></li>
</ul>
</div>
<div class="section" id="ipc">
<h1>4.4. IPC<a class="headerlink" href="#ipc" title="Permalink to this headline">¶</a></h1>
<p class="rubric" id="ipc-technical-documents-links">IPC technical documents links</p>
<table border="1" class="docutils">
<colgroup>
<col width="78%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Links</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference external" href="http://processors.wiki.ti.com/index.php/IPC_Users_Guide">IPC User&#8217;s Guide</a></td>
<td>TI IPC User&#8217;s Guide</td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="section" id="ipc-examples">
<span id="ipc-rtos-examples"></span><h2>4.4.1. IPC Examples<a class="headerlink" href="#ipc-examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>4.4.1.1. IPC RTOS Examples<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p class="rubric" id="ipc-examples-with-arm-host-running-ti-rtos">IPC Examples with ARM Host running TI-RTOS</p>
<p>The IPC package includes examples for the use-case with both the Host and slave cores running TI-RTOS.
They can be built from the Processor SDK RTOS package.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">To Install RTOS Proc SDK, please follow the instructions in the <a class="reference external" href="http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/index_overview.html#processor-sdk-rtos-getting-started-guide">RTOS SDK Getting Started Guide</a></p>
</div>
<p>In the RTOS Processor SDK, the ipc examples are located under &lt;RTOS_SDK_INSTALL_DIR&gt;/processor_sdk_rtos_&lt;platform&gt;_x_xx_xx_xx/ipc_&lt;version&gt;/examples/&lt;platform&gt;_bios_elf.</p>
<p>Once the RTOS Processor SDK is installed at the default location, the IPC examples can be built with the following commands:</p>
<ol class="arabic">
<li><p class="first">Change to Processor SDK RTOS directory</p>
<blockquote>
<div><p>$ cd &lt;RTOS_SDK_INSTALL_DIR&gt;/processor_sdk_rtos_&lt;platform&gt;_x_xx_xx_xx</p>
</div></blockquote>
</li>
<li><p class="first">Start the top level build:</p>
<blockquote>
<div><p>$ make ipc_examples</p>
</div></blockquote>
</li>
</ol>
</div>
</div>
</div>
<div class="section" id="opencl">
<h1>4.5. OpenCL<a class="headerlink" href="#opencl" title="Permalink to this headline">¶</a></h1>
<p><a class="reference external" href="http://downloads.ti.com/mctools/esd/docs/opencl/index.html">OpenCL</a></p>
</div>
<div class="section" id="boot">
<h1>4.6. Boot<a class="headerlink" href="#boot" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<span id="fc-boot-label"></span><h2>4.6.1. Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>This page provides an overview about the Secondary Bootloader support
provided in Processor SDK RTOS.</p>
<p>The Secondary Bootloader (SBL) sets-up the PLL clocks, powers on the
I/O Peripherals, initializes the DDR, loads the application image into
DDR &amp; brings the slave cores for applicable SOCs out of reset.
Additional details including execution boot flow is covered in more
elaborate detail under individual SOC section.</p>
</div>
<div class="section" id="boot-modes">
<h2>4.6.2. Boot Modes<a class="headerlink" href="#boot-modes" title="Permalink to this headline">¶</a></h2>
<div class="section" id="mmcsd">
<h3>4.6.2.1. MMCSD<a class="headerlink" href="#mmcsd" title="Permalink to this headline">¶</a></h3>
<p>MMCSD bootloader is required to boot target using an SD card containing
bootloader and application images. When the board is powered ON the ROM
bootloader detects the MMCSD bootloader image and loads it to the
internal memory.The bootloader initializes the board, copies the
application image from SD card to the DDR memory and gives control to
the application.</p>
</div>
<div class="section" id="qspi">
<h3>4.6.2.2. QSPI<a class="headerlink" href="#qspi" title="Permalink to this headline">¶</a></h3>
<p>A flash device interfaced with QSPI is flashed with QSPI bootloader and
application images. When the board is powered ON the ROM bootloader
detects the bootloader image from flash device and loads it to the
internal memory. The Bootloader initializes the board, copies the
application image from QSPI device to the DDR memory and gives control
to the application.</p>
</div>
<div class="section" id="uart">
<h3>4.6.2.3. UART<a class="headerlink" href="#uart" title="Permalink to this headline">¶</a></h3>
<p>A Serial connection is used for transferring the bootloader binary from
PC to target board through XMODEM protocol. The bootloader on execution
prompts for application image to transfer through XMODEM. On providing
the path, the application binary is transferred through serial
connection to DDR memory and the control is passed to application to
execute.</p>
</div>
<div class="section" id="mcspi-spi">
<h3>4.6.2.4. MCSPI/SPI<a class="headerlink" href="#mcspi-spi" title="Permalink to this headline">¶</a></h3>
<p>A SPI flash device flashed with MCSPI/SPI bootloader and application
images is used for booting the board. When the board is powered ON the
ROM bootloader detects the bootloader image from flash device and loads
it to the internal memory. The Bootloader initializes the board, copies
the application image from flash to the DDR memory and gives control to
the application.</p>
</div>
<div class="section" id="nand">
<h3>4.6.2.5. NAND<a class="headerlink" href="#nand" title="Permalink to this headline">¶</a></h3>
<p>NAND flash with bootloader and and application images is used for
booting the board. When the board is powered ON the ROM bootloader
detects the bootloader image from flash device and loads it to the
internal memory. The bootloader initializes the board, copies the
application image from flash to the DDR memory and gives control to the
application.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For information on boot mode setting, see the applicable <a class="reference external" href="index_release_specific.html#supported-platforms-and-versions">EVM Hardware User Guide</a></p>
</div>
</div>
</div>
<div class="section" id="platforms">
<h2>4.6.3. Platforms<a class="headerlink" href="#platforms" title="Permalink to this headline">¶</a></h2>
<div class="section" id="am335x-am437x">
<h3>4.6.3.1. AM335x/AM437x<a class="headerlink" href="#am335x-am437x" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>4.6.3.1.1. Overview<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Bootloader supports power-on-reset bootstraps for the board. It
initializes board, loads application from the memory device to DDR and
transfers control to application. Section provides additional details
including flashing and booting instructions across different media.</p>
</div>
<div class="section" id="source-reference">
<h4>4.6.3.1.2. Source Reference<a class="headerlink" href="#source-reference" title="Permalink to this headline">¶</a></h4>
<div class="highlight-cpp"><div class="highlight"><pre>&lt; BASE_DIR = PDK_INSTALL_DIR\packages\ti\starterware&gt;
</pre></div>
</div>
<div class="section" id="bootloader-build-files-for-am335x-am437x">
<h5>4.6.3.1.2.1. Bootloader build files for AM335x/AM437x<a class="headerlink" href="#bootloader-build-files-for-am335x-am437x" title="Permalink to this headline">¶</a></h5>
<p><strong>Source files:</strong></p>
<ul class="simple">
<li><strong>BASE_DIRbootloadersrc</strong>: Common source files for bootloader
functionality</li>
<li><strong>BASE_DIRbootloadersrc&lt;device&gt;</strong>: Files specific to device to
initialize platform features like PLL, pinmux and DDR</li>
</ul>
<p><strong>Build Files:</strong></p>
<ul class="simple">
<li><strong>BASE_DIR/build/makerules/rules_a8.mk</strong>: Common Compiler flags used
for A8 cores. Applies to AMIC110 and AM335x</li>
<li><strong>BASE_DIR/build/makerules/rules_a8.mk</strong>: Common Compiler flags used
for A9 cores. Applies to AM437x devices</li>
<li><strong>BASE_DIR/build/makerules/platform.mk</strong>: Global settings for all
components for a particular platform.</li>
<li><strong>BASE_DIR/build/makerules/components.mk</strong>: Specific settings for
components in starterware</li>
<li><strong>BASE_DIR/build/makerules/build_cfg.mk</strong>: Flags to enable features
in the build</li>
<li><strong>BASE_DIR/bootloader/Makefile</strong>: Makefile for bootloader that
provides list of source files and library to create bootloader
binary.</li>
</ul>
<p><strong>Boot and flashing tools:</strong></p>
<ul class="simple">
<li><strong>BASE_DIR/tools Contains tools to create boot images and flashing
tools to program the boot binary on the boot media.</strong></li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="bootloader-execution-sequence">
<h4>4.6.3.1.3. Bootloader execution sequence<a class="headerlink" href="#bootloader-execution-sequence" title="Permalink to this headline">¶</a></h4>
<p>The Processor SDK RTOS boot loader uses a two stage boot process. The
different stages of the application boot sequence using Processor SDK
RTOS bootloader are shown below:</p>
<div class="section" id="boot-sequence">
<h5>4.6.3.1.3.1. Boot Sequence<a class="headerlink" href="#boot-sequence" title="Permalink to this headline">¶</a></h5>
<ol class="arabic simple">
<li>Power on Reset</li>
<li>ROM Bootloader (RBL)<ul>
<li>Platform configuration and initialization.<ul>
<li>DPLL and clock settings for MPU, I2C, MMCSD, USB, SPI, QSPI,
Ethernet etc.</li>
</ul>
</li>
<li>Checks Sysboot pins and choose booting device<ul>
<li>If no valid bootloader found on booting device, RBL checks for
next booting device. The sequence depends on RBL execution flow
and Sysboot pins.</li>
</ul>
</li>
<li>RBL gets image size and load address by checking TI Image Header
appended on bootloader binary(.bin). Check <a class="reference external" href="index_Foundational_Components.html#tools-and-binary-formats">binary
formats</a>.</li>
<li>Loads the binary to internal OCMC memory at the Load address
fetched from TI Image Header</li>
<li>Passes control to Secondary Bootloader(SBL)</li>
</ul>
</li>
<li>Secondary Bootloader(SBL)<ul>
<li>Configure PLL and Initialize DDR</li>
<li>Configure PRCM and PinMux&nbsp; for Boot Peripherals</li>
<li>Copies application image to DDR</li>
<li>Passes execution control to Application</li>
</ul>
</li>
<li>Application execution</li>
</ol>
</div>
</div>
<div class="section" id="tools-and-binary-formats">
<h4>4.6.3.1.4. Tools and Binary formats<a class="headerlink" href="#tools-and-binary-formats" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Binary format</td>
<td>Requirement</td>
<td>Details</td>
</tr>
<tr class="row-even"><td>.bin</td>
<td><p class="first">QSPI&nbsp;bootloader,</p>
<p class="last">UART bootloader and
app</p>
</td>
<td><p class="first">QSPI bootloader
binary should in .bin
format and
Application binary
should be in _ti.bin
format.</p>
<p class="last">UART bootloader and
applications are
loaded in .bin format
through XMODEM in
terminal.</p>
</td>
</tr>
<tr class="row-odd"><td>_ti.bin</td>
<td><p class="first">MMCSD bootloader
and&nbsp;app,</p>
<p>NAND bootloader and
app,</p>
<p>MCSPI boot loader and
app,</p>
<p class="last">QSPI app.</p>
</td>
<td><p class="first">.bin binaries are
converted to
_ti.bin format by
adding Image
size(4bytes) and
Image load
address(4bytes) as
image header.
Refer to Image
format section in
Initialization
chapter of <a class="reference external" href="http://www.ti.com/lit/ug/spruhl7h/spruhl7h.pdf">AM437x
TRM</a></p>
<p class="last">MMCSD, NAND&nbsp;and MCSPI
boot loaders and
application binaries
should be appended
with ti image header.</p>
</td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p><strong>TI Boot image</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Offset</th>
<th class="head">Binary value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x00000000</td>
<td><strong>Size</strong></td>
</tr>
<tr class="row-odd"><td>0x00000004</td>
<td><strong>Entry Point (Location)</strong></td>
</tr>
<tr class="row-even"><td>0x00000008</td>
<td><strong>Binary (.bin)</strong></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>For bootloader Entry point is usually 0x402f0000</li>
<li>For the app the entry point is usually 0x80000000.</li>
</ul>
</div>
<div class="section" id="binary-format-conversion-procedure">
<h5>4.6.3.1.4.1. Binary format conversion procedure<a class="headerlink" href="#binary-format-conversion-procedure" title="Permalink to this headline">¶</a></h5>
<div class="section" id="binary-format-conversion-in-linux">
<h6>4.6.3.1.4.1.1. Binary format conversion in Linux<a class="headerlink" href="#binary-format-conversion-in-linux" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li>To convert from .out -&gt; .bin</li>
</ol>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">TOOLCHAIN_PATH_</span><span class="o">&lt;</span><span class="n">A8</span><span class="o">/</span><span class="n">A9</span><span class="o">&gt;/</span><span class="n">bin</span><span class="o">/</span><span class="n">arm</span><span class="o">-</span><span class="n">none</span><span class="o">-</span><span class="n">eabi</span><span class="o">-</span><span class="n">objcopy</span> <span class="o">-</span><span class="n">O</span> <span class="n">binary</span> <span class="o">&lt;</span><span class="n">application</span><span class="o">&gt;</span><span class="p">.</span><span class="n">out</span> <span class="o">&lt;</span><span class="n">application</span><span class="o">&gt;</span><span class="p">.</span><span class="n">bin</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li>Build tiimage.out. Go to starterware/tools/ti_image/</li>
</ol>
<div class="highlight-cpp"><div class="highlight"><pre>gcc tiimage.c –o tiimage.out
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li>To convert from .bin -&gt; _ti.bin</li>
</ol>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">tiimage</span><span class="p">.</span><span class="n">out</span> <span class="o">&lt;</span><span class="n">Image</span> <span class="n">Load</span> <span class="n">Address</span><span class="o">&gt;</span> <span class="n">NONE</span> <span class="o">&lt;</span><span class="n">application</span><span class="o">&gt;</span><span class="p">.</span><span class="n">bin</span> <span class="o">&lt;</span><span class="n">application</span><span class="o">&gt;</span><span class="n">_ti</span><span class="p">.</span><span class="n">bin</span>
</pre></div>
</div>
</div>
<div class="section" id="binary-format-conversion-in-windows">
<h6>4.6.3.1.4.1.2. Binary format conversion in Windows<a class="headerlink" href="#binary-format-conversion-in-windows" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li>To convert from .out -&gt; .bin</li>
</ol>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">TOOLCHAIN_PATH_</span><span class="o">&lt;</span><span class="n">A8</span><span class="o">/</span><span class="n">A9</span><span class="o">&gt;/</span><span class="n">bin</span><span class="o">/</span><span class="n">arm</span><span class="o">-</span><span class="n">none</span><span class="o">-</span><span class="n">eabi</span><span class="o">-</span><span class="n">objcopy</span> <span class="o">-</span><span class="n">O</span> <span class="n">binary</span> <span class="o">&lt;</span><span class="n">application</span><span class="o">&gt;</span><span class="p">.</span><span class="n">out</span> <span class="o">&lt;</span><span class="n">application</span><span class="o">&gt;</span><span class="p">.</span><span class="n">bin</span>
</pre></div>
</div>
<p>2) To convert from .bin -&gt; _ti.bin. tiimage.exe is provided as prebuilt
binary in starterware/tools/ti_image.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">tiimage</span><span class="p">.</span><span class="n">exe</span> <span class="o">&lt;</span><span class="n">Image</span> <span class="n">Load</span> <span class="n">Address</span><span class="o">&gt;</span> <span class="n">NONE</span> <span class="o">&lt;</span><span class="n">application</span><span class="o">&gt;</span><span class="p">.</span><span class="n">bin</span> <span class="o">&lt;</span><span class="n">application</span><span class="o">&gt;</span><span class="n">_ti</span><span class="p">.</span><span class="n">bin</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
</div>
<div class="section" id="boot-modes-supported">
<h4>4.6.3.1.5. Boot Modes supported<a class="headerlink" href="#boot-modes-supported" title="Permalink to this headline">¶</a></h4>
<p>Following are the Boot Modes supported through AM335x/AM437x bootloader
for the various EVMs.</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&nbsp;</td>
<td><strong>MMCSD</strong></td>
<td><strong>NAND</strong></td>
<td><strong>McSPI</strong></td>
<td><strong>QSPI</strong></td>
<td><strong>UART</strong></td>
</tr>
<tr class="row-even"><td><strong>AM335x
GPEVM</strong></td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
<td>YES</td>
</tr>
<tr class="row-odd"><td><strong>AM335x
ICEv2</strong></td>
<td>YES</td>
<td>NO</td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr class="row-even"><td><strong>AM335x
StarterKi
t</strong></td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
<td>YES</td>
</tr>
<tr class="row-odd"><td><strong>AM335x
BeagleBon
eBlack</strong></td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
<td>YES</td>
</tr>
<tr class="row-even"><td><strong>AM437x
GPEVM</strong></td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
<td>YES</td>
</tr>
<tr class="row-odd"><td><strong>AM437x
IDK</strong></td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr class="row-even"><td><strong>AM437x
StarterKi
t</strong></td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="building-the-bootloader">
<h4>4.6.3.1.6. Building the Bootloader<a class="headerlink" href="#building-the-bootloader" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt><strong>Pre-requisite:</strong> Setup SDK build environment as described in article</dt>
<dd><a class="reference external" href="index_overview.html#setup-environment">Setup_Environment</a></dd>
</dl>
<p class="rubric" id="normal-operation-of-bootloader">Normal Operation of Bootloader:</p>
<p>Bootloading an application from flash into DDR memory as in case of TI
evaluation platforms is described as normal operation mode for the
bootloader. This is the default behaviour of the bootloader and can be
built using the following command in starterware.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">gmake</span> <span class="n">bootloader</span> <span class="n">BUILDCFG</span><span class="o">=</span><span class="n">boot</span> <span class="n">BOOTMODE</span><span class="o">=&lt;</span><span class="n">BOOT_MODE</span><span class="o">&gt;</span> <span class="n">PLATFORM</span><span class="o">=&lt;</span><span class="n">EVM</span><span class="o">&gt;</span> <span class="n">PROFILE</span><span class="o">=&lt;</span><span class="n">BUILD_PROFILE</span><span class="o">&gt;</span> <span class="o">-</span><span class="n">s</span> <span class="n">KW_BUILD</span><span class="o">=</span><span class="n">no</span>
</pre></div>
</div>
<ul class="simple">
<li>BOOT_MODE: mcspi, nand, qspi, mmcsd, uart (Check supported boot modes
for your evaluation platform)</li>
<li>EVM: am335x-evm, am43xx-evm, amic110-ddrless</li>
<li>BUILD_PROFILE: debug, release</li>
</ul>
<p class="rubric" id="additional-build-options-currently-support-only-for-amic110am335x-ice-users">Additional Build options (currently support only for
AMIC110/AM335x ICE Users)</p>
<ul class="simple">
<li><strong>DDR less Application boot setup</strong></li>
</ul>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">gmake</span> <span class="n">bootloader</span> <span class="n">BUILDCFG</span><span class="o">=</span><span class="n">boot</span> <span class="n">BOOTMODE</span><span class="o">=</span><span class="n">mcspi</span> <span class="n">PLATFORM</span><span class="o">=</span><span class="n">amic110</span><span class="o">-</span><span class="n">ddrless</span> <span class="n">PROFILE</span><span class="o">=</span><span class="n">debug</span> <span class="o">-</span><span class="n">s</span> <span class="n">KW_BUILD</span><span class="o">=</span><span class="n">no</span> <span class="n">USE_DDR</span><span class="o">=</span><span class="n">no</span>
<span class="n">gmake</span> <span class="n">bootloader</span> <span class="n">BUILDCFG</span><span class="o">=</span><span class="n">boot</span> <span class="n">BOOTMODE</span><span class="o">=</span><span class="n">mcspi</span> <span class="n">PLATFORM</span><span class="o">=</span><span class="n">amic110</span><span class="o">-</span><span class="n">ddrless</span> <span class="n">PROFILE</span><span class="o">=</span><span class="n">release</span> <span class="o">-</span><span class="n">s</span> <span class="n">KW_BUILD</span><span class="o">=</span><span class="n">no</span> <span class="n">USE_DDR</span><span class="o">=</span><span class="n">no</span>
</pre></div>
</div>
<p>This option builds an ultra light weight (&lt;10 KB) bootloader for cost
optimized application that don`t external DDR memory.</p>
<ul class="simple">
<li><strong>PRU/ICSS Enable in SBL</strong></li>
</ul>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">gmake</span> <span class="n">bootloader</span> <span class="n">BUILDCFG</span><span class="o">=</span><span class="n">boot</span> <span class="n">BOOTMODE</span><span class="o">=</span><span class="n">mcspi</span> <span class="n">PLATFORM</span><span class="o">=</span><span class="n">am335x</span><span class="o">-</span><span class="n">evm</span> <span class="n">PROFILE</span><span class="o">=</span><span class="n">debug</span> <span class="o">-</span><span class="n">s</span> <span class="n">KW_BUILD</span><span class="o">=</span><span class="n">no</span> <span class="n">ENABLE_PRU</span><span class="o">=</span><span class="n">yes</span>
<span class="n">gmake</span> <span class="n">bootloader</span> <span class="n">BUILDCFG</span><span class="o">=</span><span class="n">boot</span> <span class="n">BOOTMODE</span><span class="o">=</span><span class="n">mcspi</span> <span class="n">PLATFORM</span><span class="o">=</span><span class="n">am335x</span><span class="o">-</span><span class="n">evm</span> <span class="n">PROFILE</span><span class="o">=</span><span class="n">release</span> <span class="o">-</span><span class="n">s</span> <span class="n">KW_BUILD</span><span class="o">=</span><span class="n">no</span> <span class="n">ENABLE_PRU</span><span class="o">=</span><span class="n">yes</span>
</pre></div>
</div>
<p>This feature is required in application that need to quick wake up of
ICSS/PRU cores. The PRU cores can be woken up and loaded from the SBL by
combining the ENABLE_PRU and BIN_LOAD arguments.</p>
<ul class="simple">
<li><strong>Load additional binaries from flash</strong></li>
</ul>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">gmake</span> <span class="n">bootloader</span> <span class="n">BUILDCFG</span><span class="o">=</span><span class="n">boot</span> <span class="n">BOOTMODE</span><span class="o">=</span><span class="n">mcspi</span> <span class="n">PLATFORM</span><span class="o">=</span><span class="n">am335x</span><span class="o">-</span><span class="n">evm</span> <span class="n">PROFILE</span><span class="o">=</span><span class="n">debug</span> <span class="o">-</span><span class="n">s</span> <span class="n">KW_BUILD</span><span class="o">=</span><span class="n">no</span> <span class="n">BIN_LOAD</span><span class="o">=</span><span class="n">yes</span>
<span class="n">gmake</span> <span class="n">bootloader</span> <span class="n">BUILDCFG</span><span class="o">=</span><span class="n">boot</span> <span class="n">BOOTMODE</span><span class="o">=</span><span class="n">mcspi</span> <span class="n">PLATFORM</span><span class="o">=</span><span class="n">am335x</span><span class="o">-</span><span class="n">evm</span> <span class="n">PROFILE</span><span class="o">=</span><span class="n">release</span> <span class="o">-</span><span class="n">s</span> <span class="n">KW_BUILD</span><span class="o">=</span><span class="n">no</span> <span class="n">BIN_LOAD</span><span class="o">=</span><span class="n">yes</span>
</pre></div>
</div>
<p>The location of binaries in offset is configured using
sbl_flash_offset_cfg.h in the bootloader source. Users are required to
use TIIMAGE tool to append an header to the binary so that the
bootloader knows the loction and size of the binary to be loaded.</p>
<p class="rubric" id="industrial-ddrless-booting">Industrial DDRless Booting</p>
<p>The AMIC110 DDRLESS platform provides a superset flag to enable all the
above features and build the bootloader . The superset build is invoked
using <strong>BUILD_ICSS_DDRLESS_BOOT=yes</strong> as shown below:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">gmake</span> <span class="n">bootloader</span> <span class="n">BUILDCFG</span><span class="o">=</span><span class="n">boot</span> <span class="n">BOOTMODE</span><span class="o">=</span><span class="n">mcspi</span> <span class="n">PLATFORM</span><span class="o">=</span><span class="n">amic110</span><span class="o">-</span><span class="n">ddrless</span> <span class="n">PROFILE</span><span class="o">=</span><span class="n">debug</span> <span class="o">-</span><span class="n">s</span> <span class="n">KW_BUILD</span><span class="o">=</span><span class="n">no</span> <span class="n">BUILD_ICSS_DDRLESS_BOOT</span><span class="o">=</span><span class="n">yes</span>
<span class="n">gmake</span> <span class="n">bootloader</span> <span class="n">BUILDCFG</span><span class="o">=</span><span class="n">boot</span> <span class="n">BOOTMODE</span><span class="o">=</span><span class="n">mcspi</span> <span class="n">PLATFORM</span><span class="o">=</span><span class="n">amic110</span><span class="o">-</span><span class="n">ddrless</span> <span class="n">PROFILE</span><span class="o">=</span><span class="n">release</span> <span class="o">-</span><span class="n">s</span> <span class="n">KW_BUILD</span><span class="o">=</span><span class="n">no</span> <span class="n">BUILD_ICSS_DDRLESS_BOOT</span><span class="o">=</span><span class="n">yes</span>
</pre></div>
</div>
<p>Prebuilt binaries inside the Processor SDK RTOS for AMIC110-DDRLESS will
be configured using this option to allow for testing of cost optimized
industrial use case.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="boot-mode-settings">
<h4>4.6.3.1.7. Boot Mode settings<a class="headerlink" href="#boot-mode-settings" title="Permalink to this headline">¶</a></h4>
<p>Boot mode settings for all supported AM335x and AM437x boards are <a class="reference external" href="http://processors.wiki.ti.com/index.php/Processor_SDK_RTOS_CSL_AM335x/AM437x_Boot_mode_settings">here</a></p>
</div>
<div class="section" id="id3">
<h4>4.6.3.1.8. Boot Modes<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<div class="section" id="booting-via-sd-card">
<h5>4.6.3.1.8.1. Booting Via SD Card<a class="headerlink" href="#booting-via-sd-card" title="Permalink to this headline">¶</a></h5>
<p>Booting from SD Card involves two steps.</p>
<ol class="arabic simple">
<li>Preparing SD card.</li>
<li>Booting target.</li>
</ol>
<div class="section" id="preparing-sd-card">
<h6>4.6.3.1.8.1.1. Preparing SD card<a class="headerlink" href="#preparing-sd-card" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li>To boot target the SD card should be bootable. Follow the steps at
<a class="reference external" href="index_overview.html#windows-sd-card-creation-guide">Creating bootable SD card in windows</a>
or <a class="reference external" href="index_overview.html#linux-sd-card-creation-guide">Creating bootable SD card in Linux</a>.</li>
<li>Delete the &#8220;<em>MLO</em>&#8221; and &#8220;<em>app</em>&#8221; in the bootable SD card which are
created in the process of making the SD bootable.</li>
<li>Bootloader images with ti header (&lt;mmcsd_bootloader&gt;_ti.bin)should be
renamed to &#8220;<em>MLO</em>&#8221;. Bootloader images are located at
<em>&lt;PDK_INSTALL_DIRpackagestistarterwarestarterwarebinarybootloaderbin&lt;TargetType</em>&gt;</li>
<li>Similarly the converted application binary image has to be renamed to
&#8220;<em>app</em>&#8221; from &#8220;<em>&lt;app_name&gt;_ti.bin</em>&#8220;</li>
<li>Copy both the boot loader image &#8220;<em>MLO</em>&#8221; and the application image
&#8220;<em>app</em>&#8221; to the SD card.</li>
<li>The SD card is ready for use on target.</li>
</ol>
</div>
<div class="section" id="booting-target">
<h6>4.6.3.1.8.1.2. Booting target<a class="headerlink" href="#booting-target" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li>Insert SD card to the base board SD slot. Connect a UART cable to a
host running a serial terminal application (teraterm/hyperterminal)
with 115200 baud, 8bit, No parity and 1 STOP bit configuration.</li>
<li>Configure the board for SD Boot mode<ol class="arabic">
<li>SD instance 0 (on base board) is available in all profiles.</li>
<li>SD instance 0 boot mode needs to appropriately set. For SD boot to
be selected first, SD boot should appear first in the boot device
list in the boot mode. If any other boot mode is selected, even if
a SD boot card is inserted, and does not appear first in the list,
the first available sane boot image (like NAND or SPI etc) is
booted and SD is not selected. Only if no sane boot image is found
in the first devices, SD boot image will be selected.</li>
</ol>
</li>
<li>Once SD boot image is chosen, the <em>MLO</em> is first detected and copied
and executed from the OCMC0 RAM. The <em>MLO</em> then copies the
application image (<em>app</em>) from the card to the SDRAM and passes the
control to the application. If the process is succesful, messages
identifying board and SoC will appear on the serial console.</li>
</ol>
<p>After this the application will take control and execute.</p>
<p><strong>NOTE:</strong> If board have BootMode selection pins choose proper Boot
Selection pins from hardware reference manuals.</p>
<div class="line-block">
<div class="line">If the boards have no boot mode selection pins and a valid boot image
is present on McSPI flash, Booting will happen from McSPI flash. Erase
McSPI flash in such cases to boot from SD card <a class="reference external" href="http://processors.wiki.ti.com/index.php?title=StarterWare_Booting_And_Flashing&amp;action=edit&amp;redlink=1">McSPI flash
erase</a>
. The boot sequence depends on ROM bootloader.</div>
</div>
</div>
</div>
<div class="section" id="booting-via-qspi">
<h5>4.6.3.1.8.2. Booting Via QSPI<a class="headerlink" href="#booting-via-qspi" title="Permalink to this headline">¶</a></h5>
<p>Booting from QSPI flash involves two steps-</p>
<ol class="arabic simple">
<li>Preparing Flash Device</li>
<li>Booting target.</li>
</ol>
<div class="section" id="preparing-flash-device">
<h6>4.6.3.1.8.2.1. Preparing Flash Device<a class="headerlink" href="#preparing-flash-device" title="Permalink to this headline">¶</a></h6>
<p>Procedure relies on contents being copied to SD card. Additional
details below:</p>
<ol class="arabic simple">
<li>Copy bootloader image(bootloader_boot_qspi_a9host_debug.bin rename)
and app image(&#8220;&lt;app_name&gt;_ti.bin&#8221;) into the SD card.
The file names have to be renamed in such a way that the length of
name is less than 9 characters. Any file name less than 9 characters
can be used.
Rename the bootloader file to &#8216;boot&#8217; and application image to &#8216;app&#8217;
with no extensions.</li>
<li>Copy the &#8216;config&#8217; file into the SD card which will contain the names
of the image to be flashed and the offset.
A sample config file can be found at
<em>&lt;PDK_INSTALL_DIRpackagestistarterwarestarterwaretoolsqspiconfig&gt;
directory</em>. Do not change name of the <strong>config</strong> file.
<strong>NOTE:</strong> &#8220;config&#8221; file can be used without any modifications if
bootloader and application images are renamed to &#8220;boot&#8221; and &#8220;app&#8221;.
<strong>NOTE:</strong> Do not rename bootloader to be copied to SD card as
&#8220;<em>MLO</em>&#8221;, as MMCSD bootloader expects &#8220;<em>MLO</em>&#8221; and &#8220;<em>app</em>&#8221; to boot.</li>
<li>Now SD card contains 1)boot 2)app 3)config files.
config file contains the address of boot image as <strong>0x0</strong> and app
image as <strong>0x80000</strong>.
Insert it into the SD card slot.</li>
<li>Connect the board with CCS and load the prebuilt qspi flash writer
application from
<em>&lt;PDK_INSTALL_DIRpackagestistarterwarestarterwarebinaryqspi_app_flash_writerbinm43xx-evm&gt;</em></li>
<li>Run the QSPI flash writer application. Following logs expected on
console.</li>
</ol>
<div class="highlight-cpp"><div class="highlight"><pre>StarterWare QSPI Flash Writer!!
BOARDInit status [0x0]
SoC                   : [AM43XX]
Core                  : [A9]
Board Detected        : [IDKEVM]
Base Board Revision   : [UNKNOWN]
Daughter Card Revision: [UNKNOWN]
Copying boot to QSPI Flash
Copying app to QSPI Flash
Changing read to quad mode
Read mode has been changed to Quad mode
SUCCESS!!!
Flashing completed
</pre></div>
</div>
</div>
<div class="section" id="booting-the-target">
<h6>4.6.3.1.8.2.2. Booting the target.<a class="headerlink" href="#booting-the-target" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li>Connect UART cable to a host running serial terminal application
(teraterm/hyperterminal) with 115200 baud, 8bit, No parity and 1 STOP
bit configuration.</li>
<li>After&nbsp;flashing successfully&nbsp;remove SD card and reboot to see
following logs</li>
</ol>
<div class="highlight-cpp"><div class="highlight"><pre>StarterWare Boot Loader
BOARDInit status [0x0]
SoC                   : [AM43XX]
Core                  : [A9]
Board Detected        : [IDKEVM]
Base Board Revision   : [UNKNOWN]
Daughter Card Revision: [UNKNOWN]
Copying Header of the application image
Copying image from flash to DDR
Jumping to StarterWare Application...
</pre></div>
</div>
<div class="highlight-cpp"><div class="highlight"><pre><span class="nl">NOTE:</span> <span class="n">Boot</span> <span class="n">logs</span> <span class="n">will</span> <span class="n">appear</span> <span class="n">approximately</span> <span class="n">after</span> <span class="mi">25</span> <span class="n">seconds</span> <span class="n">on</span> <span class="n">reset</span><span class="p">.</span>
</pre></div>
</div>
<div class="highlight-cpp"><div class="highlight"><pre> <span class="nl">NOTE:</span><span class="n">If</span> <span class="n">there</span> <span class="n">is</span> <span class="n">no</span> <span class="n">boot</span> <span class="n">mode</span> <span class="n">selection</span> <span class="n">present</span> <span class="n">on</span> <span class="n">board</span><span class="p">,</span> <span class="n">boot</span> <span class="n">image</span> <span class="n">will</span> <span class="n">be</span> <span class="n">loaded</span> <span class="n">depending</span> <span class="n">on</span> <span class="n">ROM</span> <span class="n">boot</span> <span class="n">sequence</span>
<span class="nl">Example:</span> <span class="n">If</span> <span class="n">QSPI</span> <span class="n">flash</span> <span class="n">and</span> <span class="n">MMCSD</span> <span class="n">has</span> <span class="n">valid</span> <span class="n">bootloaders</span><span class="p">,</span> <span class="n">on</span> <span class="n">reset</span> <span class="n">MMCSD</span> <span class="n">boot</span> <span class="n">image</span> <span class="n">will</span> <span class="n">be</span> <span class="n">loaded</span> <span class="n">following</span> <span class="n">ROM</span> <span class="n">Boot</span> <span class="n">sequence</span><span class="p">.</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="booting-via-uart">
<h5>4.6.3.1.8.3. Booting Via UART<a class="headerlink" href="#booting-via-uart" title="Permalink to this headline">¶</a></h5>
<p>ROM and Bootloader supports XMODEM protocol with images being binary
not requiring any additional headers. Following are steps for boot:</p>
<ol class="arabic simple">
<li>Configure board for UART boot mode&nbsp;:
UART boot need to be first in the boot device list. Note: In case if
any other boot mode is selected, the first available boot image
(eg:NAND or MMCSD etc) will override. In case of no valid images,
UART boot will be selected.<ul>
<li>Select View-&gt;Memory Browser through CCS.</li>
<li>Select address 0x44e10040.</li>
<li>Write 0x19 to last 2 bytes of this memory address.(UART boot)</li>
<li>Soft reset the board. This is a volatile bit which gets reset
after power on.</li>
</ul>
</li>
<li>ROM code will print &#8220;CC..&#8221; on UART console expecting Bootloader via
XMODEM. File can be sent via xmodem through tera-term File-&gt; Transfer
-&gt; XMODEM -&gt; Send.</li>
<li>On transmitting bootloader
image,&nbsp;bootloader_boot_uart_a9host_debug.bin via XMODEM, following
message will be expected on serial console.</li>
</ol>
<div class="highlight-cpp"><div class="highlight"><pre>CCCCCCCCCCCCCCCCCCCCCCCCCCCC
StarterWare Boot Loader
BOARDInit status [0x0]
 SoC                   : [AM43XX]
 Core                  : [A9]
 Board Detected        : [IDKEVM]
 Base Board Revision   : [UNKNOWN]
 Daughter Card Revision: [UNKNOWN]
GPIO Instance number: 0
Pin number: 22
Please transfer file:
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
</pre></div>
</div>
<p>&nbsp;&nbsp;4.&nbsp; As&nbsp; a next step application binary (without header) can be sent
via XMODEM which will lead to application start executing.</p>
</div>
<div class="section" id="booting-via-mcspi">
<h5>4.6.3.1.8.4. Booting Via McSPI<a class="headerlink" href="#booting-via-mcspi" title="Permalink to this headline">¶</a></h5>
<p>Booting from McSPI involves two steps.</p>
<ol class="arabic simple">
<li>Preparing Flash Device</li>
<li>Booting the target.</li>
</ol>
<p class="rubric" id="preparing-flash-device-1">Preparing Flash Device</p>
<ul class="simple">
<li>Set the appropriate bootmode if applicable for EVM.Refer <a class="reference external" href="http://processors.wiki.ti.com/index.php/Processor_SDK_RTOS_CSL_AM335x/AM437x_Boot_mode_settings">Boot mode
settings</a>.
<strong>Note</strong>: Most of the boards may not have switch settings.</li>
<li>Add a required target configuration in CCS depending on emulator and
board connected.</li>
<li>Connect target to required core. Ex: A8.</li>
<li>Load the flash writer from
<em>&lt;PDK_INSTALL_DIRpackagestistarterwarestarterwaretoolsflash_writerspi_flash_writer_AM335X.out</em>
onto the EVM.</li>
<li>Run the application and observe the logs on CCS console.</li>
</ul>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Starting</span> <span class="n">SPIWriter</span><span class="p">.</span>
<span class="n">Choose</span> <span class="n">Operation</span><span class="o">:</span>
<span class="n">Enter</span> <span class="mi">1</span> <span class="o">----&gt;</span> <span class="n">To</span> <span class="n">FLASH</span> <span class="n">an</span> <span class="n">Image</span>
<span class="n">Enter</span> <span class="mi">2</span> <span class="o">----&gt;</span> <span class="n">To</span> <span class="n">ERASE</span> <span class="n">Flash</span>
<span class="n">Enter</span> <span class="mi">3</span> <span class="o">----&gt;</span> <span class="n">To</span> <span class="n">EXIT</span>
</pre></div>
</div>
<ul class="simple">
<li>When Flash option is chosen program prompts to enter file name.</li>
</ul>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Enter</span> <span class="n">the</span> <span class="n">File</span> <span class="n">Name</span>
</pre></div>
</div>
<ul class="simple">
<li>Provide the complete path of file
<em>bootloader_boot_mcspi_a8host_release_ti.bin</em> at directory
&#8220;binary/bootloader/bin/&lt;PLATFORM&gt;/&lt;gcc/ccs&gt;/&#8221; and hit Enter.</li>
</ul>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Enter</span> <span class="n">the</span> <span class="n">Offset</span> <span class="n">in</span> <span class="n">bytes</span> <span class="p">(</span><span class="n">in</span> <span class="n">HEX</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li>Provide <strong>0x00000</strong> to flash bootloader.</li>
<li>To flash application binary image &lt;app_name&gt;_a8host_ti.bin, provide
<strong>0x20000</strong>.</li>
<li>Wait for few miniuits as flashing is a slower process.</li>
</ul>
<div class="highlight-cpp"><div class="highlight"><pre>Erasing flash at byte offset: xx, byte length: xxxx
SF: Successfully erased xxxx bytes @ xxxx
Writing flash at page offset: x, number of pages: xxxx
Flashing is in progress...
Verifying... Success.
</pre></div>
</div>
<ul class="simple">
<li>Once SPI flash writing completes disconnect target.</li>
</ul>
<p class="rubric" id="id4">Booting the target</p>
<ol class="arabic simple">
<li>Connect a&nbsp;serial cable to a host running a serial terminal
application (teraterm/hyperterminal) with 115200 baud, 8bit, No
parity and 1 STOP bit configuration.</li>
<li>Configure the board for SPI boot mode.</li>
<li>On reset, ROM bootloder copies the bootloader from flash to internal
memory. The bootloader then copies the application image from flash
to DDR and passes the control to the application.</li>
</ol>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="booting-via-nand">
<h5>4.6.3.1.8.5. Booting Via NAND<a class="headerlink" href="#booting-via-nand" title="Permalink to this headline">¶</a></h5>
<p>Booting from NAND involves two steps.</p>
<ol class="arabic simple">
<li>Preparing Flash Device</li>
<li>Booting the target.</li>
</ol>
<p class="rubric" id="preparing-flash-device-2">Preparing Flash Device</p>
<ul class="simple">
<li>Configure BOOT pins for NAND <a class="reference external" href="http://processors.wiki.ti.com/index.php/Processor_SDK_RTOS_CSL_AM335x/AM437x_Boot_mode_settings">Boot mode
settings</a></li>
<li>Connect target with CCS.</li>
<li>Load the
<em>&lt;PDK_INSTALL_DIRpackagestistarterwarestarterwaretoolsflash_writernand_flash_writer_AM335X.out&gt;</em>
to target and Run. Flash writer will output messages to CCS console.
When it prompts for inputs, proper inputs shall be given via CCS
console.</li>
<li>When prompted for binary file name, update file with proper path.</li>
<li>Select option for flashing.</li>
</ul>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Choose</span> <span class="n">your</span> <span class="n">operation</span>
<span class="n">Enter</span> <span class="mi">1</span> <span class="o">---&gt;</span> <span class="n">To</span> <span class="n">Flash</span> <span class="n">an</span> <span class="n">Image</span>
<span class="n">Enter</span> <span class="mi">2</span> <span class="o">---&gt;</span> <span class="n">To</span> <span class="n">ERASE</span> <span class="n">the</span> <span class="n">whole</span> <span class="n">NAND</span>
<span class="n">Enter</span> <span class="mi">3</span> <span class="o">---&gt;</span> <span class="n">To</span> <span class="n">EXIT</span>
</pre></div>
</div>
<ul class="simple">
<li>If Option 1 is selected, enter image path to flash when prompted as
shown below.</li>
</ul>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Enter</span> <span class="n">image</span> <span class="n">file</span> <span class="n">path</span>
</pre></div>
</div>
<p>&nbsp;&nbsp;&nbsp; Provide the complete path (e.g.
&lt;PDK_INSTALL_DIRpackagestistarterwarestarterwarebinarybootloaderbin&lt;am335x/am437x-evm&gt;&lt;compiler&gt;bootloader_boot_nand_a8host_&lt;debug/release&gt;_ti.bin)</p>
<ul class="simple">
<li>Enter offset when prompted as shown below.</li>
</ul>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Enter</span> <span class="n">offset</span> <span class="p">(</span><span class="n">in</span> <span class="n">hex</span><span class="p">)</span><span class="o">:</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">&nbsp;&nbsp;&nbsp; This offset is start location from where the image should be
flashed.</div>
<div class="line">NOTE:</div>
</div>
<ol class="arabic simple">
<li>Use hex format</li>
<li>If bootloader is to be flashed, provide <strong>0x00000</strong>. For application
binary, provide <strong>0x80000</strong>.</li>
</ol>
<ul class="simple">
<li>Select ECC for flashing.</li>
</ul>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Choose</span> <span class="n">the</span> <span class="n">ECC</span> <span class="n">scheme</span> <span class="n">from</span> <span class="n">given</span> <span class="n">options</span>
<span class="n">Enter</span> <span class="mi">1</span> <span class="o">---&gt;</span> <span class="n">BCH</span> <span class="mi">8</span> <span class="n">bit</span>
<span class="n">Enter</span> <span class="mi">2</span> <span class="o">---&gt;</span> <span class="n">HAM</span>
<span class="n">Enter</span> <span class="mi">3</span> <span class="o">---&gt;</span> <span class="n">T0</span> <span class="n">EXIT</span>
<span class="n">Please</span> <span class="n">enter</span> <span class="n">ECC</span> <span class="n">scheme</span> <span class="n">type</span><span class="o">:</span>
</pre></div>
</div>
<p>&nbsp;&nbsp;&nbsp; Always select BCH8 for bootloader and application as ROM code and
bootloader uses the BCH8 ECC scheme.</p>
<ul class="simple">
<li>Ensure that flash info displayed by tool matches NAND flash in EVM.</li>
<li>After this tool should first erase the required region in flash and
then start flashing new image.</li>
<li>If flashing procedure is complete following message should be
displayed.</li>
</ul>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Application</span> <span class="n">is</span> <span class="n">successfully</span> <span class="n">flashed</span>
<span class="n">NAND</span> <span class="n">flashing</span> <span class="n">successful</span><span class="o">!</span>
</pre></div>
</div>
<ul class="simple">
<li>Once NAND flash writing completes, disconnect from CCS.</li>
</ul>
<p class="rubric" id="booting-the-target-1">Booting the target</p>
<ul class="simple">
<li>Connect a UART cable to a host running a serial terminal application
(teraterm/hyperterminal) with 115200 baud, 8bit, No parity and 1 STOP
bit configuration.</li>
<li>Configure the board for NAND boot mode. Refer&nbsp; <a class="reference external" href="http://processors.wiki.ti.com/index.php/Processor_SDK_RTOS_CSL_AM335x/AM437x_Boot_mode_settings">Boot mode
settings</a></li>
<li>On reset, ROM detects bootloader from NAND and copies it to internal
memory. Bootloader then copies application image from the NAND to DDR
and passes control to application. If the process is succesful,
following messages appear in serial console.</li>
</ul>
<div class="highlight-cpp"><div class="highlight"><pre>   StarterWare Boot Loader
BOARDInit status [0x0]
SoC                   : [AM335X]
Core                  : [A8]
Board Detected        : [GPEVM]
Base Board Revision   : [1.5]
Daughter Card Revision: [UNKNOWN]
NAND flash is connected to GPMC on this board
Jumping to StarterWare Application...
</pre></div>
</div>
<p>After this application should take control and execute.</p>
</div>
</div>
<div class="section" id="test-application">
<h4>4.6.3.1.9. Test Application<a class="headerlink" href="#test-application" title="Permalink to this headline">¶</a></h4>
<p>The section explains steps for building and booting a sample pdk
application for am335x or am437x using MMCSD bootloader.</p>
<div class="section" id="test-application-image-creation">
<h5>4.6.3.1.9.1. Test Application Image Creation<a class="headerlink" href="#test-application-image-creation" title="Permalink to this headline">¶</a></h5>
<p>Follow below steps to generate the bootable application image.</p>
<ol class="arabic simple">
<li>Generate .out files using steps for <a class="reference external" href="index_how_to_guides.html#rebuild-drivers-from-pdk-directory">Rebuilding
PDK</a>. Locate .out file in directory
<em>&lt;PDK_INSTALL_PATH/MyExampleProjects/&lt;ExampleProjectDirectory&gt;/Debug&gt;</em></li>
<li>Convert files to support MMCSD boot using steps as per <a class="reference external" href="index_Foundational_Components.html#binary-format-conversion-procedure">Binary format
conversion procedure</a>.</li>
<li>Rename generated &lt;Application&gt;_ti.bin to &#8220;app&#8221;.</li>
</ol>
</div>
<div class="section" id="loading-test-application">
<h5>4.6.3.1.9.2. Loading Test application<a class="headerlink" href="#loading-test-application" title="Permalink to this headline">¶</a></h5>
<p>Follow procedure to use &#8220;app&#8221; file as per section <a class="reference external" href="index_Foundational_Components.html#booting-via-sd-card">Booting Via SD
Card</a>.</p>
</div>
</div>
<div class="section" id="usage-notes">
<h4>4.6.3.1.10. Usage Notes<a class="headerlink" href="#usage-notes" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><strong>Bootloader Memory map</strong></li>
</ul>
<p>The bootloader code runs from internal OCMC memory and occupies certain
amount of OCMC memory that is not available for application to use
during booting.</p>
<p>Refer to the map file for the boot loader to check for latest
information on the memory utilization in the boot loader.</p>
<p>Location of linker command file:</p>
<div class="highlight-cpp"><div class="highlight"><pre>BASE_DIR\binary\bootloader\bin\&lt;platform&gt;\gcc
</pre></div>
</div>
<p>After SBL execution is complete, this region can be used as per
application requirement.</p>
<ul class="simple">
<li><strong>Configuring entry point for SBL</strong></li>
</ul>
<p>The three files that help setup the entry point in the bootloader build
are &#8220;PDK_INSTALL_PATHpackagestistarterwaresocarmv7agccsbl_init.S&#8221;
and the linker command file
&#8220;PDK_INSTALL_PATHpackagestistarterwareexamplesgcc&lt;device&gt;_boot.lds&#8221;.
The global symbol Entry is used to provide the entry point to the
bootloader. The Base address of the memory section OCMCRAM (starts at 1K
offset in OCMC RAM as defined in TRM) is then used by the tiimage or
GPHEader tool to provide RBL the guidance to find the entry point to
pass control. After MLO is created check the TI image format file(
_ti.bin) to confirm that the entry point matches the location of Entry
symbol in the .map file.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The object file created by sbl_init.S should always be the first object
file in the link order for the symbol Entry to be placed at the BASE
address of the memory section SBL_MEM</p>
</div>
<ul class="simple">
<li><strong>Boot image creation tools generates a large boot image if load
sections are fragmented</strong></li>
</ul>
<p>Please note that when using objcopy the compiler generates a contiguous
binary that gets loaded by the bootloader at the location specified in
the header appended by TIIMAGE boot utility. IF you have some code
sections in OCMC or SRAM and some section in DDR the compiler will
generates a binary that spans across full memory range which would be in
order of MB or even GB size so it is recommended that you create compact
binaries that can be loaded into memory or implement a ELF parser to
bootloader memory sections that may be fragmented in the address space.
you can also load separate binaries for OCMC sections and DDR memory and
load the sections separately</p>
<ul class="simple">
<li><strong>Removing Heap section from application binary to speed up boot
times</strong></li>
</ul>
<p>A common issue reported with the ARM GCC compiler is that it appends
Heap section associated with the binary to the binary image used to
boot. The Heap section is usually filled with zeros so can cause
significant delay in boot times. Essentially the bootloader will be
writing a bunch of zeros in memory so is inefficient. Following work
around has been used to circumvent the issue</p>
<p><strong>Option 1:</strong> Eliminate the heap by using the compiler option
&#8220;&#8211;remove-section&#8221; as described in the E2E post below:</p>
<p><strong>Refer:</strong> <a class="reference external" href="https://e2e.ti.com/support/arm/sitara_arm/f/791/p/604616/2225826">E2E post to configure Heap in ARM application binary by
adding
&#8220;&#8211;remove-section&#8221;</a></p>
<p><strong>Example BIOS configuration:</strong></p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">var</span> <span class="n">heap1</span> <span class="o">=</span> <span class="n">HeapMem</span><span class="p">.</span><span class="n">create</span><span class="p">();</span>
<span class="n">heap1</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">256</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
<span class="n">heap1</span><span class="p">.</span><span class="n">sectionName</span> <span class="o">=</span> <span class="s">&quot;.stack&quot;</span><span class="p">;</span>
<span class="n">Memory</span><span class="p">.</span><span class="n">defaultHeapInstance</span> <span class="o">=</span> <span class="n">heap1</span><span class="p">;</span>
</pre></div>
</div>
<p><strong>Compiler Setting&nbsp;:</strong> &#8211;remove-section=.stack</p>
<p><strong>Option 2</strong> Configure Segment type to be &#8220;NO LOAD&#8221; in .cfg and use
excludeSections</p>
<p>SYSBIOS Memory map configurations allows user to specify the section
name, length and type. by configuring the section type to &#8220;NOLOAD&#8221; and
using excludeSection option the heap memory can be eliminated from the
final binary.</p>
<p><strong>Example BIOS configuration:</strong></p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Program</span><span class="p">.</span><span class="n">sectMap</span><span class="p">[</span><span class="s">&quot;.biosheap&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Program</span><span class="p">.</span><span class="n">SectionSpec</span><span class="p">();</span>
<span class="n">Program</span><span class="p">.</span><span class="n">sectMap</span><span class="p">[</span><span class="s">&quot;.biosheap&quot;</span><span class="p">].</span><span class="n">runSegment</span> <span class="o">=</span> <span class="s">&quot;DDR2&quot;</span>
<span class="n">Program</span><span class="p">.</span><span class="n">sectMap</span><span class="p">[</span><span class="s">&quot;.biosheap&quot;</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="s">&quot;NOLOAD&quot;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Program</span><span class="p">.</span><span class="n">sectionsExclude</span> <span class="o">=</span> <span class="s">&quot;.biosheap&quot;</span>
</pre></div>
</div>
<p>Alternate approach using linker command file:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="p">.</span><span class="n">ddr3Heap</span> <span class="p">(</span><span class="n">NOLOAD</span><span class="p">)</span><span class="o">:</span>
  <span class="p">{</span>
      <span class="o">*</span><span class="p">(.</span><span class="n">ddr3Heap</span><span class="p">)</span>
  <span class="p">}</span> <span class="o">&gt;</span> <span class="n">HOST_DDR3</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The approach described above helps improve boot times but Users are
recommended to initialize the HEAP sections to zeros post boot during
initialization to avoid any undesired behavior during normal operation
of the app</p>
</div>
</div>
<div class="section" id="debugging-application-boot">
<h4>4.6.3.1.11. Debugging application boot<a class="headerlink" href="#debugging-application-boot" title="Permalink to this headline">¶</a></h4>
<p>Steps to debug application boot using Processor SDK RTOS bootloader are
discussed in the article <strong>`Common steps to debug application
boot &lt;index_Foundational_Components.html#common-steps-to-debug-application-boot&gt;`__</strong></p>
</div>
</div>
<div class="section" id="am57x">
<h3>4.6.3.2. AM57x<a class="headerlink" href="#am57x" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id5">
<h4>4.6.3.2.1. Overview<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>The Secondary Bootloader (SBL) for AM57xx device initializes the
execution environment for multi-core application and this can be used to
demonstrate an out-of-box experience.The section covers additional
details including execution sequence, tools and additional flashing
instructions.</p>
</div>
<div class="section" id="id6">
<h4>4.6.3.2.2. Bootloader Execution Sequence<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><strong>Power On Reset</strong></li>
<li><strong>ROM Bootloader (RBL)</strong><ul>
<li>Software pre-programmed in ROM memory starts executing</li>
<li>Checks Sysboot pins and choose booting device</li>
<li>If no valid bootloader found on booting device, RBL checks for
next booting device.</li>
<li>Platform configuration and initialization.</li>
<li>Configures DPLL and clock settings for MPU, and boot media like
I2C, MMCSD, SD/MMC, SPI, QSPI, Ethernet etc for reliable boot.</li>
<li>The sequence depends on RBL execution flow and Sysboot pins.</li>
<li>RBL gets image size and load address by checking TI Image Header
appended on bootloader binary(.bin). Check&nbsp;binary formats.</li>
<li>Loads the binary to internal memory at the Load address fetched
from TI Image Header</li>
<li>Passes control to Secondary Bootloader(SBL)</li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Detailed description of ROM bootloader is provided in Initialization
Chapter in <a class="reference external" href="http://www.ti.com/lit/pdf/spruhz6">AM57xx Technical Reference
manual</a></p>
</div>
<ul class="simple">
<li><strong>Secondary bootloader(SBL)</strong><ul>
<li>User level secondary bootloader(SBL) begins execution from
internal memory by running basic initialization routines like
setting up Stack, BSS and then jumps to main() to begin Board
Initialization.</li>
<li>Board Initialization is done by a call to <strong>Board_init()</strong> API.For
additional details refer <a class="reference external" href="index_board.html#board-support">Processor SDK Board
Support</a>.</li>
<li>It includes setting up PLLs, enabling clocks to all interfaces and
modules, performing pinmux and setting up UART console.</li>
<li>Once Board Initialization is complete, it enables clocks to the
slave cores like C66x/DSP, IPU, etc and brings them out of reset.</li>
<li>Parses Multicore Application image located in memory device and
copies it&nbsp;to&nbsp;DDR memory based on load address for different
sections.</li>
<li>Once copy is successful&nbsp;it transfers control to application.</li>
</ul>
</li>
<li><strong>Application then starts executing from DDR</strong>.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>RBL requires boot loader to be in a special format with a header
appended to the binary image. The header shall contain the load
address of the bootloader and size of the bootloader image.</li>
<li>For more information on the TI header refer TRM document</li>
</ul>
</div>
</div>
<div class="section" id="directory-structure">
<h4>4.6.3.2.3. Directory structure<a class="headerlink" href="#directory-structure" title="Permalink to this headline">¶</a></h4>
<p><strong>Makefiles:</strong></p>
<ul class="simple">
<li><strong>PDK_INSTALL_PATH/ti/boot/sbl/board/&lt;EVAL_BOARD&gt;/build</strong>: Makefile
for bootloader that provides list of source files and library and
compiler options to create bootloader binary.</li>
</ul>
<p><strong>Source Files:</strong></p>
<ul class="simple">
<li><strong>PDK_INSTALL_PATH/ti/boot/sbl/board/&lt;EVAL_BOARD&gt;</strong>: Source to SBL
main function that consolidates all features</li>
<li><strong>PDK_INSTALL_PATH/ti/boot/sbl/soc</strong>: Source to SOC specific
initialization used in the SBL.</li>
<li><strong>PDK_INSTALL_PATH/ti/boot/sbl/src</strong>: Source to boot media specific
initialization used in the SBL.</li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="id7">
<h4>4.6.3.2.4. Tools and Binary Formats<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>This section lists out the various tools and scripts used by SBL for
different boot modes&nbsp;and those required to create a bootable application
image.</p>
<p><strong>SBL/MLO image format:</strong>
To generate the <em>MLO</em>, SBL uses tiImageGen tool to prepend the sbl.bin
image with the TI header information. The image format has been
described in detail in the Image Format Section of the<a class="reference external" href="http://www.ti.com/lit/pdf/spruhz6">AM57xx
Technical Reference manual</a></p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p><strong>Application image format:</strong>
A bootable application image can be created by using the Am57xImageGen
script provided under tools folder as part of sbl. It can be located at
<em>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools/scripts</em> folder.</p>
<p>The Am57xImageGen script uses out2rprc and multicoreImageGen format
conversion tools to create the final application image. Graphical view
of the multicore application image is provided below:</p>
<img alt="../_images/Multicore_app_image.png" src="../_images/Multicore_app_image.png" />
<p>The script creates the bootable image in 2 steps</p>
<p><strong>Step 1: Conversion to RPRC format conversion</strong></p>
<ul class="simple">
<li>Firstly, application executable is converted from ELF/COFF format
(.out) to custom TI Rprc binary image using out2rprc tool. This tool
strips out the initialized sections from the executable file (i.e.
*.out) and places them in a compact format that the SBL can
understand. The output (bin) file is typically much smaller than the
original executable (out) file.</li>
<li>The rprc files are intermediate files in a format that is consumed by
MulticoreImageGen tool that generates the final binary.</li>
</ul>
<p><strong>RPRC File Header Format</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Offset</th>
<th class="head">Binary value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x00000000</td>
<td><strong>Magic Word(43525052)</strong></td>
</tr>
<tr class="row-odd"><td>0x00000004</td>
<td><strong>Entry Point (Location)</strong></td>
</tr>
<tr class="row-even"><td>0x00000008</td>
<td><strong>Reserved Addr</strong></td>
</tr>
<tr class="row-odd"><td>0x0000000C</td>
<td><strong>Section Count</strong></td>
</tr>
<tr class="row-even"><td>0x00000010</td>
<td><strong>Version</strong></td>
</tr>
</tbody>
</table>
<p><strong>RPRC Section Header Format</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Offset</th>
<th class="head">Binary value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x00000000</td>
<td><strong>Section start Address</strong></td>
</tr>
<tr class="row-odd"><td>0x00000004</td>
<td><strong>Reserved Addr</strong></td>
</tr>
<tr class="row-even"><td>0x00000008</td>
<td><strong>Size</strong></td>
</tr>
<tr class="row-odd"><td>0x0000000C</td>
<td><strong>Reserved CRC</strong></td>
</tr>
<tr class="row-even"><td>0x00000010</td>
<td><strong>Reserved</strong></td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p><strong>Step 2: Multicore Image file generation</strong></p>
<ul class="simple">
<li>RPRC files for each cores is combined into a single multicore
bootable application image.</li>
</ul>
<p><strong>Multicore boot image format</strong></p>
<p><strong>Meta Header Start</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Offset</th>
<th class="head">Binary value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x00000000</td>
<td><strong>Magic String (0x5254534D)</strong></td>
</tr>
<tr class="row-odd"><td>0x00000004</td>
<td><strong>Number of Files</strong></td>
</tr>
<tr class="row-even"><td>0x00000008</td>
<td><strong>Device ID</strong></td>
</tr>
<tr class="row-odd"><td>0x0000000C</td>
<td><strong>Reserved</strong></td>
</tr>
</tbody>
</table>
<p><strong>Meta Header per Core</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Offset</th>
<th class="head">Binary value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x00000000</td>
<td><strong>Core ID</strong></td>
</tr>
<tr class="row-odd"><td>0x00000004</td>
<td><strong>Image Offset</strong></td>
</tr>
</tbody>
</table>
<p>Core ID and Device ID for specific devices can be located in the file
sbl_slave_core_boot.h in the boot/sbl/soc/&lt;SOC_NAME&gt; folder</p>
<p>Refer section <a class="reference external" href="index_Foundational_Components.html#application-image-creation">App Image
Creation</a>
for more details on usage of this script and application image creation.</p>
<p><strong>Flashing Tools</strong></p>
<p>SBL provides a CCS based qspi flash writer utility to flash image and
multicore AppImage from a SD card to onboard QSPI device. It
is&nbsp;located at <em>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools/flashWriter/qspi</em></p>
</div>
<div class="section" id="building-the-sbl">
<h4>4.6.3.2.5. Building the SBL<a class="headerlink" href="#building-the-sbl" title="Permalink to this headline">¶</a></h4>
<p><strong>Pre-requisites to Building</strong></p>
<ul class="simple">
<li>Set your environment using pdksetupenv.bat or pdksetupenv.sh. Refer
to the Processor SDK RTOS Building page for information on setting up
your build environment</li>
<li>The SBL has following dependencies and will need the following
libraries built<ul>
<li>Board</li>
<li>UART</li>
<li>I2C</li>
<li>SPI</li>
<li>CSL</li>
<li>OSAL</li>
<li>MMCSD</li>
<li>PM</li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Refer to the makefile for the board you are using for the latest driver
dependency. These libraries should come pre-built with any fresh
installation of the Processor SDK RTOS but may be removed if a gmake
clean is invoked</p>
</div>
<p><strong>Compiling the SBL Components</strong></p>
<p>To build the SBL components:</p>
<ol class="arabic simple">
<li><strong>cd &lt;PDK&gt;/packages/ti/board/diag</strong></li>
<li><strong>make all BOARD=&lt;BOARD_NAME&gt; SOC=&lt;SOC_NAME&gt; BOOTMODE=&lt;BOOTMEDIA&gt;</strong></li>
</ol>
<ul class="simple">
<li>BOARD_NAME&nbsp;: idkAM572x, idkAM571x, evmAM572x, idkAM574x</li>
<li>SOC_NAME&nbsp;: AM572x, AM571x, AM574x</li>
</ul>
<p>This will make the SBL for a specific $BOARD and $BOOT_MEDIA. Output
files will be located in: <strong>&lt;PDK&gt;/packages/ti/boot/sbl/binary/&lt;BOARD&gt;</strong></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Refer <strong>&lt;PDK&gt;/packages/ti/boot/sbl/sbl_&lt;DEVICE&gt;.sh</strong> for more build
options</p>
</div>
<p class="rubric" id="id8">Boot Modes</p>
<p>This Release of SBL supports MMCSD and QSPI Boot modes. The different
boot modes supported for all the boards is tabulated in the table below.</p>
<table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="14%" />
<col width="14%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&nbsp;</td>
<td>MMCSD</td>
<td>QSPI</td>
<td>eMMC</td>
</tr>
<tr class="row-even"><td>AM572x GPEVM</td>
<td>YES</td>
<td>NO</td>
<td>YES</td>
</tr>
<tr class="row-odd"><td>AM572x IDKEVM</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr class="row-even"><td>AM571x IDKEVM</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr class="row-odd"><td>AM574x IDKEVM</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="section" id="id9">
<h5>4.6.3.2.5.1. Booting Via SD Card<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h5>
<ol class="arabic simple">
<li>Preparing the SD card.</li>
<li>Booting the target.</li>
</ol>
<div class="section" id="preparing-the-sd-card">
<h6>4.6.3.2.5.1.1. Preparing the SD card<a class="headerlink" href="#preparing-the-sd-card" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li>To boot the target the SD card should be bootable. Follow the steps
at <a class="reference external" href="index_overview.html#windows-sd-card-creation-guide">Creating bootable SD card in windows</a>
or <a class="reference external" href="index_overview.html#linux-sd-card-creation-guide">Creating bootable SD card in Linux</a>.</li>
<li>Delete the &#8220;MLO&#8221; and &#8220;app&#8221; in the bootable SD card which are created
in the process of making the SD bootable.</li>
<li>Copy the sbl binary(MLO) to the SD card.</li>
<li>Copy the Application image(app) generated using the
<a class="reference external" href="index_Foundational_Components.html#application-image-creation">Script</a>
to the SD card.</li>
</ol>
</div>
<div class="section" id="id10">
<h6>4.6.3.2.5.1.2. Booting the target<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li>Insert micro SD card into the SD card slot of the board.</li>
<li>Open a serial communication terminal like TeraTerm, MiniCom on host
PC and connect to the UART console port</li>
<li>Do a power reset of the board to boot the appliation from the SD
card.</li>
</ol>
</div>
</div>
<div class="section" id="booting-via-emmc">
<h5>4.6.3.2.5.2. Booting Via eMMC<a class="headerlink" href="#booting-via-emmc" title="Permalink to this headline">¶</a></h5>
<ol class="arabic simple">
<li>Preparing the eMMC.</li>
<li>Booting the target.</li>
</ol>
<div class="section" id="preparing-the-emmc">
<h6>4.6.3.2.5.2.1. Preparing the eMMC<a class="headerlink" href="#preparing-the-emmc" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li>To format the eMMC of the target board, Run the following application on the target board
<a class="reference external" href="Device_Drivers.html#id6">USB_DevMsc_mmcsd</a> .</li>
<li>To boot the target the eMMC should be bootable. Follow the steps same as SD card
formatting as given
at <a class="reference external" href="Overview.html#windows-sd-card-creation-guide">Creating bootable SD card in windows</a>
or <a class="reference external" href="Overview.html#linux-sd-card-creation-guide">Creating bootable SD card in Linux</a>
except instead of SD card, connect the target board eMMC to the host PC.</li>
<li>Delete the &#8220;MLO&#8221; and &#8220;app&#8221; in the bootable eMMC which are created
in the process of making the eMMC bootable.</li>
<li>Copy the sbl binary(MLO) to the eMMC.</li>
<li>Copy the Application image(app) generated using the
<a class="reference external" href="Foundational_Components.html#application-image-creation">Script</a>
to the eMMC.</li>
</ol>
</div>
<div class="section" id="id11">
<h6>4.6.3.2.5.2.2. Booting the target<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li>Set boot settings to eMMC by selecting J3, J4 and J6 jumpers on Pin 2 and 3
of AM572x EVM Board.</li>
<li>Ensure there is no SD card inserted in the SD card slot.</li>
<li>Open a serial communication terminal like TeraTerm, MiniCom on host
PC and connect to the UART console port</li>
<li>Do a power reset of the board to boot the appliation from the eMMC.</li>
</ol>
</div>
</div>
<div class="section" id="id12">
<h5>4.6.3.2.5.3. Booting Via QSPI<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h5>
<p>Booting from QSPI flash involves two steps-</p>
<ol class="arabic simple">
<li>Flashing bootloader and app image&nbsp;to QSPI flash.</li>
<li>Booting the target.</li>
</ol>
<div class="section" id="id13">
<h6>4.6.3.2.5.3.1. Preparing Flash Device<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h6>
<p>Use the CCS based qspi_flash_writer.out utility provided in
&lt;<em>TI_PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools/flashwriter/qspi/&lt;Board&gt;&#8217;</em>
to flash&nbsp;the SBL image at offset 0 and application image at offset
0x80000 to the QSPI device.</p>
<p>QSPI device Memory Map:</p>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="64%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Offset 0x00</td>
<td>SBL</td>
</tr>
<tr class="row-even"><td>Offset 0x80000</td>
<td>Application Multicore Image</td>
</tr>
</tbody>
</table>
<p>The images can be flashed into QSPI flash by following steps given
below.</p>
<ol class="arabic simple">
<li>Copy QSPI mode SBL image
<em>TI_PDK_INSTALL_DIRpackagestibootsblbinary&lt;BoardName&gt;qspibinMLO</em>
and application image(app) generated using the Script into the SD
card.
Rename the bootloader file to &#8216;boot&#8217; and application image to &#8216;app&#8217;
with no extensions.</li>
<li>Copy &#8216;config&#8217; file into the SD card, the&nbsp;config file&nbsp;should contain
names of the image to be flashed and the offset.
A sample config file can be found at
<em>TI_PDK_INSTALL_DIRpackagestibootsbltoolsflashWriterqspiconfig</em>.
Do not change the name of the config file.
<strong>NOTE:</strong> &#8220;config&#8221; file can be used without any modifications if
bootloader and application images are renamed to &#8220;boot&#8221; and &#8220;app&#8221;.
<strong>NOTE:</strong> Do not rename the bootloader to be copied to SD card as
&#8220;MLO&#8221;, as MMCSD bootloader expects &#8220;MLO&#8221; and &#8220;app&#8221; to boot.</li>
<li>Now SD card contains 3 files 1)boot 2)app 3)config files.
config file contains the address of boot image as 0x0 and app image
as 0x80000.
Insert it into the SD card slot.</li>
<li>Connect the board with CCS and and load the prebuilt qspi flash
writer application from
$(TI_PDK_INSTALL_DIR)packagestibootsbltoolsflashWriterqspibin&lt;BoardName&gt;\</li>
<li>Run the QSPI flash writer application. You will see the following
logs on the EVM&#8217;s UART console.</li>
<li>After the images have been flashed to the QSPI device disconnect from
CCS and do a power reset to boot from the QSPI memory.</li>
</ol>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">PDK</span> <span class="n">QSPI</span> <span class="n">Flash</span> <span class="n">Writer</span><span class="o">!!</span>
<span class="n">Copying</span> <span class="n">boot</span> <span class="n">to</span> <span class="n">QSPI</span> <span class="n">Flash</span>
<span class="n">Copying</span> <span class="n">app</span> <span class="n">to</span> <span class="n">QSPI</span> <span class="n">Flash</span>
<span class="n">Changing</span> <span class="n">read</span> <span class="n">to</span> <span class="n">quad</span> <span class="n">mode</span>
<span class="n">Read</span> <span class="n">mode</span> <span class="n">has</span> <span class="n">been</span> <span class="n">changed</span> <span class="n">to</span> <span class="n">Quad</span> <span class="n">mode</span>
<span class="n">SUCCESS</span><span class="o">!!!</span>
<span class="n">Flashing</span> <span class="n">completed</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>The file names have to be renamed in such a way that the length of
name is less than 9 characters. Any file name less than 9 characters
can be used.</li>
<li>This application will flash the image at required offset without
taking into consideration any overwriting to previously flashed
image.</li>
<li>It is the responsibility of the user to provide proper offsets.</li>
</ul>
</div>
</div>
</div>
</div>
<div class="section" id="id14">
<h4>4.6.3.2.6. Test Application<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<p>SBL provides a test application to demonstrate booting of multicore
application image on A15 and DSP cores.The multicore sample
application uses mailbox for inter-processor communication. It is used
to validate the multi-core boot-up use case.</p>
<p>Master application sends wake-up message to the DSP slave cores &amp; waits
for acknowledgement message from the slave cores in an infinite
loop.Each slave DSP core waits for wake-up message from the master core
responds back with an acknowledgement message.</p>
<div class="section" id="application-image-creation">
<h5>4.6.3.2.6.1. Application Image Creation<a class="headerlink" href="#application-image-creation" title="Permalink to this headline">¶</a></h5>
<p>Application Image creation involves two steps.</p>
<ol class="arabic simple">
<li>Generating the .outs of applications for individual cores</li>
<li>Combining the .outs of individual cores to create a bootable
multicore image</li>
</ol>
<p>The steps to create the bootable image in Linux and Windows environment
are listed below.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>Valid SOC settings are AM571x/AM572x</li>
<li>Valid BOARD settings are evmAM572x/idkAM571x/idkAM572x</li>
</ul>
</div>
</div>
<div class="section" id="linux-environment">
<h5>4.6.3.2.6.2. Linux Environment<a class="headerlink" href="#linux-environment" title="Permalink to this headline">¶</a></h5>
<p>Command to build the test application.</p>
<div class="highlight-cpp"><div class="highlight"><pre>Go to cd (TI_PDK_INSTALL_DIR)\packages\ti\boot\sbl

make example BOARD=&lt;BOARD&gt; SOC=&lt;SOC&gt; to build the application
make example_clean BOARD=&lt;BOARD&gt;
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">make</span> <span class="n">example</span> <span class="n">BOARD</span><span class="o">=</span><span class="n">idkAM572x</span> <span class="n">SOC</span><span class="o">=</span><span class="n">AM572x</span>
</pre></div>
</div>
<p>To create the final bootable application image use the AM57xImageGen
script and follow these steps</p>
<p>1. Set the following environment variable in the shell.&nbsp; BIN_PATH:
Pointing to the path where the AppImage needs to be generated</p>
<div class="highlight-cpp"><div class="highlight"><pre>Ex: export BIN_PATH=$(TI_PDK_INSTALL_DIR)/packages/ti/boot/sbl/binary
</pre></div>
</div>
<p>2. Edit the script file to point to the application elf files by setting
the input application variables.</p>
<p>App_MPU_CPU0: Point to the path where the application .out for A15 MPU is located
App_DSP1: Point to the path where the dsp core 1 application is located
App_DSP2: Point to the path where the dsp core 2 application is located</p>
<div class="highlight-cpp"><div class="highlight"><pre>export APP_MPU_CPU0=$(TI_PDK_INSTALL_DIR)/packages/ti/boot/sbl/binary/idkAM572x/example/armv7/bin/sbl_app.out

export APP_DSP1=$(TI_PDK_INSTALL_DIR)/packages/ti/boot/sbl/binary/idkAM572x/example/c66/dsp1/bin/sbl_app.xe66

export APP_DSP2=$(TI_PDK_INSTALL_DIR)/packages/ti/boot/sbl/binary/idkAM572x/example/c66/dsp2/bin/sbl_app.xe663

export APP_IPU1_CPU0=$(TI_PDK_INSTALL_DIR)/packages/ti/boot/sbl/binary/idkAM572x/example/m4/ipu1/bin/sbl_app.xem4

export APP_IPU1_CPU0=$(TI_PDK_INSTALL_DIR)/packages/ti/boot/sbl/binary/idkAM572x/example/m4/ipu2/bin/sbl_app.xem4
</pre></div>
</div>
<p>3. If it is not required to load an application on specific core leave
the variable blank.</p>
<ol class="arabic simple" start="4">
<li>Run the script file AM57xImageGen found under the path $(TI_PDK_INSTALL_DIR)/packages/ti/boot/sbl/tools/scripts</li>
</ol>
<p>5. An application image by name app is created in the path pointed by
BIN_PATH variable</p>
<p>6. Copy the Bootlaoder image(MLO) and application(app) in the SD card to
boot using MMCSD boot mode.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>The AM57xImageGen.sh script depends on tools like mono to execute the
out2rprc.exe.</li>
<li>The linux host environment needs to have this tool installed to
execute this script.</li>
<li>Refer this link to download the
<a class="reference external" href="http://www.mono-project.com">mono</a> tool</li>
</ul>
</div>
</div>
<div class="section" id="windows-environment">
<h5>4.6.3.2.6.3. Windows environment<a class="headerlink" href="#windows-environment" title="Permalink to this headline">¶</a></h5>
<p>Command to build the test application.</p>
<div class="highlight-cpp"><div class="highlight"><pre>Go to cd (TI_PDK_INSTALL_DIR)\packages\ti\boot\sbl

gmake example BOARD=&lt;BOARD&gt; SOC=&lt;SOC&gt; to build the application
gmake example_clean BOARD=&lt;BOARD&gt;
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">gmake</span> <span class="n">example</span> <span class="n">BOARD</span><span class="o">=</span><span class="n">idkAM572x</span> <span class="n">SOC</span><span class="o">=</span><span class="n">AM572x</span>
</pre></div>
</div>
<p>To create the final bootable application image use the AM57xImageGen
script and follow these steps</p>
<ol class="arabic simple">
<li>Set the following environment variable in windows command prompt</li>
</ol>
<p>BIN_PATH: Pointing to the path where the AppImage needs to be generated</p>
<div class="highlight-cpp"><div class="highlight"><pre>Ex:  set BIN_PATH=%TI_PDK_INSTALL_DIR%\packages\ti\boot\sbl\binary
</pre></div>
</div>
<p>2. Edit the batch file to point to the application elf files by setting
the input application variables.</p>
<p>App_MPU_CPU0: Point to the path where the application .out for A15 MPU is located
App_DSP1: Point to the path where the dsp core 1 application is located
App_DSP2: Point to the path where the dsp core 2 application is located</p>
<div class="highlight-cpp"><div class="highlight"><pre>set App_MPU_CPU0=%TI_PDK_INSTALL_DIR%\packages\ti\boot\sbl\binary\idkAM572x\example\armv7\bin\sbl_app.out

set App_DSP1=%TI_PDK_INSTALL_DIR%\packages\ti\boot\sbl\binary\idkAM572x\example\c66\dsp1\bin\sbl_app.xe66

set App_DSP2=%TI_PDK_INSTALL_DIR%\packages\ti\boot\sbl\binary\idkAM572x\example\c66\dsp2\bin\sbl_app.xe66

set App_IPU1_CPU0=%TI_PDK_INSTALL_DIR%\packages\ti\boot\sbl\binary\idkAM572x\example\m4\ipu1\bin\sbl_app.xem4

set App_IPU2_CPU0=%TI_PDK_INSTALL_DIR%\packages\ti\boot\sbl\binary\idkAM572x\example\m4\ipu2\bin\sbl_app.xem4
</pre></div>
</div>
<p>3. If it is not required to load an application on specific core leave
the variable blank.</p>
<ol class="arabic simple" start="4">
<li>Run the batch file AM57xImageGen found under the path $(TI_PDK_INSTALL_DIR)/packages/ti/boot/sbl/tools/scripts</li>
</ol>
<p>5. Follow the steps 4 to 6 listed above for Linux environment.
|
Setup Requirements
&#8220;&#8221;&#8220;&#8221;&#8220;&#8221;&#8220;&#8221;&#8220;&#8221;&#8220;&#8221;&#8220;&#8221;&#8220;&#8221;&#8220;&#8221;&#8220;&#8221;
For information on board specific requirements like power supply, UART
console port connections refer the Hardware User guide of the respective
boards.</p>
<p>The configurations needed to setup&nbsp;UART console&nbsp;through a serial
terminal&nbsp;application on host PC&nbsp;are listed in the next section.</p>
<div class="section" id="uart-console-setup">
<h6>4.6.3.2.6.3.1. UART Console Setup<a class="headerlink" href="#uart-console-setup" title="Permalink to this headline">¶</a></h6>
<p>PDK SBL prints messages on the UART Serial Console running on the host.
Hence, a serial terminal application (like Tera
Term/HyperTerminal/minicom) should be running on the host.</p>
<p>The host serial port&nbsp;must be&nbsp;configured at 115200 baud, no parity, 1
stop bit and no flow control.
Please ensure that the local echo setting for the terminal is turned off.</p>
</div>
<div class="section" id="loading-the-test-application">
<h6>4.6.3.2.6.3.2. Loading the test application<a class="headerlink" href="#loading-the-test-application" title="Permalink to this headline">¶</a></h6>
<p>Follow these steps to load the test application using a SD card on the
target</p>
<p>copy the MLO to your SD card (located
at&nbsp;%TI_PDK_INSTALL_DIR%packagestibootsblbinary[BOARD]mmcsd)</p>
<ol class="arabic simple">
<li>copy the example app located at path pointed to by BIN_PATH to your
SD card</li>
<li>insert your SD card into your board and power on your board</li>
<li>open teraterm to connect to the board&#8217;s UART console</li>
<li>press the &#8220;Hard Reset&#8221; button on your board</li>
</ol>
<p>On Successful bootup you should see the following logs on the UART
console for a AM572x based board.</p>
<img alt="../_images/Sbl_example.jpg" src="../_images/Sbl_example.jpg" />
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">MPU Core 0 example does a sequential check of mailbox messages sent from
the other cores. On rare occasions, the check happens before the message
is sent - the &#8220;&lt;core&gt; boot-up Successful&#8221; message might not be displayed
even though the core(s) were booted successfully.</p>
</div>
</div>
</div>
</div>
<div class="section" id="application-integration">
<h4>4.6.3.2.7. Application Integration<a class="headerlink" href="#application-integration" title="Permalink to this headline">¶</a></h4>
<div class="section" id="memory-map">
<h5>4.6.3.2.7.1. Memory Map<a class="headerlink" href="#memory-map" title="Permalink to this headline">¶</a></h5>
<p>Table indicated below provides memory map details for SBL image in
OCMC_RAM1.&nbsp; For more details on pinmux and IO delay requirements refer
this link <a class="reference external" href="index_board.html#board-support">Processor SDK Board
Support</a></p>
<p>We recommend that users should refer to the linker command file and the
map file for the boot loader to check for latest information on the
memory utilization in the boot loader.</p>
<p><strong>Location of linker command file</strong>:
&lt;PDK_INSTALL_PATH&gt;packagestibootsblboard&lt;BOARD&gt;build</p>
<p>The SBL memory map is shown below</p>
<img alt="../_images/SBL_memory_map.png" src="../_images/SBL_memory_map.png" />
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>After the application boots and is running on the SOC, it is free to
use the SBL_MEM region.</li>
<li>The pinmux data from the board library and MMU Table are part of the
SBL_MEM region indicated in the figure above. If pinmux data needs to
be placed at a specific location then users can update the SBL linker
command file to add the BOARD_IO_DELAY_CODE and BOARD_IO_DELAY_DATA
as described in <a class="reference external" href="index_board.html#application-integration-for-am5x-dra7xx">Application Integration of board library for
AM5x</a></li>
</ul>
</div>
</div>
</div>
<div class="section" id="sbl-customization">
<h4>4.6.3.2.8. SBL Customization<a class="headerlink" href="#sbl-customization" title="Permalink to this headline">¶</a></h4>
<div class="section" id="changing-boot-media-offsets">
<h5>4.6.3.2.8.1. Changing boot media offsets<a class="headerlink" href="#changing-boot-media-offsets" title="Permalink to this headline">¶</a></h5>
<p>The location at which SBL resides on the flash is predefined by the ROM
bootloader spec and so these defaults can`t be changed. However the SBL
is a user defined bootloader so many of the defaults can easily be
modified to meet application requirements. For example the flash offset
location from which the bootloader reads the application is configured
in the source files located under
PDK_INSTALL_PATHpackagestibootsblsrc&lt;BOOT_MEDIA&gt;</p>
<p>Examples of customization that can be changed:
-  QSPI/SPI flash offsets: These offsets are configured in sbl_qspi.c</p>
<blockquote>
<div>and sbl_spi.c</div></blockquote>
<ul class="simple">
<li>MMCSD: The name of the application is hard coded as app in function
SBL_MMCBootImage in the sbl_mmcsd.c</li>
</ul>
</div>
<div class="section" id="speeding-up-boot-by-increasing-speed-of-the-boot-interface">
<h5>4.6.3.2.8.2. Speeding up boot by increasing speed of the boot interface<a class="headerlink" href="#speeding-up-boot-by-increasing-speed-of-the-boot-interface" title="Permalink to this headline">¶</a></h5>
<p>The SBL for AM57xx devices uses LLD drivers to read and write from boot
media supported. The SBL uses the default SOC configuration of the
drivers and the speeds setup. For example, the SPI driver default SPI
bitrate is 1 MHz (Refer
PDK_INSTALL_PATHpackagestidrvspisrcSPI_drv.c) so if you wish to
speed up boot you can update the SPI parameter in the SBL as shown
below:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">SPI_Params_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spiParams</span><span class="p">);</span>
<span class="n">spiParams</span><span class="p">.</span><span class="n">bitRate</span> <span class="o">=</span> <span class="mi">24000000U</span><span class="p">;</span>
</pre></div>
</div>
<p>The configuration of the driver is usually done in the
boot/sbl/soc/&lt;device&gt;/sbl_soc.c file.</p>
<ul class="simple">
<li><strong>For SD/MMC</strong>: You can configure higher speed and change bus width
using MMCSD_v1_HwAttrs_s or MMCSD_v0_HwAttrs_s</li>
<li><strong>For QSPI</strong>: 2 pin and 4 pin mode, and input frequency is configured
using QSPI_HwAttrs in the QSPI driver. Check driver for defaults.</li>
</ul>
<p>Also, check to see if the CACHE and MMU settings for the ARM core are
setup to enable fast boot.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><strong>SYSBOOT settings for AM57xx</strong></p>
<p class="last">The SYSBOOT configuration in your hardware using Sitara devices
(AM3/AM4/AM5) can play a big role in the time required to boot
successfully. On these devices the boot pins configure a boot sequence
for the ROM bootloader to check for valid boot image so if you have a
preferred boot mode designers are required to use SYSBOOT setup such
that the preferred boot media is first in the boot sequence. If the
preferred boot media occurs later boot sequence, the boot is likely to
add the time required by RBL to check other boot media for an valid
image. For example if QSPI is the preferred boot media on your AM57xx
hardware then you should have system configure SYSBOOT to boot of QSPI
first using SYSBOOT setting for QSPI_1 or QSPI4 for Memory preferred
booting or Production booting (Refer: Initialization chapter in
TRM).Incorrect SYSBOOT configuration can causes long delays especially
if peripheral boot is configured to be one of the preferred boot modes
in the boot order</p>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="reducing-size-of-sbl-and-application">
<h5>4.6.3.2.8.3. Reducing size of SBL and application<a class="headerlink" href="#reducing-size-of-sbl-and-application" title="Permalink to this headline">¶</a></h5>
<p>Another way to optimize boot times is to reduce the size of the binary
that needs to be loaded by the bootloader by building the app with
optimization for code size using -Os (GNU GCC) and for -O&lt;level&gt; when
using TI compilers.</p>
<p>Other than compiler based optimizations developers can actively shutdown
non-essential modules and features to reduce code size. For example if
UART logging is not required or DDR memory is not connected in the
system, the initialization functions can be removed to reduce code size.</p>
</div>
</div>
<div class="section" id="id15">
<h4>4.6.3.2.9. Usage Notes<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h4>
<div class="section" id="sbl-avs-and-abb-setup">
<h5>4.6.3.2.9.1. SBL AVS and ABB setup<a class="headerlink" href="#sbl-avs-and-abb-setup" title="Permalink to this headline">¶</a></h5>
<p>AVS and ABB configuration is mandated for normal operation of AM57xx
devices. All Processor SDK RTOS releases v3.3 and later contain SBL that
sets up AVS and ABB configuration features using PM LLD APIs The
complete details of PMIC configuration and AVS and ABB configuration
required by the chip for different OPP has been implemented in the file:</p>
<p>PDK_INSTALL_PATHpackagestibootsblboardsrcsbl_avs_config.c If you
are using the same PMIC as GP EVM or IDK platform then you can reuse the
settings as is in SBL for your custom platform</p>
</div>
<div class="section" id="configuring-entry-point-for-sbl">
<h5>4.6.3.2.9.2. Configuring entry point for SBL<a class="headerlink" href="#configuring-entry-point-for-sbl" title="Permalink to this headline">¶</a></h5>
<p>The two key files that help setup the entry point in the SBL build are
&#8220;sbl/soc/&lt;SOC_NAME&gt;/sbl_init.S&#8221; and the linker command file
&#8220;sbl/soc/&lt;SOC_NAME&gt;/linker.cmd&#8221;. The global symbol Entry is used to
provide the entry point to the SBL. The Base address of the memory
section SBL_MEM is then used by the tiimage and GP Header tool to
provide RBL the guidance to find the entry point to pass control. After
MLO is created check the TI image format file(MLO or _ti.bin) or the GP
Header file to confirm that the entry point matches the location of
Entry symbol in the sbl.map</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The object file created by sbl_init.S should always be the first object
file in the link order for the symbol Entry to be placed at the BASE
address of the memory section SBL_MEM</p>
</div>
</div>
<div class="section" id="id16">
<h5>4.6.3.2.9.3. Debugging application boot<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h5>
<p>Steps to debug application boot using Processor SDK RTOS bootloader are
discussed in the article <a class="reference external" href="index_Foundational_Components.html#common-steps-to-debug-application-boot">Common steps to debug application
boot</a></p>
</div>
</div>
</div>
<div class="section" id="am65x">
<h3>4.6.3.3. AM65x<a class="headerlink" href="#am65x" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id17">
<h4>4.6.3.3.1. Overview<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h4>
<p>The Secondary Bootloader (SBL) for AM65xx device initializes the execution
environment for multi-core application and this can be used to demonstrate
a real world product experience.The section covers additional details
including execution sequence, tools and additional flashing instructions.</p>
<p>The SBL is essentially a baremetal application, and it uses many components
from the Processor SDK</p>
<ul class="simple">
<li>&lt;PDK&gt;/packages/ti/build : For  build infrastructure</li>
<li>&lt;PDK&gt;/packages/ti/csl : For initialization and SoC addresses</li>
<li>&lt;PDK&gt;/packages/ti/board : For board and usecase specific initialization</li>
<li>&lt;PDK&gt;/packages/ti/drv/spi :  For reading applications from OSPI flashes</li>
<li>&lt;PDK&gt;/packages/ti/drv/udma :  For reading data from boot media using DMA</li>
<li>&lt;PDK&gt;/packages/ti/drv/mmcsd : For reading applications from MMC/SD/eMMC</li>
<li>&lt;PDK&gt;/packages/ti/fs/fatfs : For reading files from MMC/SD/eMMC</li>
<li>&lt;PDK&gt;/packages/ti/drv/sciclient : For communicating with DMSC sub-system</li>
<li>&lt;PDK&gt;/packages/ti/drv/uart : For log messages</li>
<li>&lt;PDK&gt;/packages/ti/osal : Primitives required by ti/drv components</li>
</ul>
<p class="rubric" id="id18">Bootloader Execution Sequence</p>
<ul class="simple">
<li><strong>Power On Reset</strong></li>
<li><strong>ROM Bootloader (RBL)</strong><ul>
<li>Software pre-programmed in AM65xx ROM memory starts executing</li>
<li>The RBL performs platform configuration and initialization.</li>
<li>It then checks sysboot pins and chooses booting device</li>
<li>The RBL then configures DPLL and clock settings for MPU, and
boot media like eMMC, SD/MMC, OSPI, UART, PCIe, Ethernet etc for reliable
boot.</li>
<li>If no valid bootloader found on booting device, the RBL checks for next
booting device, based on sysboot pins</li>
<li>The gets image size and load address by checking the X.509 certificate that
is part of the bootloader image.</li>
<li>The RBL then verifies, optionally decrypts and loads the binary to internal
memory at the Load address fetched from X.509 certificate.</li>
<li>Finally it passes control to Secondary Bootloader(SBL) running on the R5.</li>
</ul>
</li>
<li><strong>Secondary bootloader(SBL)</strong><ul>
<li>User level secondary bootloader(SBL) begins execution from internal memory.
It enables ATCM, starts PMU timers for profiling, initializes the MCU,
and sets up the stack, heap and globals. It then jumps to main().</li>
<li>Board Initialization is done by calls to <strong>Board_init()</strong> API.For additional
details refer <a class="reference external" href="http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/Board_EVM_Abstration.html">Processor SDK Board Support</a>.</li>
<li>First the Pin MUX and UART console are setup by a calls to <strong>Board_init()</strong>. Then the
system firmware (SYSFW) is loaded from the boot media into the DMSC subsystem.</li>
<li>Once the SYSFW is up and running, the rest of the initialization can be done.</li>
<li>This includes optionally using <strong>Board_init()</strong> to configure PLLs, LPSCs and DDR.</li>
<li>The SBL then parses application image(s) for each of the core(s) from boot
media and loads it to memory.</li>
<li>Once the application is loaded, the SBL communicates with the system firmware
to setup the clocks for the core and release it from reset.</li>
<li>The core then starts executing from application entry point.</li>
</ul>
</li>
</ul>
<div
style="margin: 5px; padding: 2px 10px; background-color: #ecffff; border-left: 5px solid #3399ff;"><p><strong>NOTE</strong></p>
<ul class="simple">
<li>RBL requires boot loader to be in a special format with a X.509 certificate
appended to the binary image. The certificate contains the load address, size
and SHA of the bootloader image.</li>
<li>For a detailed description of ROM bootloader and more information on the image
format expected by the RBL refer the initialization chapter in the <a class="reference external" href="http://www.ti.com/lit/pdf/spruid7">AM65xx Technical
Reference Manual</a></li>
<li>In addition to the bootloader and application, the DMSC firmware binary is also needed
for the SoC to complete the boot flow.</li>
<li>The first 256 bytes of the ATCM are reserved by SBL for its use. The SBL initializes
the ATCM with 0xFF before it uses it.</li>
<li>When the R5 is released from reset, it will always fetch and execute the first
intruction from address 0x0.</li>
</ul>
</div></div>
<div class="section" id="block-diagram">
<span id="am655x-sbl-high-level-arch"></span><h4>4.6.3.3.2. Block Diagram<a class="headerlink" href="#block-diagram" title="Permalink to this headline">¶</a></h4>
<img alt="../_images/k3_sbl_srch_block_diag.png" src="../_images/k3_sbl_srch_block_diag.png" />
</div>
<div class="section" id="am655x-sbl-memory-usage">
<span id="id19"></span><h4>4.6.3.3.3. Memory Map<a class="headerlink" href="#am655x-sbl-memory-usage" title="Permalink to this headline">¶</a></h4>
<img alt="../_images/k3_sbl_mem_uage.png" src="../_images/k3_sbl_mem_uage.png" />
</div>
<div class="section" id="am655x-sbl-directory-structure">
<span id="id20"></span><h4>4.6.3.3.4. Directory structure<a class="headerlink" href="#am655x-sbl-directory-structure" title="Permalink to this headline">¶</a></h4>
<div class="highlight-cpp"><div class="highlight"><pre>sbl
│
├── board
│   └── k3
│       └── sbl_main.c                                      &lt;= define main() for SBL, board specific init
│
├── build
│   ├── makefile                                            &lt;= makefile for the SBL component
│   ├── sbl_am65xx.sh                                       &lt;= For legacy, called by Yocto build
│   ├── sbl_boot_test.mk                                    &lt;= Builds SBL single core tests
│   ├── sbl_smp_test.mk                                     &lt;= Builds example app for using SBL lib
│   ├── sbl_mcu0_boot_perf_test.mk                          &lt;= Builds example app for SBL performance tuning
│   ├── sbl_img.mk                                          &lt;= builds SBL image that is loaded and executed by ROM code
│   ├── sbl_lib.mk                                          &lt;= Builds sbl library that other apps can link into
│   ├── sbl_multicore_smp.mk                                &lt;= Builds multi-core image from SBL lib eg. test to demonstrate symmetric multiprocessor boot (SMP)
│   └── sbl_multicore_amp.mk                                &lt;= Builds multi-core image from single core tests to demonstrate asymmetric multiprocessor boot (AMP)
│
├── example
│   └── k3MulticoreApp
│       ├── binary
│       │   └── am65xx
│       │       └── sbl_baremetal_*.appimage                &lt;= SBL loadable board specific sample apps for testing SBL boot flow
│       ├── mcuAmplinker.lds                                &lt;= Linker comamnd file when TI CGT is used for Asym. Multiproc. boot
│       ├── mpuAmplinker.lds                                &lt;= GCC linker command file (for Cortex Axx cores) for Asym. Multiproc. boot
│       ├── mcuBootPerfLinker.lds                           &lt;= TI CGT Linker comamnd file for SBL performance tuning example.
│       ├── mcuLockStepLinker.lds                           &lt;= Linker comamnd file when TI CGT is used for R5 lock-step boot
│       ├── mpuSmplinker.lds                                &lt;= GCC linker command file (for Cortex Axx cores) for SMP boot
│       ├── sbl_amp_multicore.c                             &lt;= Simple SBL test that displays UART message
│       ├── sbl_amp_multicore_sections.h                    &lt;= Allows same source to be loaded to different sections for different cores.
│       ├── sbl_mcu_0_boot_perf_benchmark.c                 &lt;= SBL Test to tune boot performance.
│       ├── sbl_multicore_a53.asm                           &lt;= Test case entry point  for Cortex-Axx cores
│       ├── sbl_multicore_r5.asm                            &lt;= Test case entry point for Cortex-R5 cores
│       ├── sbl_multicore_r5_sections.inc                   &lt;= Allows same source to be loaded to different sections for different MCUs.
│       ├── sbl_printf.c                                    &lt;= Lightweight UART printf function for SBL testing
│       ├── sbl_smp_multicore.c                             &lt;= Simple SBL SMP test that uses SBL lib to reset MPUs
│       └── sbl_smp_r5.asm                                  &lt;= Provides dummy override function for __mpu_init for SMP testcase.
│
├── binary                                                  &lt;= ROM bootable SBL images for each board/boot media
│   ├── am65xx_evm
│   │   ├── mmcsd
│   │   │   └── bin
│   │   │       └── sbl_mmcsd_img_mcu1_0_release.tiimage
│   │   └── ospi
│   │       └── bin
│   │           └── sbl_ospi_img_mcu1_0_release.tiimage
│   └── am65xx_idk
│       ├── mmcsd
│       │   └── bin
│       │       └── sbl_mmcsd_img_mcu1_0_release.tiimage
│       └── ospi
│           └── bin
│               └── sbl_ospi_img_mcu1_0_release.tiimage
│
├── lib                                                     &lt;= SBL lib for each boot media/board supported
│   ├── mmcsd
│   │   ├── am65xx_evm
│   │   │   └── r5f
│   │   │       └── release
│   │   │           └── sbl_lib_mmcsd.aer5f
│   │   └── am65xx_idk
│   │       └── r5f
│   │           └── release
│   │               └── sbl_lib_mmcsd.aer5f
│   │
│   └── ospi
│       ├── am65xx_evm
│       │   └── r5f
│       │       └── release
│       │           └── sbl_lib_ospi.aer5f
│       └── am65xx_idk
│           └── r5f
│               └── release
│                   └── sbl_lib_ospi.aer5f
│
├── soc                                                     &lt;= SOC specific SBL code
│   └── k3
│       ├── linker.cmd                                      &lt;= Linker file used for generating ROM loadable SBL image.
│       ├── sbl_err_trap.h                                  &lt;= Error loops for SBL
│       ├── sbl_init.asm                                    &lt;= SBL Entry point
│       ├── sbl_misc.asm                                    &lt;= SBL Assembly utility functions
│       ├── sbl_log.h                                       &lt;= SBL logging framework
│       ├── sbl_sci_client.c                                &lt;= Calls SYSFW on DMSC
│       ├── sbl_sci_client.h
│       ├── sbl_slave_core_boot.c                           &lt;= Code that contains the sequence to release a core from reset
│       ├── sbl_slave_core_boot.h
│       ├── sbl_soc.c                                       &lt;= Cache Ops, PMU init etc..
│       └── sbl_profile.h                                   &lt;= SBL profiling framework
│
├── src                                                     &lt;= Common drivers used across SOCs
│   ├── mmcsd
│   ├── ospi
│   ├── qspi
│   ├── rprc                                                &lt;= RPRC image parser used by SBL
│   └── spi
│
└── tools
    ├── btoccs
    ├── byteswap
    ├── ccsutil
    ├── flashWriter                                         &lt;= Unused for AM65xx. AM65xx uses Uniflash to program flashes.
    ├── multicoreImageGen                                   &lt;= Stitches multiple RPRC images for different cores into a single image
    ├── omapl13x_boot_utils                                 &lt;= Unused for AM65xx
    ├── omapl13x_sd_card_format                             &lt;= Unused for AM65xx
    ├── out2rprc                                            &lt;= Converts .out into .rprc files, so that SBL can load non-continuous memory sections
    ├── scripts                                             &lt;= Scripts used by .out  generated by CCS projects into SBL loadable images
    │   ├── AM65xxImageGen.bat
    │   └── AM65xxImageGen.sh
    └── tiImageGen                                          &lt;= Unused for AM65xx. Image generation is handled by PDK build framework (&lt;prsdk_install_path&gt;/pdk_*/packages/ti/build/)
</pre></div>
</div>
</div>
<div class="section" id="image-formats">
<span id="am655x-image-formats"></span><h4>4.6.3.3.5. Image Formats<a class="headerlink" href="#image-formats" title="Permalink to this headline">¶</a></h4>
<p><strong>SBL format:</strong></p>
<p>To generate the a bootable image, the SBL build uses x509CertificateGen script to
sign the sbl binary with so that the ROM Boot Loader (RBL) can parse it. The image
format expected by the RBL has been described in detail in the Image Format Section
of the <a class="reference external" href="http://www.ti.com/lit/pdf/spruid7">AM65xx Technical Reference Manual</a></p>
<p><strong>Application image format:</strong></p>
<p>Two utilities - out2rprc and multicoreImageGen are used to convert an application elf
image(s) into an image loadable by the SBL. The structure of a multicore application
image is provided below:</p>
<img alt="../_images/Multicore_app_image.png" src="../_images/Multicore_app_image.png" />
<p><strong>RPRC File Header Format</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Offset</th>
<th class="head">Binary value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x00000000</td>
<td><strong>Magic Word(43525052)</strong></td>
</tr>
<tr class="row-odd"><td>0x00000004</td>
<td><strong>Entry Point (Location)</strong></td>
</tr>
<tr class="row-even"><td>0x00000008</td>
<td><strong>Reserved Addr</strong></td>
</tr>
<tr class="row-odd"><td>0x0000000C</td>
<td><strong>Section Count</strong></td>
</tr>
<tr class="row-even"><td>0x00000010</td>
<td><strong>Version</strong></td>
</tr>
</tbody>
</table>
<p><strong>RPRC Section Header Format</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Offset</th>
<th class="head">Binary value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x00000000</td>
<td><strong>Section start Address</strong></td>
</tr>
<tr class="row-odd"><td>0x00000004</td>
<td><strong>Reserved Addr</strong></td>
</tr>
<tr class="row-even"><td>0x00000008</td>
<td><strong>Size</strong></td>
</tr>
<tr class="row-odd"><td>0x0000000C</td>
<td><strong>Reserved CRC</strong></td>
</tr>
<tr class="row-even"><td>0x00000010</td>
<td><strong>Reserved</strong></td>
</tr>
</tbody>
</table>
<p><strong>Multicore boot image format</strong></p>
<p><strong>Meta Header Start</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Offset</th>
<th class="head">Binary value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x00000000</td>
<td><strong>Magic String (0x5254534D)</strong></td>
</tr>
<tr class="row-odd"><td>0x00000004</td>
<td><strong>Number of Files</strong></td>
</tr>
<tr class="row-even"><td>0x00000008</td>
<td><strong>Device ID</strong></td>
</tr>
<tr class="row-odd"><td>0x0000000C</td>
<td><strong>Reserved</strong></td>
</tr>
</tbody>
</table>
<p><strong>Meta Header per Core</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Offset</th>
<th class="head">Binary value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x00000000</td>
<td><strong>Core ID</strong></td>
</tr>
<tr class="row-odd"><td>0x00000004</td>
<td><strong>Image Offset</strong></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="building-the-sbl-and-its-components">
<h4>4.6.3.3.6. Building the SBL and its components<a class="headerlink" href="#building-the-sbl-and-its-components" title="Permalink to this headline">¶</a></h4>
<p><strong>Pre-requisites to Building</strong></p>
<ul class="simple">
<li>Set your environment using pdksetupenv.bat or pdksetupenv.sh. Refer to
<a class="reference external" href="http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/index_overview.html#setup-environment">Processor SDK RTOS Building</a> for information on setting up your build environment</li>
</ul>
<div
style="margin: 5px; padding: 2px 10px; background-color: #ecffff; border-left: 5px solid #3399ff;"><p><strong>NOTE</strong></p>
<ul class="simple">
<li>SBL needs openssl to build. To check if openssl is present, type the
following at the linux or windows prompt.</li>
</ul>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">openssl</span> <span class="n">version</span>
</pre></div>
</div>
<ul class="simple">
<li>To build on Linux, you need to have <a class="reference external" href="http://www.mono-project.com">mono</a> installed.</li>
<li>Refer <a class="reference external" href="http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/Overview.html#command">Build Dependencies</a> for instructions on how to install these tools,
if they are not already present on your system.</li>
</ul>
</div><p><strong>Compiling the SBL</strong></p>
<p>To build all the SBL components:</p>
<div class="highlight-cpp"><div class="highlight"><pre>cd &lt;PDK&gt;/packages/ti/boot/sbl/build
gmake BOOTMODE=&lt;BOOTMEDIA&gt; clean all (for windows)
make BOOTMODE=&lt;BOOTMEDIA&gt; clean all  (for Linux)
BOOTMEDIA : mmcsd, ospi
</pre></div>
</div>
<ul class="simple">
<li>SBL image files are be located at: <strong>&lt;PDK&gt;/packages/ti/boot/sbl/binary/</strong></li>
<li>SBL examples are located at <strong>&lt;PDK&gt;/packages/ti/boot/sbl/examples/k3MulticoreApp/binary</strong></li>
<li>SBL lib are located at <strong>&lt;PDK&gt;/packages/ti/boot/sbl/lib/</strong></li>
</ul>
<p><strong>Compile time options for the SBL</strong></p>
<p>The SBL supports several compile time options to tweak the SBL to satisfy requirements of
ease of use, boot time and size. These can be enabled or disabled by editing <a class="reference external" href="http://git.ti.com/keystone-rtos/sbl/blobs/master/sbl_component.mk">sbl/sbl_component.mk</a></p>
<ul class="simple">
<li>SBL_LOG_LEVEL : Controls amount of SBL logs on the MCU UART. Varies from 0
(no logs) to  3 (all logs)</li>
<li>SBL_DISPLAY_PROFILE_INFO : At the end of the boot process, displays a log of timestamps
at which different SBL profile points are hit. This is useful to see how much
time the SBL spends in different functions.</li>
<li>SBL_ENABLE_PLL : Dials up all the PLLs calling Board_init(). Makes it easier for
applications as they no longer have to initialize the PLLs. However, enabling this
significantly increases boot time and power consumption. Requires system firmware to
be loaded.</li>
<li>SBL_ENABLE_CLOCKS : Enables all the module clocks by calling Board_init(). Makes
it easier for applications as they no longer have to enable clocks.</li>
<li>SBL_ENABLE_DDR : Initializes the DDR. At the cost of boot time, this enables
applications to run from and use DDR. SBL_ENABLE_CLOCKS and SBL_ENABLE_PLL must
also be enabed for this to work. Enabling this option increases the boot time.</li>
<li>SBL_SKIP_MCU_RESET : Jumps to the MCU0 application entry point
without resetting the core. Enables faster boot time. Will change the MCU&#8217;s
mode (lock-step/split). Application also inherits the MCU state as the SBL
left it in.</li>
</ul>
<div
style="margin: 5px; padding: 2px 10px; background-color: #ecffff; border-left: 5px solid #3399ff;"><p><strong>NOTE</strong></p>
<ul class="simple">
<li>Refer <strong>&lt;PDK&gt;/packages/ti/boot/sbl/buid/sbl_am65xx.sh</strong> for more build options</li>
</ul>
</div><p id="am655x-compiling-apps-for-sbl"><strong>Compiling apps that can be loaded by SBL:</strong></p>
<p><strong>Memory Map Considerations</strong></p>
<p>Applications that the SBL loads must comply with the <a class="reference internal" href="#am655x-sbl-memory-usage">am655x-sbl-memory-usage</a>.
In the application&#8217;s linker command file, care must be taken to not use the first
0x100 bytes of either MCU&#8217;s ATCM memory and SBL reserved memory from 0x41C00100
to 0x41C28000.</p>
<div
style="margin: 5px; padding: 2px 10px; background-color: #ecffff; border-left: 5px solid #3399ff;"><p><strong>NOTE</strong></p>
<ul class="simple">
<li>The local address 0x0 of the MPU is not accessible from the MCU, so any MPU linker
command file must not specify any loadable sections in that memory region. The SBL
will not be able to access that memory to load code or data.</li>
</ul>
</div><p><strong>Converting ELF executables to SBL loadable image</strong></p>
<p>Depending on the usecase, an ELF application executable can be converted into an
image that can be loaded by SBL in many ways.</p>
<ul class="simple">
<li><strong>Using CCS</strong>: Any project created using the pdkProjectCreate scripts will
automatically generate a SBL loadable app, as part of a post-build step.</li>
<li><strong>Using makefiles</strong>: Add the following lines to the component&#8217;s .mk file</li>
</ul>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">app_name_SBL_APPIMAGEGEN</span> <span class="o">=</span> <span class="n">yes</span>
<span class="k">export</span> <span class="n">app_name_SBL_APPIMAGEGEN</span>
</pre></div>
</div>
<ul class="simple">
<li><strong>Existing ELF executable</strong>: By calling the AM65xxImageGen script.</li>
</ul>
<div class="highlight-cpp"><div class="highlight"><pre>Linux Syntax: AM65xxImageGen.sh &lt;CoreID&gt; &lt;.out&gt;

Example:
cd  &lt;prsdk_install_path&gt;/pdk_*/packages/ti/boot/sbl/example/ampMulticoreApp/binary/am65xx_evm/
AM65xxImageGen.sh 4 sbl_baremetal_boot_test_am65xx_evm_mcu1_0TestApp_release.xer5f
</pre></div>
</div>
<div class="highlight-cpp"><div class="highlight"><pre>Windows Syntax: AM65xxImageGen.bat &quot;&lt;CoreID&gt; &lt;.out&gt;&quot;

Example:
cd  &lt;prsdk_install_path&gt;\pdk_*\packages\ti\boot\sbl\example\ampMulticoreApp\binary\am65xx_evm\
AM65xxImageGen.bat &quot;4 sbl_baremetal_boot_test_am65xx_evm_mcu1_0TestApp_release.xer5f&quot;
</pre></div>
</div>
<ul class="simple">
<li><strong>Multicore Images</strong>: Multicore images, as the name suggests, allows the SBL
to load applications for multiple cores from a single image. Creating such images
invloves three steps.</li>
</ul>
<ol class="arabic simple">
<li>Generate the ELF application executables for individual cores</li>
<li>Convert the ELF executables into intermediate .rprc images</li>
<li>Combine the .rprc images of individual cores to create a single multicore image</li>
</ol>
<p>To covert any .out into the intermediate .rprc format, execute the following commands</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">For</span> <span class="n">Linux</span><span class="o">:</span>
<span class="n">mono</span> <span class="o">&lt;</span><span class="n">PDK</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">sbl</span><span class="o">/</span><span class="n">tools</span><span class="o">/</span><span class="n">out2rprc</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">out2rprc</span><span class="p">.</span><span class="n">exe</span> <span class="n">input</span><span class="p">.</span><span class="n">out</span> <span class="n">output</span><span class="p">.</span><span class="n">rprc</span>
</pre></div>
</div>
<div class="highlight-cpp"><div class="highlight"><pre>For Windows:
&lt;PDK&gt;\packages\ti\boot\sbl\tools\out2rprc\bin\out2rprc.exe input.out output.rprc
</pre></div>
</div>
<p>To stitch multiple .rprc images into a multicore image, execute the following command</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">For</span> <span class="n">Linux</span><span class="o">:</span>
<span class="o">&lt;</span><span class="n">PDK</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">sbl</span><span class="o">/</span><span class="n">tools</span><span class="o">/</span><span class="n">multicoreImageGen</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">MulticoreImageGen</span> <span class="n">LE</span> <span class="mi">55</span> <span class="n">output</span><span class="p">.</span><span class="n">appimage</span>  <span class="o">&lt;</span><span class="n">core_id_1</span><span class="o">&gt;</span> <span class="n">core_1</span><span class="p">.</span><span class="n">rprc</span> <span class="o">&lt;</span><span class="n">core_id_2</span><span class="o">&gt;</span> <span class="n">core_2</span><span class="p">.</span><span class="n">rprc</span>
</pre></div>
</div>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">For</span> <span class="n">Windows</span><span class="o">:</span>
<span class="o">&lt;</span><span class="n">PDK</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">sbl</span><span class="o">/</span><span class="n">tools</span><span class="o">/</span><span class="n">multicoreImageGen</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">MulticoreImageGen</span><span class="p">.</span><span class="n">exe</span> <span class="n">LE</span> <span class="mi">55</span> <span class="n">output</span><span class="p">.</span><span class="n">appimage</span>  <span class="o">&lt;</span><span class="n">core_id_1</span><span class="o">&gt;</span> <span class="n">core_1</span><span class="p">.</span><span class="n">rprc</span> <span class="o">&lt;</span><span class="n">core_id_2</span><span class="o">&gt;</span> <span class="n">core_2</span><span class="p">.</span><span class="n">rprc</span>
</pre></div>
</div>
<div
style="margin: 5px; padding: 2px 10px; background-color: #ecffff; border-left: 5px solid #3399ff;"><p><strong>NOTE</strong></p>
<ul class="simple">
<li>The linux host environment needs to have <a class="reference external" href="http://www.mono-project.com">mono</a> installed.</li>
<li>The values used for the Core ID and Device ID can be found in <a class="reference external" href="http://git.ti.com/keystone-rtos/sbl/blobs/master/soc/k3/sbl_slave_core_boot.h#line51">sbl/soc/k3/
sbl_slave_core_boot.h</a></li>
<li>To simply load an ELF without executing it, use CoreID value ONLY_LOAD_ID</li>
<li>If an image for MCU_1 core is provided, the SBL will attempt to switch to
split mode.</li>
<li>If only an image for MCU_0 is provided, the SBL will not change the mode of the
MCU subsystem.</li>
<li>To enable SMP on the MPU, ie, to get multiple MPUs execute from a single binary
from the same address, use one of the following core_ids<ul>
<li>MPU1_SMP_ID: The same app binary runs on both cores in MPU cluster 1</li>
<li>MPU2_SMP_ID: The same app binary runs on both cores in MPU cluster 2</li>
<li>MPU_SMP_ID:  The same app binary runs all the MPUs</li>
</ul>
</li>
</ul>
</div></div>
<div class="section" id="testing-the-sbl">
<h4>4.6.3.3.7. Testing the SBL<a class="headerlink" href="#testing-the-sbl" title="Permalink to this headline">¶</a></h4>
<p>SBL provides a test applications to demonstrate booting the A53 and R5 cores in
both symmetric/lock step &amp; asymmetric/split-mode.The multicore sample application
prints a message on the UART for each core. The functionality the different tests
exercises are listed below.</p>
<ul class="simple">
<li>sbl_*_boot_test_*_all_coresTestApp_release: A single multicore boot test case
that boots each core in the SoC with a separate app. Also tests DDR loading</li>
<li>sbl_*_boot_test_*_xxxx_xTestApp_release.appimage: A simple testcase for booting
core xxxx_x (eg. MCU1_0, MPU2_0 etc.)</li>
<li>sbl_*_smp_test_*_all_coresTestApp_release.appimage: A single SMP boot test case
that boots MCUs in lock step. The MCU app then uses the SBL lib to boot all the
MPUs in SMP mode, ie, all the MPUs execute a single binary from the same address.</li>
<li>sbl_baremetal_boot_perf_*_mcu1_0TestApp_release.appimage: A single MCU1_0 test
case that can be used to measure the effect of enabling/disabling the perf.
tuning knobs in the SBL for OSPI boot. The size of the test case can be easily
modified by changing the value of SIZE_OF_PAD in <a class="reference external" href="http://git.ti.com/keystone-rtos/sbl/blobs/master/example/k3MulticoreApp/sbl_mcu_0_boot_perf_benchmark.c#line90">sbl/example/k3MulticoreApp/
sbl_mcu_0_boot_perf_benchmark.c</a>
to profile for different app image sizes.</li>
</ul>
<p>The test log for sbl_*_boot_test_*_all_coresTestApp_release is</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">SYSFW</span>  <span class="n">ver</span> <span class="mf">18.7.1</span><span class="o">-</span><span class="n">v2018</span><span class="mf">.07</span><span class="n">a</span> <span class="p">(</span><span class="n">Curious</span> <span class="n">Crow</span><span class="p">)</span> <span class="n">running</span>
<span class="n">SBL</span> <span class="n">Revision</span><span class="o">:</span> <span class="mf">01.00.09.01</span> <span class="p">(</span><span class="n">Aug</span> <span class="mi">29</span> <span class="mi">2018</span> <span class="o">-</span> <span class="mi">18</span><span class="o">:</span><span class="mi">29</span><span class="o">:</span><span class="mi">57</span><span class="p">)</span>
<span class="n">MPU1_0</span> <span class="n">running</span>
<span class="n">MPU1_1</span> <span class="n">running</span>
<span class="n">MPU2_0</span> <span class="n">running</span>
<span class="n">MPU2_1</span> <span class="n">running</span>
<span class="n">MCU1_1</span> <span class="n">running</span>
<span class="n">MCU1_0</span> <span class="n">running</span>
<span class="n">MCU1_0</span> <span class="n">reports</span><span class="o">:</span> <span class="n">All</span> <span class="n">tests</span> <span class="n">have</span> <span class="n">passed</span>
</pre></div>
</div>
<p>The test log for sbl_*_smp_test_*_all_coresTestApp_release.appimage is</p>
<div class="highlight-cpp"><div class="highlight"><pre>SYSFW  ver 18.7.1-v2018.07a (Curious Crow) running
SBL Revision: 01.00.09.01 (Sep  7 2018 - 13:04:04)
Initlialzing DDR @333000000Hz..done
MPU AMP boot test
All MPUs will boot from 0x801007a0
Resetting all MPUs now...
No of MPU core(s) running: 1
No of MPU core(s) running: 2
No of MPU core(s) running: 3
No of MPU core(s) running: 4
All tests have passed
</pre></div>
</div>
<p>The test log for sbl_baremetal_boot_perf_*_mcu1_0TestApp_release.appimage, when the best boot time is reached is</p>
<div class="highlight-cpp"><div class="highlight"><pre>Time elapsed since start of SBL: 39692us
fxn:boot_perf_test_main cycles: 15877177
MCU CLK @ 400000000Hz, cycles/usec = 400
Boot time is now optimised....
All tests have passed
</pre></div>
</div>
</div>
<div class="section" id="id21">
<h4>4.6.3.3.8. Boot Modes<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h4>
<p>The SBL supports MMCSD and OSPI Boot modes. The different boot modes supported for
all the am65xx boards is tabulated below.</p>
<table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="15%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&nbsp;</td>
<td>MMCSD</td>
<td>OSPI</td>
<td>UART</td>
<td>PCIe</td>
<td>ETH</td>
</tr>
<tr class="row-even"><td>AM65xx EVM</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr class="row-odd"><td>AM65xx IDK</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
</tbody>
</table>
<p><strong>Booting Via SD Card</strong></p>
<ol class="arabic simple">
<li>Preparing the SD card.</li>
<li>Booting the testcase from SD card.</li>
</ol>
<p><strong>Preparing the SD card</strong></p>
<ol class="arabic simple">
<li>To boot the target the SD card should be bootable. Follow the steps
at <a class="reference external" href="http://processors.wiki.ti.com/index.php/Processor_SDK_RTOS_Creating_a_SD_Card_with_Windows">Creating bootable SD card in
windows</a>
or <a class="reference external" href="http://processors.wiki.ti.com/index.php/Processor_SDK_RTOS_create_SD_card_script">Creating bootable SD card in
Linux</a>.</li>
<li>To update the SBL with a newer version, copy the sbl image (sbl_mmcsd_img_mcu1_0_release.tiimage) to the SD card.
Rename it to <strong>tiboot3.bin</strong></li>
<li>To update the SYSFW with a newer version, copy the system firmware image (sysfw.bin) to the SD card.</li>
<li>Copy the generated application image(*.appimage) to the SD card. Rename it to
<strong>app</strong></li>
</ol>
<p><strong>Booting the testcase  from SD card</strong></p>
<ol class="arabic simple">
<li>Insert SD card into the SD card slot of the board.</li>
<li>Refer Boot Modes section in the <a class="reference external" href="http://www.ti.com/lit/pdf/spruim7">AM6x EVM Hardware Users Guide</a>  to setup EVM to boot from MMCSD.</li>
<li>Open a serial communication terminal like TeraTerm, MiniCom on host
PC and connect to the MCU UART console port</li>
<li>Power cycle the board to boot the appliation from the SD card.</li>
<li>The test logs will be displayed on the MCU UART</li>
</ol>
<p><strong>Booting Via OSPI flash</strong></p>
<ol class="arabic simple">
<li><a class="reference external" href="http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/index_board.html#uniflash">Programming the OSPI flash</a></li>
<li>Booting the testcase from OSPI flash</li>
</ol>
<p><strong>Booting the testcase from OSPI flash</strong></p>
<ol class="arabic simple">
<li>Refer Boot Modes section in the <a class="reference external" href="http://www.ti.com/lit/pdf/spruim7">AM6x EVM Hardware Users Guide</a>  to setup EVM to boot from OSPI.</li>
<li>Open a serial communication terminal like TeraTerm, MiniCom on host
PC and connect to the MCU UART console port</li>
<li>Power cycle  the board to boot the appliation from the OSPI flash.</li>
<li>The test logs will be displayed on the MCU UART</li>
</ol>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If sysfw.bin is not present in the boot media, the boot will fail without displaying any
logs on the MCU UART. SBL enables UART logging only after successfully starting the system
firmware image. If the system firmware load fails, the RBL will eventually reset the system.</p>
</div>
</div>
<div class="section" id="evm-setup-for-testing-sbl">
<h4>4.6.3.3.9. EVM Setup for testing SBL<a class="headerlink" href="#evm-setup-for-testing-sbl" title="Permalink to this headline">¶</a></h4>
<p>For information on board specific requirements like power supply, UART console port
connections refer the Hardware User guide of the respective boards.</p>
<p>The configurations needed to setup&nbsp;UART console&nbsp;through a serial terminal
application on host PC&nbsp;are listed in the next section.</p>
<p><strong>UART Console Setup</strong></p>
<p>PDK SBL prints messages on the UART Serial Console running on the host. Hence, a
serial terminal application (like Tera Term/HyperTerminal/minicom) should be
running on the host.</p>
<ul class="simple">
<li>The host serial port&nbsp;must be&nbsp;configured at 115200 baud, no parity, 1  stop bit
and no flow control.</li>
<li>Please ensure that the local echo setting for the terminal is turned  off.</li>
<li>All SBL prints are routed to the <a class="reference external" href="http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/index_how_to_guides.html#uart-connection">MCU UART</a></li>
<li>To verify setup is correct, setup the EVM to boot from UART  as the Primary Boot
Device(refer <a class="reference external" href="http://www.ti.com/lit/pdf/spruim7">AM6x EVM Hardware Users Guide</a>.
Power cycle the EVM, and look for the string CCCCCCC on the UART.</li>
</ul>
</div>
</div>
<div class="section" id="c66x">
<h3>4.6.3.4. C66x<a class="headerlink" href="#c66x" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id22">
<h4>4.6.3.4.1. Overview<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h4>
<p>C66x SOCs use the Intermediate Boot-Loader (IBL) to initialize and setup
the SOC for specific boot modes. The table below illustrates the
supported bootmodes:</p>
<table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="20%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Boot Mode</th>
<th class="head">TMDSEVM6678</th>
<th class="head">TMDXEVM6657</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>NOR boot via IBL over I2C<sup>1</sup></td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr class="row-odd"><td>NAND boot via IBL over I2C<sup>1</sup></td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr class="row-even"><td>TFTP boot via IBL over I2C<sup>1</sup></td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr class="row-odd"><td>I2C POST boot<sup>2</sup></td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr class="row-even"><td>Ethernet boot</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr class="row-odd"><td>SRIO boot</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr class="row-even"><td>PCIe boot</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ol class="last arabic simple">
<li>Support boot over I2C bus address 0x51</li>
<li>Support POST boot over I2C bus address&nbsp;0x50</li>
<li>Only&nbsp;ELF and BBLOB images are supported for booting</li>
<li>IBL is using the first 128KB L2 local memory, any application booting
from IBL should NOT use the first 128KB L2 memory, OR should only use
the first 128KB L2 memory for uninitialized data section</li>
</ol>
</div>
<p>Please refer to the boot mode dip switch settings for different boot
modes on
<a class="reference external" href="http://processors.wiki.ti.com/index.php/TMDXEVM6678L_EVM_Hardware_Setup#Boot_Mode_Dip_Switch_Settings">TMDSEVM6678L_EVM</a>,
and
<a class="reference external" href="http://processors.wiki.ti.com/index.php/TMDSEVM6657L_EVM_Hardware_Setup#Boot_Mode_Dip_Switch_Settings">TMDSEVM6657L_EVM</a>
that IBL supports.</p>
</div>
<div class="section" id="flashing-the-bootloader">
<h4>4.6.3.4.2. Flashing the Bootloader<a class="headerlink" href="#flashing-the-bootloader" title="Permalink to this headline">¶</a></h4>
<p>IBL needs to be flashed into EEPROM address 0x51.</p>
<p>Refer to <a class="reference external" href="http://processors.wiki.ti.com/index.php/Program_EVM_UG">Processor SDK RTOS Flashing Bootable
Images</a>] for
instructions on using the script, program_evm.js, to automatically flash
your device.</p>
</div>
<div class="section" id="id23">
<h4>4.6.3.4.3. Bootloader Execution Sequence<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h4>
<p>IBL is flashed into I2C EEPROM bus address 0x51. IBL provides a
workaround for the PLL lockup issue (please refer to C6678 errata
document, February 2011, advisory 8 for details on the PLL lockup
issue). For ROM boot modes (EMAC,SRIO,PCIe,Hyperlink etc) and I2C boot
mode with bus address 0x50, DSP will initially boot from I2C EEPROM bus
address 0x51 which does the PLL reset workaround, updates the DEVSTAT
for appropriate values based on the DIP switch settings (SW3 through SW6
settings) and then re enters the ROM to accomplish the desired boot
mode. Please note that the re entry is done for all boot modes except
for PCIe boot mode and I2C boot mode with bus address 0x51.</p>
<p>Below are the steps done in the IBL:</p>
<ol class="arabic simple">
<li>FPGA samples the bootmode pins</li>
<li>FPGA forces the DSP to boot via I2C bus address 0x51</li>
<li>PLL is initialized correctly by the IBL on the I2C.</li>
<li>IBL reads the sampled bootmode from an FPGA register.</li>
<li>IBL checks the bootmode, if it is not I2C boot or it is I2C boot but
with bus address 0x50, IBL writes bootmode into the DEVSTAT register</li>
<li>IBL then checks if the bootmode is PCIE boot or not. If it is, it
executes some PCIE workaround to configure the PCIE registers (mainly
to accept spread spectrum clock) and stays inside IBL waiting for
PCIe boot.</li>
<li>If it is not PCIE boot mode, IBL writes the Boot ROM entry address
into the DSP Program Counter, DSP executes the desired internal ROM
boot mode or boot from I2C bus address 0x50 as normal.</li>
</ol>
</div>
<div class="section" id="compilation">
<h4>4.6.3.4.4. Compilation<a class="headerlink" href="#compilation" title="Permalink to this headline">¶</a></h4>
<p>The recommended rule-of-thumb to compiling projects in the Processor SDK
RTOS package is to use the makefiles provided. The makefiles are usable
after setting up your shell/terminal/command prompt environment with the
setupenv.bat or setupenv.sh script located in</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">processor_sdk_rtos_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Refer to <a class="reference external" href="index_overview.html#building-the-sdk">Processor SDK RTOS Building the SDK</a>
guide on how to setup your environment for building within any of the
Processor SDK RTOS packages.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">C66x projects are supported by C6000 Code Generation
Tools 7.4.x. Make sure your environment variable, C6X_GEN_INSTALL_PATH,
is pointing to a valid C6000 compiler. Compiling IBL invokes the C6000
compiler, cl6x, directly. Your PATH variable will need to have
$C6X_GEN_INSTALL_PATH/bin.</p>
</div>
<p>The IBL package can be found in:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">ibl</span>
</pre></div>
</div>
<p>To build:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">ibl</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">make</span>
<span class="n">make</span> <span class="o">&lt;</span><span class="n">IBL_BINARY_NAME</span><span class="o">&gt;</span> <span class="n">ENDIAN</span><span class="o">=&lt;</span><span class="n">BINARY_ENDIANNESS</span><span class="o">&gt;</span> <span class="n">I2C_BUS_ADDR</span><span class="o">=</span><span class="mh">0x51</span>
</pre></div>
</div>
<p><em>&lt;IBL_BINARY_NAME&gt;</em> can be of values: <strong>evm_c6657_i2c</strong> or
<strong>evm_c6678_i2c</strong>. (For C6657 or C6678 platforms, respectively)</p>
<p><em>&lt;BINARY_ENDIANNESS&gt;</em> can be of values: <strong>little</strong> or <strong>big</strong></p>
<p><em>I2C_BUS_ADDR</em> specifies the I2C bus address to use, and has to be 0x51
for C66x SOCs to access the EEPROM.</p>
<p>The resulting output will be in [SDK Install
Path]/pdk_&lt;platform&gt;_&lt;version&gt;/packages/ti/boot/ibl/src/make/bin
directory.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For developers, who want to build IBL in Windows environment. Please
build this using MinGW environment using the instructions provided in
the build_instructions.txt that can be found under
pdk_c66xx_xx_xxpackagestibootibldocibldoc</p>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="flash-writers">
<h4>4.6.3.4.5. Flash Writers<a class="headerlink" href="#flash-writers" title="Permalink to this headline">¶</a></h4>
<p>There are three types of flash memory provided with the C66x SOCs:
EEPROM, NOR, and NAND. Each of these flash memory can hold bootable
application binaries. As such, respective flash writers are provided in:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">writer</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Please set your EVM to <strong>NO BOOT</strong> mode before loading
and running any of the flash writers. Flashing in NO BOOT mode is the
safest way since it eliminates any unwarranted interactions with booted
applications.</p>
</div>
<div class="section" id="eeprom-writer">
<h5>4.6.3.4.5.1. EEPROM Writer<a class="headerlink" href="#eeprom-writer" title="Permalink to this headline">¶</a></h5>
<p>The EEPROM Writer is used to write a binary into the EEPROM memory.</p>
<div class="section" id="id24">
<h6>4.6.3.4.5.1.1. Compilation<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h6>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">writer</span><span class="o">/</span><span class="n">eeprom</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">build</span>
<span class="n">make</span> <span class="n">all</span>
</pre></div>
</div>
</div>
<div class="section" id="usage">
<h6>4.6.3.4.5.1.2. Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li>Set your EVM to <strong>NO BOOT</strong>. Power on, launch target configuration in
CCS, and connect to Core 0. Be sure the GEL file is used and DDR is
initialized.</li>
<li>Copy the desired binary you want to flash to [SDK Install
Path]/pdk_&lt;platform&gt;_&lt;version&gt;/packages/ti/boot/writer/eeprom/&lt;platform&gt;/bin
directory.</li>
<li>Rename the binary you copied in the previous step to &#8220;app.bin&#8221;.</li>
<li>In CCS, select Core 0 and open the Memory Browser</li>
<li>In the Memory Browser window, right click and select &#8220;Load Memory&#8221;</li>
<li>Load your app.bin to 0x0C000000. Do so by selecting app.bin for the
file, click Next, and input 0x0C000000 for Start Address (Type-size
selected should be 32-bit)</li>
<li>Load [SDK Install
Path]/pdk_&lt;platform&gt;_&lt;version&gt;/packages/ti/boot/writer/eeprom/&lt;SOC&gt;/bin/eepromwriter_&lt;platform&gt;.out</li>
<li>Run Core 0. This will program the flash memory.</li>
</ol>
<p>If it succeeds, the console will print &#8220;EEPROM programming completed
successfully&#8221;</p>
</div>
</div>
<div class="section" id="nor-writer">
<h5>4.6.3.4.5.2. NOR Writer<a class="headerlink" href="#nor-writer" title="Permalink to this headline">¶</a></h5>
<p>The NOR Writer is used to write a binary into the NOR memory.</p>
<div class="section" id="id25">
<h6>4.6.3.4.5.2.1. Compilation<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h6>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">writer</span><span class="o">/</span><span class="n">nor</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">build</span>
<span class="n">make</span> <span class="n">all</span>
</pre></div>
</div>
</div>
<div class="section" id="id26">
<h6>4.6.3.4.5.2.2. Usage<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li>Set your EVM to <strong>NO BOOT</strong>. Power on, launch target configuration in
CCS, and connect to Core 0. Be sure the GEL file is used and DDR is
initialized.</li>
<li>Copy the desired binary you want to flash to [SDK Install
Path]/pdk_&lt;platform&gt;_&lt;version&gt;/packages/ti/boot/writer/nor/&lt;platform&gt;/bin
directory.</li>
<li>Rename the binary you copied in the previous step to &#8220;app.bin&#8221;.</li>
<li>In CCS, select Core 0 and open the Memory Browser</li>
<li>In the Memory Browser window, right click and select &#8220;Load Memory&#8221;</li>
<li>Load your app.bin to 0x80000000. Do so by selecting app.bin for the
file, click Next, and input 0x80000000 for Start Address (Type-size
selected should be 32-bit)</li>
<li>Load [SDK Install
Path]/pdk_&lt;platform&gt;_&lt;version&gt;/packages/ti/boot/writer/nor/&lt;SOC&gt;/bin/norwriter_&lt;platform&gt;.out</li>
<li>Run Core 0. This will program the flash memory.</li>
</ol>
<p>If it succeeds, the console will print &#8220;NOR programming completed
successfully&#8221;</p>
</div>
</div>
<div class="section" id="nand-writer">
<h5>4.6.3.4.5.3. NAND Writer<a class="headerlink" href="#nand-writer" title="Permalink to this headline">¶</a></h5>
<p>The NAND Writer is used to write a binary into the NAND memory.</p>
<div class="section" id="id27">
<h6>4.6.3.4.5.3.1. Compilation<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h6>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">writer</span><span class="o">/</span><span class="n">nand</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">build</span>
<span class="n">make</span> <span class="n">all</span>
</pre></div>
</div>
</div>
<div class="section" id="id28">
<h6>4.6.3.4.5.3.2. Usage<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li>Set your EVM to <strong>NO BOOT</strong>. Power on, launch target configuration in
CCS, and connect to Core 0. Be sure the GEL file is used and DDR is
initialized.</li>
<li>Copy the desired binary you want to flash to [SDK Install
Path]/pdk_&lt;platform&gt;_&lt;version&gt;/packages/ti/boot/writer/nand/&lt;platform&gt;/bin
directory.</li>
<li>Rename the binary you copied in the previous step to &#8220;app.bin&#8221;.</li>
<li>In CCS, select Core 0 and open the Memory Browser</li>
<li>In the Memory Browser window, right click and select &#8220;Load Memory&#8221;</li>
<li>Load your app.bin to 0x80000000. Do so by selecting app.bin for the
file, click Next, and input 0x80000000 for Start Address (Type-size
selected should be 32-bit)</li>
<li>Load [SDK Install
Path]/pdk_&lt;platform&gt;_&lt;version&gt;/packages/ti/boot/writer/nand/&lt;SOC&gt;/bin/nandwriter_&lt;platform&gt;.out</li>
<li>Run Core 0. This will program the flash memory.</li>
</ol>
<p>If it succeeds, the console will print &#8220;NAND programming completed
successfully&#8221;</p>
</div>
</div>
</div>
<div class="section" id="id29">
<h4>4.6.3.4.6. Boot Modes<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h4>
<div class="section" id="nand-boot">
<h5>4.6.3.4.6.1. NAND Boot<a class="headerlink" href="#nand-boot" title="Permalink to this headline">¶</a></h5>
<img alt="../_images/Nandboot.jpg" src="../_images/Nandboot.jpg" />
<p>NAND boot is a multi-stage process which is designed to boot an
application from NAND flash after reset. Figure below illustrates the
elements of the NAND boot process.</p>
<p>On reset the DSP starts execution with the bootrom which transfers
execution to the secondary bootloader from EEPROM using the I2C slave
bus address&nbsp;0x51. The secondary bootloader loads the application program
from NAND flash then transfers control to the application. To execute
the NAND bootloader you must ensure the DIP switches for your platform
are properly configured for I2C Master Boot and address&nbsp;0x51, AND
the&nbsp;boot parameter&nbsp;index dip switch should be set to 2 or 3.</p>
<p>NAND boot supports multiple images booting. Depending on the boot
parameter index dip switch, maximum&nbsp;2 boot images can be supported. By
default NAND boot only supports a BBLOB image format, if the customer
wants to boot an ELF image,&nbsp; the IBL configuration table needs to be
modified and re-programmed to EEPROM.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="nor-boot">
<h5>4.6.3.4.6.2. NOR Boot<a class="headerlink" href="#nor-boot" title="Permalink to this headline">¶</a></h5>
<img alt="../_images/Norboot.jpg" src="../_images/Norboot.jpg" />
<p>NOR boot is a multi-stage process which is designed to boot an
application from NOR flash after reset. Figure below illustrates the
elements of the NOR boot process.</p>
<p>On reset the DSP starts execution with the bootrom which transfers
execution to the secondary bootloader from EEPROM using the I2C slave
address 0x51. The secondary bootloader loads the application program
from NOR flash then transfers control to the application. To execute the
NOR bootloader you must ensure the DIP switches for your platform are
properly configured for I2C Master Boot and address&nbsp;0x51, AND the boot
parameter index switch should be set to 0 or 1.</p>
<p>NOR boot supports multiple images booting. Depending on the boot
parameter index dip switch, maximum&nbsp;2 boot images can be supported.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="tftp-boot">
<h5>4.6.3.4.6.3. TFTP Boot<a class="headerlink" href="#tftp-boot" title="Permalink to this headline">¶</a></h5>
<img alt="../_images/Emacboot.jpg" src="../_images/Emacboot.jpg" />
<p>EMAC boot is a multi-stage process which is designed to boot an
application from TFTP server after reset. Figure below illustrates the
elements of the EMAC boot process.</p>
<p>On reset the DSP starts execution with the bootrom which transfers
execution to the secondary bootloader from EEPROM using the I2C slave
address&nbsp;0x51. The secondary bootloader loads the application program
from a remote TFTP server then transfers control to the application. To
execute the EMAC bootloader you must ensure the DIP switches for your
platform are properly configured for I2C Master Boot and address&nbsp;0x51,
AND&nbsp;the boot parameter index switch should be set to&nbsp;4. By default EMAC
boot only supports a BBLOB image format, if the customer wants to boot
an ELF image, the IBL configuration table needs to be modified and
re-programmed to EEPROM.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="section" id="updating-the-ibl-ethernet-configurations">
<h6>4.6.3.4.6.3.1. Updating the IBL Ethernet Configurations<a class="headerlink" href="#updating-the-ibl-ethernet-configurations" title="Permalink to this headline">¶</a></h6>
<p>There are two ways to update the IBL ethernet configurations for
ethernet boot.</p>
<p><strong>Using CCS</strong></p>
<ol class="arabic simple">
<li>Turn on and connect to your EVM with the appropriate Target
Configuration file.</li>
<li>Connect to Core 0.</li>
<li>Go to Run -&gt; Load Program and select i2cparam_0x51_c667#_le_0x500.out
located in [SDK Install
Path]/pdk_&lt;platform&gt;_&lt;version&gt;/packages/ti/boot/ibl/src/make/bin</li>
<li>Go to Tools -&gt; GEL Files and then right click on GEL Files window and
Load the i2cConfig.gel GEL file, located in [SDK Install
Path]/pdk_&lt;platform&gt;_&lt;version&gt;/packages/ti/boot/ibl/src/make/bin</li>
<li>Run the program. The following message will be printed on the CCS
console: <em>Run the GEL for the SOC to be configured, press return to
program the I2C.</em> <strong>DO NOT PRESS ENTER UNTIL STEP 6 IS DONE</strong></li>
<li>Run the GEL script&#8221;Scripts -&gt; EVM c6678 IBL&#8221; -&gt; setConfig_c6678_main.</li>
<li>Now press &#8220;Enter&#8221; in the CCS console window, and the program will
write the boot parameter table to the EEPROM. On success the message
&#8220;I2c table write complete&#8221; will be printed on the CCS console.</li>
</ol>
<p>Please note that the i2cConfig.gel file can be modified via a text
editor before loading and running the script in CCS. Please note that
this gel file contains configuration settings for multiple SOCs and
multiple boot modes.</p>
<p><strong>Using iblConfig Utility Program</strong></p>
<p>The second way to update the IBL ethernet configurations is to use
<strong>iblConfig.out</strong>. This utility program is located under:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">ibl</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">util</span><span class="o">/</span><span class="n">iblConfig</span><span class="o">/</span><span class="n">build</span>
</pre></div>
</div>
<p>In command line, use &#8220;make&#8221; with the given Makefile to generate
iblConfig.out and input.txt. Please be sure to fill in the parameters
for input.txt before running iblConfig.out; below is an example of
input.txt:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">file_name</span> <span class="o">=</span> <span class="n">ibl</span><span class="p">.</span><span class="n">bin</span>
<span class="n">SOC</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">offset</span> <span class="o">=</span> <span class="mh">0x500</span>
<span class="n">ethBoot</span><span class="o">-</span><span class="n">doBootp</span> <span class="o">=</span> <span class="n">TRUE</span>
<span class="n">ethBoot</span><span class="o">-</span><span class="n">bootFormat</span> <span class="o">=</span> <span class="n">ibl_BOOT_FORMAT_ELF</span>
<span class="n">ethBoot</span><span class="o">-</span><span class="n">ipAddr</span> <span class="o">=</span> <span class="mf">192.168.1.3</span>
<span class="n">ethBoot</span><span class="o">-</span><span class="n">serverIp</span> <span class="o">=</span> <span class="mf">192.168.1.2</span>
<span class="n">ethBoot</span><span class="o">-</span><span class="n">gatewayIp</span> <span class="o">=</span> <span class="mf">192.168.1.1</span>
<span class="n">ethBoot</span><span class="o">-</span><span class="n">netmask</span> <span class="o">=</span> <span class="mf">255.255.255.0</span>
<span class="n">ethBoot</span><span class="o">-</span><span class="n">fileName</span> <span class="o">=</span>
</pre></div>
</div>
<p>The first 3 parameters must be filled in for iblConfig.out to work:</p>
<ul class="simple">
<li>file_name refers to the IBL binary file to update. This file must be
in the same directory as iblConfig.out.</li>
<li>SOC refers to the SOC being used. Please enter <strong>6 for C6678, and 8
for C6657</strong>.</li>
<li>offset refers to an offset space in the IBL. The value is 0x500 for
C6678, and C6657</li>
</ul>
<p>The ethernet parameters (the entries beginning with ethBoot) refer to
specific ethernet configurations. If they are not specified, they will
be defaulted to the values in the [SDK Install
Path]/pdk_&lt;platform&gt;_&lt;version&gt;/packages/ti/boot/ibl/src/util/iblConfig/src/SOC.h
file. In the example above, the ethernet boot file name will be
defaulted to c6678-le.bin when iblConfig.out is run.</p>
<p>After running iblConfig.out and updating the IBL binary, you must
flash the modified IBL binary to your EVM. You can do this as part of
program_evm (refer to <a class="reference external" href="http://processors.wiki.ti.com/index.php/Program_EVM_UG">Processor SDK Flashing Bootable
Images</a>) or
you can flash it individually using eepromwriter (refer to &#8220;Flash
Writers&#8221; section above).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you updated the IBL with iblConfig and flashed it
with eepromwriter, you should <strong>NOT</strong> use
i2cparam_0x51_c667#_le_0x500.out and iblConfig.gel - this would
overwrite the changes you made to the IBL.</p>
</div>
</div>
<div class="section" id="id30">
<h6>4.6.3.4.6.3.2. Compilation<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h6>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">i2c</span><span class="o">/</span><span class="n">tftp</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">build</span>
<span class="n">make</span> <span class="n">all</span>
</pre></div>
</div>
</div>
<div class="section" id="id31">
<h6>4.6.3.4.6.3.3. Usage<a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h6>
<p>After your IBL ethernet settings are configured correctly and flashed
into EEPROM memory, follow these steps to continue the TFTP booting
process:</p>
<ol class="arabic simple">
<li>Start a TFTP server on your local PC. Your local PC will be the one
sending the image to be booted, so make sure your PC and EVM are
connected to the same subnet via ethernet</li>
<li>Copy i2ctftpboot_&lt;platform&gt;.out (refer to compilation step above) to
your base TFTP directory</li>
<li>Rename i2ctftpboot_&lt;platform&gt;.out to app.out</li>
<li>Set the IP address of the PC that is running the TFTP server to
192.168.2.101, since by default IBL will set the EVM IP address to
192.168.2.100 and the TFTP server IP address to 192.168.2.101</li>
<li>Set EVM to TFTP boot mode and power on the EVM</li>
</ol>
<p>Your PC will send the application image to the EVM to boot. Open an UART
terminal to view the output.</p>
</div>
</div>
<div class="section" id="post-boot">
<h5>4.6.3.4.6.4. POST Boot<a class="headerlink" href="#post-boot" title="Permalink to this headline">¶</a></h5>
<p>POST (Power On Self Test) Boot is designed to do a quick self-diagnostic
upon boot. The POST application itself is located in</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">post</span>
</pre></div>
</div>
<p>This application should already be compiled and flashed into EEPROM
out-of-box. Below instructions are for re-compilation or re-flashing
only.</p>
<div class="section" id="id32">
<h6>4.6.3.4.6.4.1. Compilation<a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h6>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">post</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">build</span>
<span class="n">make</span> <span class="n">all</span>
<span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">post</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">bin</span>
<span class="p">.</span><span class="o">/</span><span class="n">post_romparse</span><span class="p">.</span><span class="n">sh</span>
</pre></div>
</div>
<p>Note: You would need to use post_romparse.bat instead of the *.sh
version if your host system is running on Windows.</p>
</div>
<div class="section" id="id33">
<h6>4.6.3.4.6.4.2. Usage<a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h6>
<p>To flash the POST binary into EEPROM:</p>
<ol class="arabic simple">
<li>Refer to above Flash Writers section on flashing EEPROM memory. The
binary you are flashing is &#8220;post_i2crom.bin&#8221;.</li>
<li>Before running the last step of the EEPROM flashing instruction to
run the DSP core, modify the <strong>eepromwriter_input.txt</strong> to use
<strong>0x50</strong> for the bus_addr field. The <strong>eepromwriter_input.txt</strong> file
is located in:</li>
</ol>
<div class="highlight-cpp"><div class="highlight"><pre><span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">writers</span><span class="o">/</span><span class="n">eeprom</span><span class="o">/&lt;</span><span class="n">SOC</span><span class="o">&gt;/</span><span class="n">bin</span>
</pre></div>
</div>
<p>Configure your EVM&#8217;s DIP Switches accordingly to I2C POST BOOT mode. The
POST application will be loaded from EEPROM 0x50 and output will be
available over the UART serial console.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="ethernet-boot">
<h5>4.6.3.4.6.5. ETHERNET Boot<a class="headerlink" href="#ethernet-boot" title="Permalink to this headline">¶</a></h5>
<p>ETHERNET Boot uses Ethernet sockets to transfer a bootable image from a
host to the EVM. After powering on in Ethernet boot mode, the EVM will
send BOOTP packets at regular interval - this gives visibility of the
MAC ID of the EVM to the network.</p>
<p>Below are instructions on compiling and running an example to send a
simple program to the EVM while in Ethernet boot mode.</p>
<div class="section" id="id34">
<h6>4.6.3.4.6.5.1. Compilation<a class="headerlink" href="#id34" title="Permalink to this headline">¶</a></h6>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">ethernet</span><span class="o">/</span><span class="n">Utilities</span>
<span class="n">make</span> <span class="n">all</span>
<span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">ethernet</span><span class="o">/</span><span class="n">simple</span>
<span class="n">make</span> <span class="n">all</span>
</pre></div>
</div>
</div>
<div class="section" id="id35">
<h6>4.6.3.4.6.5.2. Usage<a class="headerlink" href="#id35" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li>Set the EVM&#8217;s DIP switches to Ethernet boot mode. Connect Ethernet
cables such that the EVM and your Host PC are on the same network.</li>
<li>Power on the EVM. The EVM will start sending BOOTP packets. Read the
packets for the EVM&#8217;s MAC ID. You can read the packet by using a
network tool such as Wireshark.</li>
<li>On your Host PC, add an ARP entry to associate the EVM&#8217;s MAC ID with
an IP address on your network.</li>
<li>Use the pcsendpkt utility provided to send the simple.eth program
compiled in the compilation step to the EVM.</li>
</ol>
<p>To use pcsendpkt:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">ethernet</span><span class="o">/</span><span class="n">Utilities</span>
<span class="n">pcsendpkt</span> <span class="n">simple</span><span class="p">.</span><span class="n">eth</span> <span class="o">&lt;</span><span class="n">EVM</span> <span class="n">IP</span> <span class="n">ADDRESS</span><span class="o">&gt;</span>
</pre></div>
</div>
<p><em>&lt;EVM IP ADDRESS&gt;</em> is the IP address you assigned the EVM in step 3</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<blockquote>
<div>If you are on a Linux Host PC, you may need to recompile pcsendpkt locally with GCC</div></blockquote>
<p class="last">To verify, connect to the EVM&#8217;s Core 0 via CCS and check that the A1
register is set to 0x11223344</p>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="srio-boot">
<h5>4.6.3.4.6.6. SRIO Boot<a class="headerlink" href="#srio-boot" title="Permalink to this headline">¶</a></h5>
<p>SRIO boot will attempt to load and run a binary image received via SRIO.
An example can be found in:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">srio</span>
</pre></div>
</div>
<p>Below are instructions on compiling and running the SRIO boot example.</p>
<div class="section" id="id36">
<h6>4.6.3.4.6.6.1. Compilation<a class="headerlink" href="#id36" title="Permalink to this headline">¶</a></h6>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">srio</span><span class="o">/</span><span class="n">srioboot_ddrinit</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">build</span>
<span class="n">make</span> <span class="n">all</span>
<span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">srio</span><span class="o">/</span><span class="n">srioboot_ddrinit</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">bin</span>
<span class="p">.</span><span class="o">/</span><span class="n">srioboot_ddrinit_elf2HBin</span><span class="p">.</span><span class="n">sh</span>
<span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">srio</span><span class="o">/</span><span class="n">srioboot_helloworld</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">build</span>
<span class="n">make</span> <span class="n">all</span>
<span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">srio</span><span class="o">/</span><span class="n">srioboot_helloworld</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">bin</span>
<span class="p">.</span><span class="o">/</span><span class="n">helloworld_elf2HBin</span><span class="p">.</span><span class="n">sh</span>
<span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">srio</span><span class="o">/</span><span class="n">srioboot_example</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">build</span>
<span class="n">make</span> <span class="n">all</span>
</pre></div>
</div>
<p>Note: You would need to use srioboot_ddrinit_elf2HBin.bat and
helloworld_elf2HBin.bat instead of their *.sh version respectively if
your host system is running on Windows. Compilation of the projects
should be done in the order stated above.</p>
</div>
<div class="section" id="id37">
<h6>4.6.3.4.6.6.2. Usage<a class="headerlink" href="#id37" title="Permalink to this headline">¶</a></h6>
<p>You will need to have 2 EVMs - both should be set to SRIO boot mode. The
two EVMs will be connected through the AMC breakout board (lane x of one
slot should be connected to lane x of the other breakout slot). One EVM
will be acting as the host (referred to as the HOST EVM) and the other
EVM will be doing the booting (referred to as the BOOTING EVM).</p>
<ol class="arabic simple">
<li>Compile srioboot_example_evm66XXl.out</li>
<li>Connect the BOOTING EVM&#8217;s UART serial port to your PC using the
RS-232 cable</li>
<li>Connect a JTAG emulator on the HOST EVM</li>
<li>Power on both EVMs</li>
<li>Open an UART terminal to view the BOOTING EVM&#8217;s output. (Remember to
set the baud rate to 115.2k bps, 8-bit data, no parity, 1-bit stop,
and no flow control)</li>
<li>Connect to the HOST EVM via Code Composer Studio (CCS is recommended
to be version 6 or higher). Launch target configuration for your HOST
EVM and connect to DSP0.</li>
<li>Load and run srioboot_example_evm66xxl.out on your HOST EVM</li>
</ol>
<p>CCS console for your HOST EVM should display:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span> <span class="n">SRIO</span> <span class="n">Boot</span> <span class="n">Host</span> <span class="n">Example</span> <span class="n">Version</span> <span class="mf">01.00.00.01</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span> <span class="n">Transfer</span> <span class="n">DDR</span> <span class="n">init</span> <span class="n">code</span> <span class="n">via</span> <span class="n">SRIO</span> <span class="n">successfully</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span> <span class="n">Transfer</span> <span class="n">boot</span> <span class="n">code</span> <span class="n">via</span> <span class="n">SRIO</span> <span class="n">successfully</span>
</pre></div>
</div>
<p>Terminal for your BOOTING EVM should display:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">SRIO</span> <span class="n">Boot</span> <span class="n">Hello</span> <span class="n">World</span> <span class="n">Example</span> <span class="n">Version</span> <span class="mf">01.00.00.01</span>
<span class="n">Booting</span> <span class="n">Hello</span> <span class="n">World</span> <span class="n">image</span> <span class="n">on</span> <span class="n">Core</span> <span class="mi">0</span> <span class="n">from</span> <span class="n">SRIO</span> <span class="p">...</span>
<span class="n">Booting</span> <span class="n">Hello</span> <span class="n">World</span> <span class="n">image</span> <span class="n">on</span> <span class="n">Core</span> <span class="mi">1</span> <span class="n">from</span> <span class="n">Core</span> <span class="mi">0</span> <span class="p">...</span>
<span class="n">Booting</span> <span class="n">Hello</span> <span class="n">World</span> <span class="n">image</span> <span class="n">on</span> <span class="n">Core</span> <span class="mi">2</span> <span class="n">from</span> <span class="n">Core</span> <span class="mi">0</span> <span class="p">...</span>
<span class="n">Booting</span> <span class="n">Hello</span> <span class="n">World</span> <span class="n">image</span> <span class="n">on</span> <span class="n">Core</span> <span class="mi">3</span> <span class="n">from</span> <span class="n">Core</span> <span class="mi">0</span> <span class="p">...</span>
<span class="n">Booting</span> <span class="n">Hello</span> <span class="n">World</span> <span class="n">image</span> <span class="n">on</span> <span class="n">Core</span> <span class="mi">4</span> <span class="n">from</span> <span class="n">Core</span> <span class="mi">0</span> <span class="p">...</span>
<span class="n">Booting</span> <span class="n">Hello</span> <span class="n">World</span> <span class="n">image</span> <span class="n">on</span> <span class="n">Core</span> <span class="mi">5</span> <span class="n">from</span> <span class="n">Core</span> <span class="mi">0</span> <span class="p">...</span>
<span class="n">Booting</span> <span class="n">Hello</span> <span class="n">World</span> <span class="n">image</span> <span class="n">on</span> <span class="n">Core</span> <span class="mi">6</span> <span class="n">from</span> <span class="n">Core</span> <span class="mi">0</span> <span class="p">...</span>
<span class="n">Booting</span> <span class="n">Hello</span> <span class="n">World</span> <span class="n">image</span> <span class="n">on</span> <span class="n">Core</span> <span class="mi">7</span> <span class="n">from</span> <span class="n">Core</span> <span class="mi">0</span> <span class="p">...</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="pcie-boot">
<h5>4.6.3.4.6.7. PCIE Boot<a class="headerlink" href="#pcie-boot" title="Permalink to this headline">¶</a></h5>
<p>PCIE boot will attempt to load and run a binary image upon enumeration.
Example is located:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">pcie</span>
</pre></div>
</div>
<p>Below are instructions on compiling and running the PCIE boot example.</p>
<div class="section" id="id38">
<h6>4.6.3.4.6.7.1. Compilation<a class="headerlink" href="#id38" title="Permalink to this headline">¶</a></h6>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">pcie</span><span class="o">/</span><span class="n">pcieboot_ddrinit</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">build</span>
<span class="n">make</span> <span class="n">all</span>
<span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">pcie</span><span class="o">/</span><span class="n">pcieboot_helloworld</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">build</span>
<span class="n">make</span> <span class="n">all</span>
</pre></div>
</div>
<p>Additionally for C6678 EVM:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">pcie</span><span class="o">/</span><span class="n">pcieboot_interrupt</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">build</span>
<span class="n">make</span> <span class="n">all</span>
<span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">pcie</span><span class="o">/</span><span class="n">pcieboot_localreset</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">build</span>
<span class="n">make</span> <span class="n">all</span>
</pre></div>
</div>
<p>The POST application can also be used as a PCIE Boot example. Run the
corresponding *_elf2HBin.bat (or .sh) to convert the .out files into
PCIE bootable binaries.</p>
</div>
<div class="section" id="id39">
<h6>4.6.3.4.6.7.2. Usage<a class="headerlink" href="#id39" title="Permalink to this headline">¶</a></h6>
<p>An AMC to PCIE adaptor card, a TMS320C66xxL EVM card and a Linux PC are
required to do the test. The test is verified on both TMS320C6670L and
TMS320C6678L cards, with both 32-bit and 64-Linux PCs running Ubuntu
10.04. Other Linux OS are expected to work as well.</p>
<ul class="simple">
<li>Before connect the system, please update IBL with the latest from
Processor SDK</li>
<li>Set EVM card to PCIE boot (refer to hardware page)</li>
<li>Assemble the EVM card into the adaptor card</li>
<li>Connect the URAT cable from EVM card to a Linux PC’s USB port or
serial port</li>
<li>Completely shut off the PC power supply (by disconnecting the power
cord), insert the AMC adaptor card (with EVM mounted) into an open
PCIE slot in PC’s motherboard</li>
<li>Supply the power to PC, wait for a few seconds and power on the PC.</li>
<li>Make sure the PCIE device is correctly enumerated by PC by checking
below, note DEVICE_ID field is changed from 0x8888 to 0xb005 which is
programmed in IBL.</li>
<li>Either enter PC’s BIOS setting when PC is booting up, a new PCIE
device should be populated in the PCIE slot where card is inserted,
shown as a “Multimedia device”.</li>
<li>Or, type “lspci –n” under Linux command shell after Linux OS is
loaded, a TI device (VENDOR_ID: 0x104c) should be in the list:</li>
</ul>
<div class="highlight-cpp"><div class="highlight"><pre>local-ubuntu:~$ lspci -n
00:00.0 0600: 8086:2774
00:1b.0 0403: 8086:27d8 (rev 01)
….
00:1f.3 0c05: 8086:27da (rev 01)
01:00.0 0480: 104c:b005 (rev 01)
03:00.0 0200: 14e4:1677 (rev 01)
Similarly, one can type “lspci”,
local-ubuntu:~$ lspci
….
00:1f.3 SMBus: Intel Corporation N10/ICH 7 Family SMBus Controller (rev
01)
01:00.0 Multimedia controller: Texas Instruments Device b005 (rev 01)
....
</pre></div>
</div>
<ul class="simple">
<li>The PCIE BARn (n = 0, 1, 2, … , 5) registers are written by Linux PC
after enumeration, they should be non-zero. Optionally, if a JTAG
emulator is available, one can verify this by looking at address
starting from 0x21801010 for 6 32-bit word.</li>
<li>Prepare pciedemo.ko in the Linux PC</li>
<li>On the Linux PC open a new terminal window to run minicom. First run
“sudo minicom –s” to set the correct configuration: 115200bps, 8-N-1,
Hardware flow control: OFF, Software flow control: OFF, and select
the correct Serial Device. Save then run “sudo minicom” to monitor
the port.</li>
<li>Type “sudo insmod pciedemo.ko”</li>
<li>If a JTAG emulator is available, one can verify that the PC registers
for cores other than core 0 should be inside DDR; and magic address
for cores other than core 0 should be written with 0xBABEFACE.</li>
</ul>
</div>
<div class="section" id="procedure-to-build-and-run-linux-host-loader">
<h6>4.6.3.4.6.7.3. Procedure to build and run Linux host loader<a class="headerlink" href="#procedure-to-build-and-run-linux-host-loader" title="Permalink to this headline">¶</a></h6>
<ul class="simple">
<li>Create a folder (e.g. pcie_test) in a Linux machine. Copy pciedemo.c,
Makefile, pcieDdrInit_66xx.h, pcieBootCode_66xx.h,
pcieInterrupt_66xx.h and post_66xx.h from
toolsboot_loaderexamplespcielinux_host_loader to the folder.</li>
<li>Type “make”, a pciedemo.ko file should be created</li>
<li>By default, this will build the “HelloWorld” demo on little endian
6678, which is controlled by the following Marcos in pciedemo.c:</li>
</ul>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#define BIG_ENDIAN 0</span>
<span class="cp">#define HELLO_WORLD_DEMO 1</span>
<span class="cp">#define POST_DEMO 0</span>
<span class="cp">#define EDMA_INTC_DEMO 0</span>
<span class="cp">#define EVMC6678L 1</span>
<span class="cp">#define EVMC6670L 0</span>
</pre></div>
</div>
<p>One must select the endianness, demo program and target type by toggling
between 0 and 1 accordingly. Then, type “make clean” and type “make” to
rebuild the pciedemo.ko.</p>
<p>Note: “HelloWorld” and EDMA_INTC demos can be run on both endianness.
POST demo can be run on little endian only.</p>
<ul class="simple">
<li>To insert the module into kernel, type “sudo insmod pciedemo.ko”; to
view the kernel message, type “dmesg”; to remove the module from
kernel, type “sudo rmmod</li>
</ul>
<p>pciedemo.ko”</p>
</div>
<div class="section" id="the-role-of-ibl-in-pcie-boot-mode">
<h6>4.6.3.4.6.7.4. The role of IBL in PCIE boot mode<a class="headerlink" href="#the-role-of-ibl-in-pcie-boot-mode" title="Permalink to this headline">¶</a></h6>
<p>The Intermediate Boot Loader (IBL) is flashed into I2C EEPROM bus
address 0x51. IBL provides a workaround for the PLL lockup issue (please
refer to C6678 errata document, February 2011, advisory 8 for details on
the PLL lockup issue). For ROM boot modes (EMAC, SRIO, PCIE, Hyperlink,
etc) and I2C boot mode with bus address 0x50, DSP will initially boot
from I2C EEPROM bus address 0x51 which does the PLL reset workaround,
updates the DEVSTAT for appropriate values based on the DIP switch
settings (SW3 through SW6 settings) and then re-enters the ROM to
accomplish the desired boot mode. Please note that the re-entry is done
for all boot modes except for PCIE boot mode and I2C boot mode with bus
address 0x51.</p>
<p>Below are the steps done in the IBL in PCIE boot mode:</p>
<ul class="simple">
<li>FPGA samples the boot mode pins</li>
<li>FPGA forces the DSP to boot via I2C bus address 0x51</li>
<li>PLL is initialized correctly by the IBL on the I2C.</li>
<li>IBL reads the sampled boot mode from an FPGA register.</li>
<li>IBL checks the boot mode, if it is not I2C boot or it is I2C boot but
with bus address 0x50, IBL writes boot mode into the DEVSTAT register</li>
<li>IBL then checks if the boot mode is PCIE boot or not. If it is, it
executes some PCIE workaround to configure the PCIE registers (mainly
to accept spread spectrum clock) and stays inside IBL by first
clearing the magic address and then monitoring it for PCIE boot.</li>
</ul>
<p>For PCIE demos with DDR memory is used, proper DDR configuration is
required, this doesn’t need the full IBL functionality. Typically DDR
can be initialized in two ways:</p>
<ul class="simple">
<li>The Linux host initializes the DDR registers directly through PCIE
link.</li>
<li>A DDR initialization image is downloaded in the L2 first to
initialize the DDR and then reset the magic address with value 0. And
then the application image is downloaded in</li>
</ul>
<p>the DDR. In Processor SDK, the second approach is used.</p>
</div>
<div class="section" id="how-helloworld-boot-example-works">
<h6>4.6.3.4.6.7.5. How HelloWorld boot example works<a class="headerlink" href="#how-helloworld-boot-example-works" title="Permalink to this headline">¶</a></h6>
<p>The Linux host first pushes the DDR init boot image data to L2 memory of
core 0, then writes the boot entry address of the DDR init boot image to
the magic address on core 0, both via PCIE. When the EVM is in PCIE boot
mode, the IBL code running on the DSP core 0 polls the entry address and
jumps to that address and starts to boot (initialize the DDR). After DDR
is properly initialized, the DDR init code clears the magic address and
keeps on polling it.</p>
<p>Linux host then pushes the HelloWorld boot image data to DDR memory,
then writes the boot entry address of the HelloWorld boot image to the
magic address on core 0 to boot core 0. Core 0 starts to boot and print
the “Hello World” booting information, and then boot all the other cores
by writing the address of _c_int00 to the magic address on other cores
and sending an IPC interrupt to other cores. The RBL running on other
cores will jump to _c_int00 and start to boot, each core will write
0xBABEFACE to its magic address by running a function
write_boot_magic_number().</p>
<p>Note that host boot application needs to wait for some time after
pushing the DDR init boot image and before pushing the HelloWorld boot
image to the DDR, this will ensure DDR is properly initialized.</p>
</div>
<div class="section" id="how-post-boot-example-works">
<h6>4.6.3.4.6.7.6. How POST boot example works<a class="headerlink" href="#how-post-boot-example-works" title="Permalink to this headline">¶</a></h6>
<p>The POST example uses L2 only. The Linux host first pushes the POST boot
image data to L2 memory of core 0, then writes the boot entry address of
the POST to the magic address on core 0, both via PCIE. The IBL code
running on the DSP core 0 polls the entry address and jumps to that
address and starts to boot.</p>
</div>
<div class="section" id="how-dsp-local-reset-example-works">
<h6>4.6.3.4.6.7.7. How DSP local reset example works<a class="headerlink" href="#how-dsp-local-reset-example-works" title="Permalink to this headline">¶</a></h6>
<p>A user may want to re-run a PCIE demo without power cycle the Linux PC.
There is a need to reset the DSP chip from host software. There are
several types of resets: hard reset, soft reset and CPU local reset.
Hard reset will reset everything on the device except the PLLs, test,
emulation logic, and reset isolation modules. Since PCIE doesn’t support
reset isolation, a hard reset will reset PCIE module as well and all the
configured PCIE registers (PCIE MMRs) will be lost. Soft reset will
behave like a hard reset except that the stick bits of PCIE MMRs are
retained. The PC can’t communicate with PCIE card anymore in both hard
reset and soft reset cases.</p>
<p>To reset the DSP while keeping the PCIE untouched, the local reset
example does the following:</p>
<ul class="simple">
<li>Put all cores in reset via PSC</li>
<li>Disable all modules except PCIE and cores via PSC</li>
<li>Configure chip level registers DSP_BOOT_ADDRn and IPCGRn: Here the
header array converted from DSP local reset example is loaded into
each core via PCIE; the _c_int00 is then written to each
DSP_BOOT_ADDRn; finally IPCGRn is written to jump start the DSP local
reset example program, which simply polls magic address for a
secondary boot.</li>
<li>Enable all modules previous disabled via PSC</li>
<li>Pull all cores out of reset via PSC</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is IBL (in local L2) that monitors magic address
and boots the DDR init (in local L2) or POST (in local L2) or
EDMA-interrupt (in local L2) in those demos. If one wants to load
his/her own boot demo code, then it shouldn’t overlap with the IBL
code. As a guideline, the IBL uses memory from 0x00800000 to
0x0081BDFF. To check the exact memory usage, you can re-build the IBL
by following the instructions in
toolsboot_loaderibldocbuild_instructions.txt and check the
resulting ibl_c66x_init.map file. In addition, following local L2 is
reserved by RBL and shouldn’t be used: for 6678 ROM PG 1.0, 0x00872DC0
– 0x0087FFFF; for 6670 ROM PG 1.0, 0x008F2DC0 – 0x008FFFFF.</p>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="k2g">
<h3>4.6.3.5. K2G<a class="headerlink" href="#k2g" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id40">
<h4>4.6.3.5.1. Overview<a class="headerlink" href="#id40" title="Permalink to this headline">¶</a></h4>
<p>The Secondary Bootloader (SBL) for K2G does basic hardware
initialization for the board to load and run applications.</p>
</div>
<div class="section" id="id41">
<h4>4.6.3.5.2. Bootloader Execution Sequence<a class="headerlink" href="#id41" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Power On Reset occurs</li>
<li>ROM Bootloader (RBL) executes. It checks for bootmode and attempts to
load+run the SBL from that bootmode.</li>
<li>SBL begins execution from internal memory (MSMC RAM)<ul>
<li>Board Initialization is done by a call to <strong>Board_init()</strong> API.
For additional details refer to <a class="reference external" href="index_board.html#board-support">Processor SDK Board
Support</a>.</li>
<li>SBL setup includes configuring Pinmux, enable peripheral clocks,
set up PLLs, and configure EMIF for DDR.</li>
</ul>
</li>
<li>SBL finishes setup and looks for &#8220;app&#8221; to execute next. This
user-modifiable application may reside in SD card or QSPI memory
depending on the bootmode chosen.</li>
<li>Once located, app will be loaded into memory and execution will be
branched to the application&#8217;s entry address</li>
</ul>
</div>
<div class="section" id="id42">
<h4>4.6.3.5.3. Tools and Binary Formats<a class="headerlink" href="#id42" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="making-bootable-sbl-image-mlo">
<h4>4.6.3.5.4. Making Bootable SBL image (MLO)<a class="headerlink" href="#making-bootable-sbl-image-mlo" title="Permalink to this headline">¶</a></h4>
<p>RBL loads and runs &#8220;MLO&#8221;, which is a .out executable formatted by TI
tools. To make a .out, such as SBL, bootable by ROM, you must follow
these steps:</p>
<ol class="arabic simple">
<li><strong>armhex [.out file] [.rmd file]</strong><ul>
<li>.out file is the file you want to boot, such as sbl.out</li>
<li>.rmd file is an input file to specify sections information. An
example can be found in:
&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/board/evmK2G/build/sbl.rmd</li>
<li>armhex is a tool in TI ARM CGT compiler. This generates a [hex
file], name of which is specified by the .rmd file</li>
</ul>
</li>
<li><strong>b2ccs [hex file] [ccs file]</strong><ul>
<li>hex file is the output from the previous step</li>
<li>ccs file can be name of your choosing</li>
</ul>
</li>
<li><strong>ccsAddGphdr -infile [ccs file] -outfile [gphdr file] -headerEndian
BE</strong><ul>
<li>gphdr file can be the name of your choosing</li>
</ul>
</li>
<li><strong>ccsAddGptlr -infile [gphdr file] -outfile [gptlr file]</strong><ul>
<li>gptlr file can be the name of your choosing</li>
</ul>
</li>
<li><strong>byteswapccs [gptlr file] [MLO ccs file]</strong><ul>
<li>MLO ccs file can be the name of your choosing</li>
</ul>
</li>
<li><strong>ccs2bin -swap [MLO ccs file] MLO</strong><ul>
<li>MLO will be created after this step</li>
</ul>
</li>
</ol>
<p>Armhex is part of TI ARM CGT, in
<strong>&lt;CCS_INSTALL_DIR&gt;/tools/compiler/ti-cgt-arm_x.x.x/bin</strong>. The rest of
the tools can be found in:
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools</strong></p>
</div>
<div class="section" id="making-loadable-user-application-image-app">
<h4>4.6.3.5.5. Making Loadable User Application image (app)<a class="headerlink" href="#making-loadable-user-application-image-app" title="Permalink to this headline">¶</a></h4>
<p>For converting the compiled .out files to a format loadable by TI&#8217;s
Secondary Boot Loader (SBL), <strong>you must follow these two steps:</strong></p>
<ol class="arabic simple">
<li><strong>out2rprc.exe [.out file] [rprc output]</strong></li>
<li><strong>MulticoreImageGen.exe LE 55 [output name] 0 [rprc output]</strong></li>
</ol>
<p>Out2rprc.exe and MulticoreImageGen.exe are tools supplied by TI and can
be located in the <strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools</strong>
folder. &#8220;rprc output&#8221; can be any spare name of your choosing. &#8220;output
name&#8221; can also be any name of your choosing.</p>
<p>The &#8216;0&#8217; used in step 2 refers to the Core ID to boot. By default, &#8216;0&#8217; is
MPU (Cortex A15) core 0. You can input a different value to boot to
other cores. Valid values are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="37%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Core</th>
<th class="head">Value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>MPU Core 0</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>DSP Core 0</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>If MPU SMP is chosen, the same boot image and entry will be used for all
MPU cores. SBL can also parse multiple boot images that are concatenated
together. Simply use MulticoreImageGen as such:</p>
<p><strong>MulticoreImageGen.exe LE 55 [output name] [Core ID a] [rprc output a]
[Core ID b] [rprc output b] [Core ID c] [rprc output c] ...</strong></p>
</div>
<div class="section" id="id43">
<h4>4.6.3.5.6. Boot Modes<a class="headerlink" href="#id43" title="Permalink to this headline">¶</a></h4>
<p>This release of SBL supports MMCSD and QSPI boot modes.</p>
<div class="section" id="mmcsd-boot-mode">
<h5>4.6.3.5.6.1. MMCSD Boot Mode<a class="headerlink" href="#mmcsd-boot-mode" title="Permalink to this headline">¶</a></h5>
<div class="section" id="id44">
<h6>4.6.3.5.6.1.1. Preparing the SD card<a class="headerlink" href="#id44" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li>To boot the target, the SD card needs to be bootable. Follow the
steps at <a class="reference external" href="index_overview.html#windows-sd-card-creation-guide">Creating bootable SD card in windows</a>
or <a class="reference external" href="index_overview.html#linux-sd-card-creation-guide">Creating bootable SD card in Linux</a>.</li>
<li>Copy &#8220;MLO&#8221; and &#8220;app&#8221; to your SD card.<ul>
<li>MLO is the SBL formatted by the aforementioned tools. A pre-built
MLO can be found at:
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/binary/evmK2G/mmcsd/bin</strong></li>
<li>app is the target application to be booted and also formatted by
the aforementioned tools. (Note that the tools for making the
bootable MLO and the loadable app are different).</li>
</ul>
</li>
</ol>
</div>
<div class="section" id="id45">
<h6>4.6.3.5.6.1.2. Booting via SD Card<a class="headerlink" href="#id45" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li>Insert micro SD card into the SD card slot of the board</li>
<li>Set the board to MMC/SD bootmode by configuring the DIP switches to
&#8216;0111&#8217;. Verify the bootmode on the LCD display on your board</li>
<li>Open a serial communication terminal (such as TeraTerm, MiniCom,
etc.) on host PC and connect to the UART console port</li>
<li>Power on the board</li>
</ol>
<div class="line-block">
<div class="line">Below is an example of K2G SBL successfully booting the diagnostic
application:</div>
</div>
<img alt="../_images/K2g_boot_diag.jpg" src="../_images/K2g_boot_diag.jpg" />
</div>
</div>
<div class="section" id="qspi-boot-mode">
<h5>4.6.3.5.6.2. QSPI Boot Mode<a class="headerlink" href="#qspi-boot-mode" title="Permalink to this headline">¶</a></h5>
<div class="section" id="preparing-qspi-flash">
<h6>4.6.3.5.6.2.1. Preparing QSPI Flash<a class="headerlink" href="#preparing-qspi-flash" title="Permalink to this headline">¶</a></h6>
<p>MLO and app needs to be flashed into QSPI memory so that they can be
booted. MLO will reside at offset 0 and app will reside at offset
0x80000. QSPI flash memory map:</p>
<table border="1" class="docutils">
<colgroup>
<col width="76%" />
<col width="24%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Offset 0x0</td>
<td>MLO</td>
</tr>
<tr class="row-even"><td>Offset 0x80000</td>
<td>app</td>
</tr>
</tbody>
</table>
<p>The images can be flashed into QSPI flash by following steps given
below:</p>
<ol class="arabic simple">
<li>Copy MLO, app, and config to SD card<ul>
<li>MLO is the SBL formatted by the aforementioned tools. A pre-built
MLO can be found at:
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/binary/evmK2G/qspi/bin</strong></li>
<li>app is the target application to be booted and also formatted by
the aforementioned tools. (Note that the tools for making the
bootable MLO and the loadable app are different).</li>
<li>config helps specify the memory map. The default config file can
be found at:
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools/flashWriter/qspi</strong>.
This config file may be altered to custom user settings if needed.</li>
</ul>
</li>
<li>In the SD card, rename MLO to &#8220;boot&#8221;. This is the default name
specified by the config file.</li>
<li>Insert the SD card into the SD card slot on the board</li>
<li>Connect to the board with CCS. Launch target configuration and
connect to the ARM A15 core. GEL file will run on-connect and do
basic board-level initialization</li>
<li>Load the flash writer, qspi_flash_writer.out, to the connected core<ul>
<li>A pre-built qspi_flash_writer.out can be found at:
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools/flashWriter/qspi/bin/evmK2G</strong></li>
</ul>
</li>
<li>Run the QSPI flash writer application. You will see the following
logs on the EVM&#8217;s UART console:</li>
</ol>
<div class="highlight-cpp"><div class="highlight"><pre>*** PDK QSPI Flash Writer ***
Copying &#39;boot&#39; to local memory
Begin flashing &#39;boot&#39; into QSPI
Finished flashing &#39;boot&#39; with size 20010 at offset 0
Copying &#39;app&#39; to local memory
Begin flashing &#39;app&#39; into QSPI
Finished flashing &#39;app&#39; with size 19398 at offset 80000
Flashing completed!
</pre></div>
</div>
<p>This application will flash the image at required offset without taking
into consideration any overwriting to previously flashed image.</p>
</div>
<div class="section" id="id46">
<h6>4.6.3.5.6.2.2. Booting via QSPI<a class="headerlink" href="#id46" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li>Set the board to QSPI-48 bootmode by configuring the DIP switches to
&#8216;1111&#8217;. Verify the bootmode on the LCD display on your board</li>
<li>Open a serial communication terminal (such as TeraTerm, MiniCom,
etc.) on host PC and connect to the UART console port</li>
<li>Power on the board</li>
</ol>
</div>
</div>
</div>
<div class="section" id="memory-usage">
<h4>4.6.3.5.7. Memory Usage<a class="headerlink" href="#memory-usage" title="Permalink to this headline">¶</a></h4>
<p>SBL uses the last 0x40000 memory from MSMC RAM memory.</p>
<p>The SBL memory map is shown below:</p>
<img alt="../_images/SBL_mem_k2g.jpg" src="../_images/SBL_mem_k2g.jpg" />
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">app should not have loadable sections residing in SBL memory region to
prevent overwriting SBL during load time. It is, however, free to use
SBL memory after it is loaded and running.</p>
</div>
</div>
</div>
<div class="section" id="k2h-k2e-k2l">
<h3>4.6.3.6. K2H/K2E/K2L<a class="headerlink" href="#k2h-k2e-k2l" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id47">
<h4>4.6.3.6.1. Overview<a class="headerlink" href="#id47" title="Permalink to this headline">¶</a></h4>
<p>K2H/K2E/K2L EVMs uses the Secondary Boot Loader (SBL) to configure
board-related settings and execute a user application. The user
application can be single core or multicore, and execute on either DSP
cores or ARM cores. The only restriction is that the load sections must
not overlap the memory space that SBL uses.</p>
<p>The K2H/K2E/K2L SBL supports ARM master boot using SPI NOR. Please refer
to the boot mode dip switch settings in the respective EVM hardware page
(<a class="reference external" href="index_release_specific.html#supported-platforms-and-versions">link</a>)
to configure your EVM for NOR boot.</p>
</div>
<div class="section" id="id48">
<h4>4.6.3.6.2. Flashing the Bootloader<a class="headerlink" href="#id48" title="Permalink to this headline">¶</a></h4>
<p>SBL and user application needs to be flashed into SPI NOR.</p>
<p>Refer to <a class="reference external" href="http://processors.wiki.ti.com/index.php/Program_EVM_UG">Program EVM Guide</a> for
instructions on using the script, program_evm.js, to automatically flash
your device.</p>
</div>
<div class="section" id="id49">
<h4>4.6.3.6.3. Usage<a class="headerlink" href="#id49" title="Permalink to this headline">¶</a></h4>
<ol class="arabic simple">
<li>Flash the bootloader and user application. This can be done
automatically with default files by using program_evm.js</li>
<li>Set the EVM to ARM SPI boot mode</li>
<li>Connect UART serial debug cable from EVM to your computer. Open a
terminal such as HyperTerminal or TeraTerm to see console output</li>
<li>Power on the EVM</li>
</ol>
</div>
<div class="section" id="id50">
<h4>4.6.3.6.4. Compilation<a class="headerlink" href="#id50" title="Permalink to this headline">¶</a></h4>
<p>The recommended rule-of-thumb to compiling projects in the Processor SDK
RTOS package is to use the makefiles provided. The makefiles are usable
after setting up your shell/terminal/command prompt environment with the
setupenv.bat or setupenv.sh script located in</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">processor_sdk_rtos_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Refer to <a class="reference external" href="index_overview.html#building-the-sdk">Building RTOS SDK</a> page on how to
setup your environment for building within any of the Processor SDK RTOS
packages.</p>
<p>The SBL package can be found in:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">sbl</span>
</pre></div>
</div>
<p>To build:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">sbl</span>
<span class="n">make</span> <span class="n">all</span> <span class="n">BOOTMODE</span><span class="o">=</span><span class="n">spi</span> <span class="n">BOARD</span><span class="o">=&lt;</span><span class="n">EVM</span><span class="o">&gt;</span> <span class="n">SOC</span><span class="o">=&lt;</span><span class="n">platform</span><span class="o">&gt;</span>
</pre></div>
</div>
<p><em>&lt;EVM&gt;</em> can be of values: <strong>evmK2H</strong>, <strong>evmK2E</strong>, <strong>evmK2L</strong>, or
<strong>evmK2K</strong></p>
<p><em>&lt;platform&gt;</em> can be of values: <strong>K2H</strong>, <strong>K2E</strong>, <strong>K2L</strong>, or <strong>K2K</strong></p>
<p>The resulting output will be in [SDK Install
Path]/pdk_&lt;platform&gt;_&lt;version&gt;/packages/ti/boot/sbl/binary/&lt;platform&gt;/spi/bin
directory.</p>
</div>
<div class="section" id="id51">
<h4>4.6.3.6.5. Making Loadable User Application image (app)<a class="headerlink" href="#id51" title="Permalink to this headline">¶</a></h4>
<p>For converting the compiled .out files to a format loadable by TI&#8217;s
Secondary Boot Loader (SBL), you must follow these two steps:</p>
<ol class="arabic simple">
<li><strong>out2rprc.exe [.out file] [rprc output]</strong></li>
<li><strong>MulticoreImageGen.exe LE 55 [output name] 0 [rprc output]</strong></li>
</ol>
<p>Out2rprc.exe and MulticoreImageGen.exe are tools supplied by TI and can
be located in the <strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools</strong>
folder. &#8220;rprc output&#8221; can be any spare name of your choosing. &#8220;output
name&#8221; can also be any name of your choosing.</p>
<p>The &#8216;0&#8217; used in step 2 refers to the Core ID to boot. By default, &#8216;0&#8217; is
MPU (Cortex A15) core 0. You can input a different value to boot to
other cores. Valid values are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="18%" />
<col width="17%" />
<col width="17%" />
<col width="15%" />
<col width="18%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head" colspan="2">K2H</th>
<th class="head" colspan="2">K2E</th>
<th class="head" colspan="2">K2L</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><strong>Core</strong></td>
<td><strong>Value</strong></td>
<td><strong>Core</strong></td>
<td><strong>Value</strong></td>
<td><strong>Core</strong></td>
<td><strong>Value</strong></td>
</tr>
<tr class="row-odd"><td>MPU Core 0</td>
<td>0</td>
<td>MPU Core 0</td>
<td>0</td>
<td>MPU Core 0</td>
<td>0</td>
</tr>
<tr class="row-even"><td>MPU Core 1</td>
<td>1</td>
<td>MPU Core 1</td>
<td>1</td>
<td>MPU Core 1</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>MPU Core 2</td>
<td>2</td>
<td>MPU Core 2</td>
<td>2</td>
<td>MPU SMP</td>
<td>4</td>
</tr>
<tr class="row-even"><td>MPU Core 3</td>
<td>3</td>
<td>MPU Core 3</td>
<td>3</td>
<td>DSP Core 0</td>
<td>5</td>
</tr>
<tr class="row-odd"><td>MPU SMP</td>
<td>4</td>
<td>MPU SMP</td>
<td>4</td>
<td>DSP Core 1</td>
<td>6</td>
</tr>
<tr class="row-even"><td>DSP Core 0</td>
<td>5</td>
<td>DSP Core 0</td>
<td>5</td>
<td>DSP Core 2</td>
<td>7</td>
</tr>
<tr class="row-odd"><td>DSP Core 1</td>
<td>6</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>DSP Core 3</td>
<td>8</td>
</tr>
<tr class="row-even"><td>DSP Core 2</td>
<td>7</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>DSP Core 3</td>
<td>8</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>DSP Core 4</td>
<td>9</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>DSP Core 5</td>
<td>10</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>DSP Core 6</td>
<td>11</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>DSP Core 7</td>
<td>12</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>If MPU SMP is chosen, the same boot image and entry will be used for all
MPU cores. SBL can also parse multiple boot images that are concatenated
together. Simply use MulticoreImageGen as such:</p>
<p><strong>MulticoreImageGen.exe LE 55 [output name] [Core ID a] [rprc output a]
[Core ID b] [rprc output b] [Core ID c] [rprc output c] ...</strong></p>
</div>
<div class="section" id="id52">
<h4>4.6.3.6.6. Flash Writers<a class="headerlink" href="#id52" title="Permalink to this headline">¶</a></h4>
<div class="section" id="spi-writer">
<h5>4.6.3.6.6.1. SPI Writer<a class="headerlink" href="#spi-writer" title="Permalink to this headline">¶</a></h5>
<p>The SPI flash writer, spi_flash_writer.out, is a part of the SBL package
and allows users to flash multiple images at different offsets into the
board&#8217;s SPI NOR flash memory.</p>
<div class="section" id="id53">
<h6>4.6.3.6.6.1.1. Compilation<a class="headerlink" href="#id53" title="Permalink to this headline">¶</a></h6>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">sbl</span><span class="o">/</span>
<span class="n">make</span> <span class="n">spi_flashwriter</span> <span class="n">BOARD</span><span class="o">=&lt;</span><span class="n">EVM</span><span class="o">&gt;</span> <span class="n">SOC</span><span class="o">=&lt;</span><span class="n">platform</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The binary output will be at:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">sbl</span><span class="o">/</span><span class="n">tools</span><span class="o">/</span><span class="n">flashWriter</span><span class="o">/</span><span class="n">spi</span><span class="o">/</span><span class="n">bin</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id54">
<h6>4.6.3.6.6.1.2. Usage<a class="headerlink" href="#id54" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li>Copy the binaries that you want to flash to: [SDK Install
Path]/pdk_&lt;platform&gt;_&lt;version&gt;/packages/ti/boot/sbl/tools/flashWriter/spi/bin/&lt;platform&gt;</li>
<li>In that same directory, there is a file named <strong>config</strong>. Edit that
file such that each line has 2 parameters: [name of binary to flash]
[SPI NOR offset to flash to]</li>
<li>Set your EVM to NO BOOT. Power on, launch target configuration in
CCS, and connect to DSP Core 0</li>
<li>Load and run [SDK Install
Path]/pdk_&lt;platform&gt;_&lt;version&gt;/packages/ti/boot/sbl/tools/flashWriter/spi/bin/&lt;platform&gt;/spi_flash_writer.out</li>
<li>You should see the flash progress output on UART terminal</li>
</ol>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
</div>
<div class="section" id="boot-example">
<h4>4.6.3.6.7. Boot Example<a class="headerlink" href="#boot-example" title="Permalink to this headline">¶</a></h4>
<p>Below is an example output of evmK2H booting after having images flashed
in by program_evm.js:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="o">****</span> <span class="n">PDK</span> <span class="n">SBL</span> <span class="o">****</span>
<span class="n">Boot</span> <span class="n">succesful</span><span class="o">!</span>
<span class="n">Begin</span> <span class="n">parsing</span> <span class="n">user</span> <span class="n">application</span>
<span class="n">Jumping</span> <span class="n">to</span> <span class="n">user</span> <span class="n">application</span><span class="p">...</span>


<span class="n">TMDXEVM6636K2H</span> <span class="n">POST</span> <span class="n">Version</span> <span class="mf">01.00.00.08</span>
<span class="o">------------------------------------------</span>
<span class="n">SOC</span> <span class="n">Information</span>

<span class="n">BMC</span> <span class="n">Version</span><span class="o">:</span> <span class="mo">0000</span>
<span class="n">EFUSE</span> <span class="n">MAC</span> <span class="n">ID</span> <span class="n">is</span><span class="o">:</span> <span class="n">B4</span> <span class="mi">99</span> <span class="mi">4</span><span class="n">C</span> <span class="n">B6</span> <span class="n">E2</span> <span class="mi">5</span><span class="n">B</span>
<span class="n">SA</span> <span class="n">is</span> <span class="n">enabled</span> <span class="n">on</span> <span class="k">this</span> <span class="n">board</span><span class="p">.</span>
<span class="n">PLL</span> <span class="n">Reset</span> <span class="n">Type</span> <span class="n">Status</span> <span class="n">Register</span><span class="o">:</span> <span class="mh">0x00000001</span>
<span class="n">Platform</span> <span class="n">init</span> <span class="k">return</span> <span class="n">code</span><span class="o">:</span> <span class="mh">0x00000000</span>

<span class="n">Power</span> <span class="n">On</span> <span class="n">Self</span> <span class="n">Test</span>

<span class="n">POST</span> <span class="n">running</span> <span class="n">in</span> <span class="n">progress</span> <span class="p">...</span>
<span class="n">POST</span> <span class="n">I2C</span> <span class="n">EEPROM</span> <span class="n">read</span> <span class="n">test</span> <span class="n">started</span><span class="o">!</span>
<span class="n">POST</span> <span class="n">I2C</span> <span class="n">EEPROM</span> <span class="n">read</span> <span class="n">test</span> <span class="n">passed</span><span class="o">!</span>
<span class="n">POST</span> <span class="n">SPI</span> <span class="n">NOR</span> <span class="n">read</span> <span class="n">test</span> <span class="n">started</span><span class="o">!</span>
<span class="n">POST</span> <span class="n">SPI</span> <span class="n">NOR</span> <span class="n">read</span> <span class="n">test</span> <span class="n">passed</span><span class="o">!</span>
<span class="n">POST</span> <span class="n">EMIF16</span> <span class="n">NAND</span> <span class="n">read</span> <span class="n">test</span> <span class="n">started</span><span class="o">!</span>
<span class="n">POST</span> <span class="n">EMIF16</span> <span class="n">NAND</span> <span class="n">read</span> <span class="n">test</span> <span class="n">passed</span><span class="o">!</span>
<span class="n">POST</span> <span class="n">external</span> <span class="n">memory</span> <span class="n">test</span> <span class="n">started</span><span class="o">!</span>
<span class="n">POST</span> <span class="n">external</span> <span class="n">memory</span> <span class="n">test</span> <span class="n">passed</span><span class="o">!</span>
<span class="n">POST</span> <span class="n">done</span> <span class="n">successfully</span><span class="o">!</span>

<span class="n">POST</span> <span class="n">result</span><span class="o">:</span> <span class="n">PASS</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="omapl137-omapl138-c6748">
<h3>4.6.3.7. OMAPL137/OMAPL138/C6748<a class="headerlink" href="#omapl137-omapl138-c6748" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id55">
<h4>4.6.3.7.1. Overview<a class="headerlink" href="#id55" title="Permalink to this headline">¶</a></h4>
<p>The Secondary Bootloader (SBL) for OMAPL137/OMAPL138/C6748 does basic
hardware initialization for the board to load and run applications.
Processor SDK boot support for each of these SoC is shown below</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Device</th>
<th class="head">Cores</th>
<th class="head">Boot Master</th>
<th class="head">Supported
Boot
modes in
SBL</th>
<th class="head">HW
Platforms</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>OMAPL137</td>
<td>ARM (ARM9)
DSP (C674x)</td>
<td>DSP</td>
<td>SPI</td>
<td>OMAPL137
EVM</td>
</tr>
<tr class="row-odd"><td>OMAPL138</td>
<td>ARM (ARM9)
DSP (C674x)</td>
<td>ARM</td>
<td>MMCSD</td>
<td>OMAPL138
LCDK</td>
</tr>
<tr class="row-even"><td>C6748</td>
<td>DSP (C674x)</td>
<td>DSP</td>
<td>MMCSD</td>
<td>C6748 LCDK</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id56">
<h4>4.6.3.7.2. Bootloader Execution Sequence<a class="headerlink" href="#id56" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Power On Reset occurs</li>
<li>ROM Bootloader (RBL) executes. It checks for bootmode and attempts to
load+run the SBL from that bootmode.</li>
<li>SBL begins execution from internal memory (Shared RAM)<ul>
<li>Board Initialization is done by a call to <strong>Board_init()</strong> API.
For additional details refer to <a class="reference external" href="index_board.html#board-support">Processor SDK Board
Support</a>.</li>
<li>SBL setup includes configuring Pinmux, enable peripheral clocks,
set up PLLs, and configure EMIF for SDRAM/DDR.</li>
</ul>
</li>
<li>SBL finishes setup and looks for &#8220;app&#8221; to execute next. This
user-modifiable application shall reside on the boot media.</li>
<li>Once located, app will be loaded into memory and execution will be
branched to the application&#8217;s entry address</li>
</ul>
</div>
<div class="section" id="id57">
<h4>4.6.3.7.3. Tools and Binary Formats<a class="headerlink" href="#id57" title="Permalink to this headline">¶</a></h4>
<div class="section" id="id58">
<h5>4.6.3.7.3.1. Making Bootable SBL image (MLO)<a class="headerlink" href="#id58" title="Permalink to this headline">¶</a></h5>
<p>RBL loads and runs &#8220;MLO&#8221;, which is a .out executable formatted by TI
tools. HexAIS tool should be used to convert the .out into MLO using the
below command.</p>
<p>Windows Host</p>
<p><strong>&lt;HexAIS_Tool&gt; -o &lt;output file&gt; -ini &lt;ini file&gt; &lt;input file&gt;</strong></p>
<p>Linux Host</p>
<p>HexAIS executable can be run on Linux PC by using mono tool as shown
below</p>
<p><strong>mono &lt;HexAIS_Tool&gt; -o &lt;output file&gt; -ini &lt;ini file&gt; &lt;input file&gt;</strong></p>
<ul class="simple">
<li>&lt;HexAIS_Tool&gt; is HexAIS_OMAP-L137.exe for OMAPL137 and
HexAIS_OMAP-L138.exe for OMAPL138/C6748</li>
<li>‘output file’ is name of the output file. MLO in this case</li>
<li>‘ini file’ is configuration file for defining the boot parameters.
This file provides option to instruct RBL to take certain actions
before loading the MLO into internal memory. Sample ini file is
available at <strong>&lt; PDK_INSTALL_DIR
&gt;/packages/ti/boot/sbl/soc/&lt;device&gt;</strong></li>
</ul>
<p>&lt;device&gt; can be omapl137, omapl138 or c6748</p>
<ul class="simple">
<li>‘input file’ is the input .out file name which needs to be converted
into MLO</li>
</ul>
<p>OMAPL137 HexAIS tool is available at <strong>&lt; PDK_INSTALL_DIR
&gt;/packages/ti/boot/sbl/tools/omapl13x_boot_utils/OMAP-L137/GNU/AISUtils</strong>.</p>
<p>OMAPL138/C6748 HexAIS tool is available at <strong>&lt; PDK_INSTALL_DIR
&gt;/packages/ti/boot/sbl/tools/omapl13x_boot_utils/OMAP-L138/GNU/AISUtils</strong></p>
</div>
<div class="section" id="id59">
<h5>4.6.3.7.3.2. Making Loadable User Application image (app)<a class="headerlink" href="#id59" title="Permalink to this headline">¶</a></h5>
<p>For converting the compiled .out files to a format loadable by TI&#8217;s
Secondary Boot Loader (SBL), you must follow these two steps:</p>
<ol class="arabic simple">
<li><strong>out2rprc.exe [.out file] [rprc output]</strong></li>
<li><strong>MulticoreImageGen.exe LE 55 [output name] &lt;Core ID&gt; [rprc output]</strong></li>
</ol>
<p>Out2rprc.exe and MulticoreImageGen.exe are tools supplied by TI and can
be located in the <strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools</strong>
folder. &#8220;rprc output&#8221; can be any spare name of your choosing. &#8220;output
name&#8221; can also be any name of your choosing.</p>
<p>The &lt;Core ID&gt; used in step 2 refers to the Core ID to boot. Use &#8216;0&#8217; as
Core ID for ARM core and &#8216;1&#8217; for DSP core. Valid values are:. You can
input a different value to boot to other cores. Valid values are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="41%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Core</th>
<th class="head">Value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>ARM Core</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>DSP Core</td>
<td>1</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Program entry point of DSP app images on OMAPL138 platform should be 1KByte aligned for loading and executing the DSP images from
ARM core. GPIO LLD LED blink example for C674x core can be used as reference for aligning the DSP entry point to run the DSP code from
SBL. Other LLD examples does not work from SBL as is.</p>
</div>
</div>
</div>
<div class="section" id="id60">
<h4>4.6.3.7.4. Boot Modes<a class="headerlink" href="#id60" title="Permalink to this headline">¶</a></h4>
<p>This release of SBL supports SPI and MMCSD boot modes.</p>
<div class="section" id="spi-boot-mode">
<h5>4.6.3.7.4.1. SPI Boot Mode<a class="headerlink" href="#spi-boot-mode" title="Permalink to this headline">¶</a></h5>
<div class="section" id="preparing-spi-flash">
<h6>4.6.3.7.4.1.1. Preparing SPI Flash<a class="headerlink" href="#preparing-spi-flash" title="Permalink to this headline">¶</a></h6>
<p>MLO and app needs to be flashed into SPI memory so that they can be
booted. MLO will reside at offset 0 and app will reside at offset
0x80000. SPI flash memory map:</p>
<table border="1" class="docutils">
<colgroup>
<col width="76%" />
<col width="24%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Offset 0x0</td>
<td>MLO</td>
</tr>
<tr class="row-even"><td>Offset 0x80000</td>
<td>app</td>
</tr>
</tbody>
</table>
<p>The images can be flashed into SPI flash by following steps given below:</p>
<ol class="arabic simple">
<li>Copy MLO and app to SPI flash writer binary folder -
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools/flashWriter/spi/bin/evmOMAPL137</strong>.
Make sure config file also present in the SPI flash writer binary
folder.<ul>
<li>MLO is the SBL formatted by the aforementioned tools. A pre-built
MLO can be found at:
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/binary/evmOMAPL137/spi/bin</strong></li>
<li>app is the target application to be booted and also formatted by
the aforementioned tools. (Note that the tools for making the
bootable MLO and the loadable app are different).</li>
<li>config helps specify the memory map. The default config file can
be found at:
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools/flashWriter/spi/bin/evmOMAPL137</strong>.
This config file may be altered to custom user settings if needed.</li>
</ul>
</li>
<li>Connect the DB9 port of the EVM to host PC. Open serial communication
applications like TeraTerm, MiniCom, etc and configure for ‘115200
8N1’.</li>
<li>Connect to the board with CCS. Launch target configuration and
connect to the DSP C674x core. GEL file will run on-connect and do
basic board-level initialization</li>
<li>Load the flash writer, spi_flash_writer.out, to the connected core<ul>
<li>A pre-built spi_flash_writer.out can be found at:
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools/flashWriter/spi/bin/evmOMAPL137</strong></li>
</ul>
</li>
<li>Run the SPI flash writer application. You will see the following logs
on the EVM&#8217;s UART console:</li>
</ol>
<div class="highlight-cpp"><div class="highlight"><pre> <span class="o">***</span> <span class="n">PDK</span> <span class="n">SPI</span> <span class="n">Flash</span> <span class="n">Writer</span> <span class="o">***</span>
<span class="n">Opening</span> <span class="n">SPI</span> <span class="n">handle</span><span class="p">...</span>
<span class="n">SPI</span> <span class="n">handle</span> <span class="n">opened</span><span class="o">!</span>
<span class="n">Parsing</span> <span class="n">config</span> <span class="n">file</span> <span class="n">and</span> <span class="n">flashing</span> <span class="n">content</span> <span class="n">to</span> <span class="n">SPI</span> <span class="n">NOR</span><span class="p">...</span>
<span class="n">Parsed</span> <span class="n">config</span> <span class="n">line</span><span class="p">,</span> <span class="n">received</span> <span class="n">parameters</span><span class="o">:</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">MLO</span><span class="p">,</span> <span class="n">address</span> <span class="o">=</span> <span class="mh">0x0</span>
       <span class="n">Size</span> <span class="n">of</span> <span class="n">MLO</span> <span class="n">is</span> <span class="mh">0xc81c</span>
       <span class="n">Loading</span> <span class="n">binary</span> <span class="n">to</span> <span class="n">memory</span> <span class="p">...</span>
       <span class="n">Finished</span> <span class="n">loading</span> <span class="n">binary</span> <span class="n">to</span> <span class="n">memory</span><span class="o">!</span>
       <span class="n">Flashed</span> <span class="n">MLO</span> <span class="n">to</span> <span class="n">offset</span> <span class="mh">0x0</span><span class="o">!</span>
       <span class="n">Read</span> <span class="n">flash</span> <span class="n">memory</span> <span class="n">at</span> <span class="mh">0x0</span><span class="p">,</span> <span class="n">checking</span> <span class="n">flashed</span> <span class="n">content</span><span class="p">...</span>
       <span class="n">Verified</span> <span class="n">flash</span> <span class="n">data</span> <span class="n">equal</span> <span class="n">expected</span> <span class="n">data</span><span class="o">!</span>
<span class="n">Parsed</span> <span class="n">config</span> <span class="n">line</span><span class="p">,</span> <span class="n">received</span> <span class="n">parameters</span><span class="o">:</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">app</span><span class="p">,</span> <span class="n">address</span> <span class="o">=</span> <span class="mh">0x80000</span>
       <span class="n">Size</span> <span class="n">of</span> <span class="n">app</span> <span class="n">is</span> <span class="mh">0x16144</span>
       <span class="n">Loading</span> <span class="n">binary</span> <span class="n">to</span> <span class="n">memory</span> <span class="p">...</span>
       <span class="n">Finished</span> <span class="n">loading</span> <span class="n">binary</span> <span class="n">to</span> <span class="n">memory</span><span class="o">!</span>
       <span class="n">Flashed</span> <span class="n">app</span> <span class="n">to</span> <span class="n">offset</span> <span class="mh">0x80000</span><span class="o">!</span>
       <span class="n">Read</span> <span class="n">flash</span> <span class="n">memory</span> <span class="n">at</span> <span class="mh">0x80000</span><span class="p">,</span> <span class="n">checking</span> <span class="n">flashed</span> <span class="n">content</span><span class="p">...</span>
       <span class="n">Verified</span> <span class="n">flash</span> <span class="n">data</span> <span class="n">equal</span> <span class="n">expected</span> <span class="n">data</span><span class="o">!</span>
<span class="n">Successfully</span> <span class="n">flashed</span> <span class="n">memory</span> <span class="n">content</span><span class="o">!</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This application will flash the image at required offset without taking
into consideration any overwriting to previously flashed image.</p>
</div>
</div>
<div class="section" id="booting-via-spi">
<h6>4.6.3.7.4.1.2. Booting via SPI<a class="headerlink" href="#booting-via-spi" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li>Set the OMAPL137 EVM to SPI bootmode by configuring the SW2 DIP
switches 1-4 to &#8216;OFF ON OFF ON&#8217;. Other switch positions on SW2 are
don’t care for SPI boot.</li>
<li>Connect the DB9 port of the EVM to host PC. Open serial communication
applications like TeraTerm, MiniCom, etc and configure for ‘115200
8N1’</li>
<li>Power on the board</li>
</ol>
<p>Below is an example of OMAPL137 SBL successfully booting the GPIO LED
blink application</p>
<img alt="../_images/Omapl137_boot_example.jpg" src="../_images/Omapl137_boot_example.jpg" />
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="id61">
<h5>4.6.3.7.4.2. MMCSD Boot Mode<a class="headerlink" href="#id61" title="Permalink to this headline">¶</a></h5>
<p>OMAPL138/C6848 RBL does not support reading the boot images as files
from SD card. Secondary Boot loader image should be written to SD card
as raw data. Special formatting is needed for SD card to create
un-formatted area at the beginning of the card to store SBL.</p>
<div class="section" id="formatting-the-sd-card">
<h6>4.6.3.7.4.2.1. Formatting the SD Card<a class="headerlink" href="#formatting-the-sd-card" title="Permalink to this headline">¶</a></h6>
<p>SD card for booting OMAPL138/C6748 needs to be formatted from Linux PC
due to un-formatted area requirement. Formatting the SD card from
Windows PC is not supported in this release.</p>
<p>Connect the SD card to Linux PC and use below command to format the SD
card</p>
<p><strong>sudo sh create-sdcard-omapl13x.sh &lt;Drive Name&gt;</strong></p>
<ul class="simple">
<li>&lt;Drive Name&gt; is name of the drive on which SD card is mounted. Be
cautious while selecting the drive name. Running the script with
system drive name will corrupt the file system.</li>
<li>create-sdcard-omapl13x.sh script is available at
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools/omapl13x_sd_card_format</strong></li>
</ul>
</div>
<div class="section" id="id62">
<h6>4.6.3.7.4.2.2. Preparing the SD Card<a class="headerlink" href="#id62" title="Permalink to this headline">¶</a></h6>
<p>For both OMAPL138 and C6748, MLO needs to be flashed onto SD card
un-formatted area and app should be copied onto SD card.</p>
<p>MLO can be flashed into SD card un-formatted area by following steps
given below:</p>
<ol class="arabic simple">
<li>Build the MMCSD flash writer using below commands<ul>
<li>cd &lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl</li>
<li>gmake mmcsd_flashwriter SOC=OMAPL138 BOARD=lcdkOMAPL138
BOOTMODE=mmcsd</li>
</ul>
</li>
<li>Copy &#8216;app&#8217; to SD card and insert the card into MMCSD slot of the
board</li>
<li>Copy MLO to MMCSD flash writer binary folder -
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools/flashWriter/mmcsd/bin/lcdkOMAPL138</strong>.
Make sure config file also present in the MMCSD flash writer binary
folder.<ul>
<li>MLO is the SBL formatted by the aforementioned tools. A pre-built
MLO can be found at:
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/binary/lcdkOMAPL138/mmcsd/bin</strong></li>
<li>app is the target application to be booted and also formatted by
the aforementioned tools. (Note that the tools for making the
bootable MLO and the loadable app are different).</li>
<li>config helps specify the memory map. The default config file can
be found at:
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools/flashWriter/mmcsd/bin/lcdkOMAPL138</strong>.
This config file may be altered to custom user settings if needed.</li>
</ul>
</li>
<li>Connect the USB serial port of the EVM to host PC. Open serial
communication applications like TeraTerm, MiniCom, etc and configure
for ‘115200 8N1’.</li>
<li>Connect to the board with CCS. Launch target configuration, connect
to ARM core first (not needed for C6748) and then connect to the DSP
C674x core. GEL file will run on-connect and do basic board-level
initialization</li>
<li>Load the flash writer, mmcsd_flash_writer.out, to the connected core<ul>
<li>mmcsd_flash_writer.out can be found at:
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools/flashWriter/mmcsd/bin/lcdkOMAPL138</strong></li>
</ul>
</li>
<li>Run the MMCSD flash writer application. You will see the following
logs on the EVM&#8217;s UART console:</li>
</ol>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Opening</span> <span class="n">MMCSD</span> <span class="n">handle</span><span class="p">...</span>
<span class="n">MMCSD</span> <span class="n">handle</span> <span class="n">opened</span><span class="o">!</span>
<span class="n">Parsing</span> <span class="n">config</span> <span class="n">file</span> <span class="n">and</span> <span class="n">flashing</span> <span class="n">content</span> <span class="n">to</span> <span class="n">MMCSD</span><span class="p">...</span>
<span class="n">Parsed</span> <span class="n">config</span> <span class="n">line</span><span class="p">,</span> <span class="n">received</span> <span class="n">parameters</span><span class="o">:</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">MLO</span><span class="p">,</span> <span class="n">address</span> <span class="o">=</span> <span class="mh">0x200</span>
       <span class="n">Size</span> <span class="n">of</span> <span class="n">MLO</span> <span class="n">is</span> <span class="mh">0xb9b8</span>
       <span class="n">Loading</span> <span class="n">binary</span> <span class="n">to</span> <span class="n">memory</span> <span class="p">...</span>
       <span class="n">Finished</span> <span class="n">loading</span> <span class="n">binary</span> <span class="n">to</span> <span class="n">memory</span><span class="o">!</span>
       <span class="n">Flashed</span> <span class="n">MLO</span> <span class="n">to</span> <span class="n">offset</span> <span class="mh">0x200</span><span class="o">!</span>
       <span class="n">Read</span> <span class="n">flash</span> <span class="n">memory</span> <span class="n">at</span> <span class="mh">0x200</span><span class="p">,</span> <span class="n">checking</span> <span class="n">flashed</span> <span class="n">content</span><span class="p">...</span>
       <span class="n">Verified</span> <span class="n">flash</span> <span class="n">data</span> <span class="n">equal</span> <span class="n">expected</span> <span class="n">data</span><span class="o">!</span>
<span class="n">Successfully</span> <span class="n">flashed</span> <span class="n">memory</span> <span class="n">content</span><span class="o">!</span>
</pre></div>
</div>
<p>Procedure to flash the MLO described above is applicable to C6748 also.
Use C6748 for OMAPL138 and lcdkC6748 for lcdkOMAPL138 in all the paths
mentioned above.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">MLO</span> <span class="n">offset</span> <span class="n">in</span> <span class="n">config</span> <span class="n">file</span> <span class="n">is</span> <span class="n">set</span> <span class="n">to</span> <span class="mi">200</span> <span class="n">by</span> <span class="k">default</span> <span class="n">which</span> <span class="n">indicates</span> <span class="n">that</span> <span class="n">MLO</span> <span class="n">will</span> <span class="n">be</span> <span class="n">written</span> <span class="n">to</span> <span class="n">second</span> <span class="n">sector</span> <span class="n">of</span> <span class="n">the</span> <span class="n">SD</span> <span class="n">card</span><span class="p">.</span> <span class="n">MLO</span> <span class="n">offset</span> <span class="n">can</span> <span class="n">be</span> <span class="n">any</span> <span class="n">non</span><span class="o">-</span>
<span class="n">zero</span> <span class="n">value</span> <span class="n">which</span> <span class="n">is</span> <span class="n">multiple</span> <span class="n">of</span> <span class="mi">512</span> <span class="n">and</span> <span class="n">should</span> <span class="n">be</span> <span class="n">within</span> <span class="n">first</span> <span class="mi">2</span><span class="n">Mbytes</span> <span class="n">of</span> <span class="n">SD</span> <span class="n">card</span> <span class="n">memory</span><span class="p">.</span> <span class="n">DO</span> <span class="n">NOT</span> <span class="n">set</span> <span class="n">the</span> <span class="n">MLO</span> <span class="n">offset</span> <span class="n">to</span> <span class="sc">&#39;0&#39;</span> <span class="n">which</span> <span class="n">will</span> <span class="n">corrupt</span> <span class="n">the</span> <span class="n">file</span>
<span class="n">system</span> <span class="n">on</span> <span class="n">the</span> <span class="n">card</span><span class="p">.</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This application will flash the image at required offset without taking
into consideration any overwriting to previously flashed image.</p>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="booting-via-mmcsd">
<h6>4.6.3.7.4.2.3. Booting via MMCSD<a class="headerlink" href="#booting-via-mmcsd" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li>Set the OMAPL138/C6748 LCDK to MMCSD bootmode by configuring the SW1
DIP switches 1-4 to &#8216;OFF OFF OFF ON&#8217;. Other switch positions on SW1
are don’t care for MMCSD boot.</li>
<li>Connect the USB serial port of the EVM to host PC. Open serial
communication applications like TeraTerm, MiniCom, etc and configure
for ‘115200 8N1’</li>
<li>Power on the board</li>
</ol>
<p>Below is an example of OMAPL138 SBL successfully booting the GPIO LED
blink application</p>
<img alt="../_images/Omapl138_boot_example.png" src="../_images/Omapl138_boot_example.png" />
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
</div>
<div class="section" id="id63">
<h4>4.6.3.7.5. Memory Usage<a class="headerlink" href="#id63" title="Permalink to this headline">¶</a></h4>
<p>SBL uses 0x20000 bytes from shared RAM (0x80000000 to 0x8001FFFF).</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">app should not have loadable sections residing in SBL memory region to
prevent overwriting SBL during load time. It is, however, free to use
SBL memory after it is loaded and running.</p>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="additional-details">
<h4>4.6.3.7.6. Additional Details<a class="headerlink" href="#additional-details" title="Permalink to this headline">¶</a></h4>
<p>Use below commands to clean and build the SBL and associated tools.</p>
<div class="section" id="initial-steps">
<h5>4.6.3.7.6.1. Initial Steps<a class="headerlink" href="#initial-steps" title="Permalink to this headline">¶</a></h5>
<p>Setup the environment variables to configure the build tools</p>
<p>cd &lt;PDK_INSTALL_DIR&gt;/packages</p>
<p>Run pdksetupenv script</p>
<p>cd ti/boot/sbl</p>
</div>
<div class="section" id="cleaning-sbl">
<h5>4.6.3.7.6.2. Cleaning SBL<a class="headerlink" href="#cleaning-sbl" title="Permalink to this headline">¶</a></h5>
<p>gmake clean SOC=&lt;SoC Name&gt; BOARD=&lt;Board Name&gt; BOOTMODE=&lt;Boot Mode&gt;</p>
</div>
<div class="section" id="building-sbl">
<h5>4.6.3.7.6.3. Building SBL<a class="headerlink" href="#building-sbl" title="Permalink to this headline">¶</a></h5>
<p>gmake SOC=&lt;SoC Name&gt; BOARD=&lt;Board Name&gt; BOOTMODE=&lt;Boot Mode&gt;</p>
</div>
<div class="section" id="cleaning-flash-writer">
<h5>4.6.3.7.6.4. Cleaning Flash Writer<a class="headerlink" href="#cleaning-flash-writer" title="Permalink to this headline">¶</a></h5>
<p>gmake &lt;Flash Writer&gt;_clean SOC=&lt;SoC Name&gt; BOARD=&lt;Board Name&gt;
BOOTMODE=&lt;Boot Mode&gt;</p>
</div>
<div class="section" id="building-flash-writer">
<h5>4.6.3.7.6.5. building-flash-writer<a class="headerlink" href="#building-flash-writer" title="Permalink to this headline">¶</a></h5>
<p>gmake &lt;Flash Writer&gt; SOC=&lt;SoC Name&gt; BOARD=&lt;Board Name&gt; BOOTMODE=&lt;Boot
Mode&gt;</p>
<ul class="simple">
<li>use &#8216;make&#8217; instead of &#8216;gmake&#8217; on Linux host</li>
<li>&lt;SoC Name&gt; - OMAPL137, OMAPL138 or C6748</li>
<li>&lt;Board Name&gt; - evmOMAPL137, lcdkOMAPL138 or lcdkC6748</li>
<li>&lt;Boot Mode&gt; - spi or mmcsd as supported by the device</li>
<li>&lt;Flash Writer&gt; - spi_flashwriter for spi boot mmcsd_flashwriter for
mmcsd boot</li>
</ul>
<div class="highlight-cpp"><div class="highlight"><pre><span class="nl">Examples:</span>
<span class="n">Cleaning</span> <span class="o">&amp;</span> <span class="n">Building</span> <span class="n">OMAPL137</span> <span class="n">SBL</span>
<span class="n">gmake</span> <span class="n">clean</span> <span class="n">SOC</span><span class="o">=</span><span class="n">OMAPL137</span> <span class="n">BOARD</span><span class="o">=</span><span class="n">evmOMAPL137</span> <span class="n">BOOTMODE</span><span class="o">=</span><span class="n">spi</span>
<span class="n">gmake</span> <span class="n">SOC</span><span class="o">=</span><span class="n">OMAPL137</span> <span class="n">BOARD</span><span class="o">=</span><span class="n">evmOMAPL137</span> <span class="n">BOOTMODE</span><span class="o">=</span><span class="n">spi</span>

<span class="n">Cleaning</span> <span class="o">&amp;</span> <span class="n">Building</span> <span class="n">OMAPL137</span> <span class="n">flash</span> <span class="n">writer</span>
<span class="n">gmake</span> <span class="n">spi_flashwriter_clean</span> <span class="n">SOC</span><span class="o">=</span><span class="n">OMAPL137</span> <span class="n">BOARD</span><span class="o">=</span><span class="n">evmOMAPL137</span> <span class="n">BOOTMODE</span><span class="o">=</span><span class="n">spi</span>
<span class="n">gmake</span> <span class="n">spi_flashwriter</span> <span class="n">SOC</span><span class="o">=</span><span class="n">OMAPL137</span> <span class="n">BOARD</span><span class="o">=</span><span class="n">evmOMAPL137</span> <span class="n">BOOTMODE</span><span class="o">=</span><span class="n">spi</span>
</pre></div>
</div>
<p>On successful build, SBL .out and MLO will be created at
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/binary/&lt;Board Name&gt;/&lt;Boot
Mode&gt;/bin</strong> and flash writer binary will be created at
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools/flashWriter/&lt;Boot
Mode&gt;/bin/&lt;Board Name&gt;</strong></p>
</div>
</div>
</div>
</div>
<div class="section" id="bootloader-debugging">
<h2>4.6.4. Bootloader Debugging<a class="headerlink" href="#bootloader-debugging" title="Permalink to this headline">¶</a></h2>
<div class="section" id="common-steps-to-debug-application-boot">
<h3>4.6.4.1. Common Steps to debug application boot<a class="headerlink" href="#common-steps-to-debug-application-boot" title="Permalink to this headline">¶</a></h3>
<p>Bootloading an application is a system level issue which is impacted by
hardware as well as software setup. There are some common steps that
users are expected to check while debugging boot related issues. This
section discusses common issues to checkout when debugging application
boot.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="section" id="hardware-debug-steps">
<h4>4.6.4.1.1. Hardware Debug Steps<a class="headerlink" href="#hardware-debug-steps" title="Permalink to this headline">¶</a></h4>
<div class="toccolours" style="width:1600px"><p><strong>Input clocks and power sequencing</strong></p>
<ul class="simple">
<li>Ensure that correct power sequencing is occurring on your board.
Power sequencing specifications can be found in the data manual.</li>
<li>Check the system clock and ensure this is outputting the expected
frequency and the signal is swinging rail to rail (should be a 1.8V
signal). If you have an external oscillator, it should be outputting
a square wave at the desired frequency. If you are using a crystal ,
you should have a sine wave at the desired frequency at XTALIN.
XTALOUT should be similar (may be distorted a little).</li>
<li>Check the power on reset signal PORZ. This signal should stay low
throughout the power sequencing and go high when the power AND high
frequency clock are stable.</li>
<li>If the device has an OBSCLK or CLKOUT then ensure that this pin
provides the correct output that matches your software
configurations.</li>
</ul>
<p><strong>Boot pins:</strong></p>
<p>Best way to confirm what the device ROM bootloader reads from the pins
is to read the register where the Boot pins are latched into the device:</p>
<ul class="simple">
<li>For AM335x/AM437x: Check the Control_status register</li>
<li>For AM57xs: Check CTRL_CORE_BOOTSTRAP register</li>
<li>For C66x/K2X devices: Check the DEVSTAT register</li>
<li>For OMAPL13x/C674x devices: Check BOOTCFG register</li>
</ul>
<p><strong>Boot media connectivity</strong></p>
<p>Users are required to test their boot interface by running boot loader
independent diagnostic tests that confirm that the SOC can read and
write from the boot interface. Processor SDK RTOS provides Diagnostic
utilities for K2G/AMXX devices and provides POST utility for keystone
devices with which the TI EVM was tested.</p>
<p>TI Technical documentation like Technical reference manual (AMXX
devices), Bootloader USer guide (for C66x/K2X devices) and Bootloader
Application notes for OMAPLxx/C674x list default behavior or the ROM
bootloader and limitations and constraints for each boot mode.
Application developers need to account for this while designing their
system to ensure smooth bring up process.</p>
<p><strong>Signalling on boot media and reset pins</strong></p>
<p>If software and other hardware debug steps have not helped identify the
issue, you may need to hook up a scope or protocol analyzer to check the
clocks and the data transfers from the boot media to check if there is
any issues that can be identified. Another commonly known issue that
impacts boot is noise on the power lines which may cause the SOC to
reset or cause a hang on the boot core. Provide these scope shots to TI
on E2E forums so TI engineers can confirm that there are no issues.</p>
</div></div>
<div class="section" id="software-debug-steps">
<h4>4.6.4.1.2. Software Debug Steps<a class="headerlink" href="#software-debug-steps" title="Permalink to this headline">¶</a></h4>
<div class="toccolours" style="width:1600px"><p class="rubric" id="sbl-and-app-entry-points">SBL and app Entry points</p>
<p>If you don`t see your bootloader executing post boot, a good sanity
check is for you to look at the map file for the bootloader and ensure
that the entry point matches with the location in the TI or GPHeader in
the boot image. this can be done by looking at the entry point in the
MLO/_ti.bin/GPheader and ensure that it matches with the location of
symbol Entry in the .out/map file for the bootloader.</p>
<p class="rubric" id="sbl-and-app-memory-map">SBL and App memory map</p>
<p>The SBL execute from device onchip memory so if your application is also
using Onchip memory in addition to DDR memory, developers need to ensure
that the code sections in the application do not overlap with memory
sections that are used by the SBL. This can cause the SBL to hang during
the application boot process and go into an abort state.</p>
<p>To check what memory region is used by the SBL please locate the map
file created from building the bootloader.</p>
<p class="rubric" id="flash-programming-verification">Flash Programming verification</p>
<p>It is essential to understand that the flash programmer that you use has
not just the ability to write the image to flash but should also be able
to verify that the image written to flash matches the image that you
have created on your host machine. you can use TI flash programming
utilities as reference and ensure that the production flashing tools use
a method to erase, write and then verify the boot image that is written
to the flash.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p class="rubric" id="ddr-timings-and-configuration-sbl">DDR timings and configuration /SBL</p>
<p>The Processor SDK bootloader ships with DDR clock and timing settings
that apply to the external memory devices that have been used in TI
evaluation platforms. When running the code on custom platforms, users
may be required to change these setting to match the timings required by
custom design. We highly recommend that users create a GEL script
similar to one provided by TI and test the memory interface with the new
settings before using them in the secondary bootloader to setup external
memory. <a class="reference external" href="index_board.html#diagnostics">**Processor SDK Diagnostics**</a>
provides a mem_test that can be used to test read and writes to the
entire DDR address space for confirming the SOC EMIF settings.</p>
<p class="rubric" id="emulator-based-debugging-of-boot">Emulator based debugging of boot</p>
<p>The processor SDK RTOS bootloader is like any other application that can
be loaded over the emulator and debugged. Steps to connect an emulator
to the EVM have been described in the <a class="reference external" href="Release_Specific.html#supported-platforms-and-versions">**Hardware Setup Guides**</a>
that is linked to the Processor SDK RTOS documentation.</p>
<p>Loading the bootloader over emulator can be very useful step in
debugging the system boot. Before generating the final binary for
bootloader, the build generates the .out file for the bootloader which
is then formatted in a boot format that the ROM bootloader(RBL) can
interpret. This .out can be loaded over the emulator similar to any
other application. If you load the debug version of the bootloader, you
can single step through the code that initializes the SOC and also part
of the SBL code that loads the app from the boot media.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">SBL runs from onchip memory so users can load the SBL.out even without
using the GEL file but using the GEL sometimes helps with putting the
core in a clean state so usage of the GEL is optional</p>
</div>
<p><strong>Alternate Approach:</strong></p>
<p><strong>Add a spinlock in SBL main</strong></p>
<p>In some occasions the RBL may load the SBL but there may be some issue
that you need to debug in the SBL. In this case you can add a spinlock
loop at the start of main in SBL and allow the first stage boot to
complete normally and then connect to the core when you connect the core
will be held in the spinlock condition waiting for you to connect.</p>
<p>Example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">volatile</span> <span class="kt">int</span> <span class="n">exitSpinLock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">Debug_spinLock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">exitSpinLock</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You will then have to &#8220;release&#8221; the core by toggling the variable which
the while loop is blocking on. You can either do this manually by
halting CCS, examining the variable in the watch window and then
changing the value before continuing execution on the core, or you can
use a GEL script.</p>
<p><strong>Use an IO input to stall the core until user input is received:</strong></p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hit enter to continue:&quot;</span><span class="p">);</span>
<span class="n">getchar</span><span class="p">();</span>
</pre></div>
</div>
<p class="rubric" id="system-state-at-boot-failure">System state at boot failure</p>
<p>A useful data point for TI to debug boot related issues is to isolate
commonly known initialization and to understand how far the bootloader
has executed correctly before it runs into any issues. Users are
required to capture ARM/DSP clocks, Program counter value, Entry points
detected, pinmux configuration and confirm DDR initialization and slave
core states. This helps minimize the number of variables in the system
boot and helps us zero in on the most likely cause for the boot failure.</p>
</div>
</div>
</div>
<div class="section" id="uart-apploader">
<h2>4.6.5. UART AppLoader<a class="headerlink" href="#uart-apploader" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id64">
<h3>4.6.5.1. Overview<a class="headerlink" href="#id64" title="Permalink to this headline">¶</a></h3>
<p>UART AppLoader is a standalone application used to download application image over UART
from the host PC. Host PC uses the serial console utility to transfer application image to apploader.</p>
<p>The Apploader application loads and executes the application binary to be tested,
over UART on the target platform.</p>
</div>
<div class="section" id="supported-platforms">
<h3>4.6.5.2. Supported Platforms<a class="headerlink" href="#supported-platforms" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="32%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">SOC</th>
<th class="head">PLATFORM</th>
<th class="head">Verified Boot Modes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td rowspan="3">AM335x</td>
<td>AM335x GP EVM</td>
<td>MMCSD</td>
</tr>
<tr class="row-odd"><td>AM335x ICEv2</td>
<td>MMCSD</td>
</tr>
<tr class="row-even"><td>AMIC110 ICE</td>
<td>SPI</td>
</tr>
<tr class="row-odd"><td rowspan="2">AM437x</td>
<td>AM437x EVM</td>
<td>MMCSD</td>
</tr>
<tr class="row-even"><td>AM437x IDK</td>
<td>MMCSD</td>
</tr>
<tr class="row-odd"><td>AM571x</td>
<td>AM571x IDK</td>
<td>MMCSD</td>
</tr>
<tr class="row-even"><td rowspan="2">AM572x</td>
<td>AM572x EVM</td>
<td>MMCSD</td>
</tr>
<tr class="row-odd"><td>AM572x IDK</td>
<td>MMCSD</td>
</tr>
<tr class="row-even"><td>AM574x</td>
<td>AM574x IDK</td>
<td>MMCSD</td>
</tr>
<tr class="row-odd"><td rowspan="2">K2G</td>
<td>K2G GP EVM</td>
<td>MMCSD</td>
</tr>
<tr class="row-even"><td>K2G ICE</td>
<td>MMCSD</td>
</tr>
<tr class="row-odd"><td>OMAPL137</td>
<td>OMAPL137 EVM</td>
<td>SPI</td>
</tr>
<tr class="row-even"><td>OMAPL138</td>
<td>OMAPL138 LCDK</td>
<td>MMCSD</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="apploader-load-address">
<h3>4.6.5.3. Apploader Load Address<a class="headerlink" href="#apploader-load-address" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="18%" />
<col width="18%" />
<col width="23%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">SOC</th>
<th class="head">PLATFORM</th>
<th class="head">DDR Size</th>
<th class="head">DDR Start Address</th>
<th class="head">Apploader Load Address</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td rowspan="3">AM335x</td>
<td>AM335x GP EVM</td>
<td>1GB</td>
<td>0x80010000</td>
<td>0xBFE00000</td>
</tr>
<tr class="row-odd"><td>AM335x ICEv2</td>
<td>256MB</td>
<td>0x80010000</td>
<td>0x8FD00000</td>
</tr>
<tr class="row-even"><td>AMIC110 ICE</td>
<td>512MB</td>
<td>0x80010000</td>
<td>0x9FE00000</td>
</tr>
<tr class="row-odd"><td rowspan="2">AM437x</td>
<td>AM437x EVM</td>
<td>2GB</td>
<td>0x80000000</td>
<td>0xFFE00000</td>
</tr>
<tr class="row-even"><td>AM437x IDK</td>
<td>1GB</td>
<td>0x80000000</td>
<td>0xBFE00000</td>
</tr>
<tr class="row-odd"><td>AM571x</td>
<td>AM571x IDK</td>
<td>1GB</td>
<td>0x80000000</td>
<td>0xBFDFFFFF</td>
</tr>
<tr class="row-even"><td rowspan="2">AM572x</td>
<td>AM572x EVM</td>
<td>2GB</td>
<td>0x80000000</td>
<td>0xFFDFFFFF</td>
</tr>
<tr class="row-odd"><td>AM572x IDK</td>
<td>2GB</td>
<td>0x80000000</td>
<td>0xFFDFFFFF</td>
</tr>
<tr class="row-even"><td>AM574x</td>
<td>AM574x IDK</td>
<td>2GB</td>
<td>0x80000000</td>
<td>0xFFDFFFFF</td>
</tr>
<tr class="row-odd"><td rowspan="2">K2G</td>
<td>K2G GP EVM</td>
<td>2GB</td>
<td>0x80000000</td>
<td>0xFFD00000</td>
</tr>
<tr class="row-even"><td>K2G ICE</td>
<td>512MB</td>
<td>0x80000000</td>
<td>0x9FE00000</td>
</tr>
<tr class="row-odd"><td>OMAPL137</td>
<td>OMAPL137 EVM</td>
<td>64MB</td>
<td>0xC3000000</td>
<td>0xC6E00000</td>
</tr>
<tr class="row-even"><td>OMAPL138</td>
<td>OMAPL138 LCDK</td>
<td>128MB</td>
<td>0xC0000000</td>
<td>0xC7E00000</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="pre-requisites">
<h3>4.6.5.4. Pre-Requisites<a class="headerlink" href="#pre-requisites" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li>Download and install the Processor-SDK RTOS package. See the software product page for your device to get the latest version of this software:</li>
</ol>
<ul>
<li><p class="first"><a class="reference external" href="http://www.ti.com/tool/processor-sdk-am335x">Processor SDK for
AM335x</a></p>
</li>
<li><p class="first"><a class="reference external" href="http://www.ti.com/tool/processor-sdk-am437x">Processor SDK for
AM437x</a></p>
</li>
<li><p class="first"><a class="reference external" href="http://www.ti.com/tool/processor-sdk-am57x">Processor SDK for
AM57xx</a></p>
</li>
<li><p class="first"><a class="reference external" href="http://www.ti.com/tool/PROCESSOR-SDK-AMIC110">Processor SDK for
AMIC110</a></p>
</li>
<li><p class="first"><a class="reference external" href="http://www.ti.com/tool/processor-sdk-omapl137">Processor SDK RTOS for
C6747/OMAP-L17</a></p>
</li>
<li><p class="first"><a class="reference external" href="http://www.ti.com/tool/processor-sdk-omapl138">Processor SDK RTOS for
C6748/OMAP-L138</a></p>
</li>
<li><p class="first"><a class="reference external" href="http://www.ti.com/tool/PROCESSOR-SDK-K2G">Processor SDK RTOS for
K2G</a></p>
<p>From the appropriate software product page, go to the download page by
clicking &#8220;Get Software&#8221; for the RTOS package.</p>
</li>
</ul>
<ol class="arabic simple" start="2">
<li>The Uart Apploader binaries are found under &lt;pdk_install_path&gt;/packages/ti/board/utils/uartAppLoader/bin/&lt;board_name&gt;/sd/apploader_Test</li>
</ol>
<p><strong>Serial Connection</strong></p>
<p>Launch the serial console utility with the following configurations:</p>
<ul class="simple">
<li>Baud Rate: 115200</li>
<li>Data : 8 bits</li>
<li>Parity : None</li>
<li>Stop : 1 bit</li>
<li>Flow Control : None</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Any Serial Console utility that supports xmodem protocol can be used.
Verified utility is Teraterm</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TI Binaries does not work with Apploader on AM335x/AM437x platforms.
Make sure to use non TI binaries for testing on these platforms.</p>
</div>
</div>
<div class="section" id="apploader-usage">
<h3>4.6.5.5. AppLoader Usage<a class="headerlink" href="#apploader-usage" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li>Set the sysboot pins to the relevant boot mode(SPI / MMCSD).</li>
<li>Make sure UART connection is established between Target platform and Host PC.</li>
<li>Power cycle the board.</li>
<li>Check the below output on the serial console. The application starts sending character &#8216;C&#8217;</li>
</ol>
<div class="highlight-cpp"><div class="highlight"><pre><span class="o">****</span> <span class="n">PDK</span> <span class="n">SBL</span> <span class="o">****</span>
<span class="n">SBL</span> <span class="n">Revision</span><span class="o">:</span> <span class="mf">01.00.09.00</span> <span class="p">(</span><span class="n">May</span> <span class="mi">10</span> <span class="mi">2018</span> <span class="o">-</span> <span class="mi">15</span><span class="o">:</span><span class="mi">48</span><span class="o">:</span><span class="mi">57</span><span class="p">)</span>
<span class="n">Begin</span> <span class="n">parsing</span> <span class="n">user</span> <span class="n">application</span>

<span class="n">SD</span> <span class="n">Boot</span> <span class="o">-</span> <span class="n">file</span> <span class="n">open</span> <span class="n">completed</span> <span class="n">successfully</span>
<span class="n">Jumping</span> <span class="n">to</span> <span class="n">user</span> <span class="n">application</span><span class="p">...</span>
<span class="o">*********</span> <span class="n">PDK</span> <span class="n">UART</span> <span class="n">Apploader</span> <span class="o">********</span>
<span class="n">version</span> <span class="mf">0.1</span> <span class="p">(</span><span class="n">May</span> <span class="mi">14</span> <span class="mi">2018</span> <span class="o">-</span> <span class="mi">21</span><span class="o">:</span><span class="mi">40</span><span class="o">:</span><span class="mi">11</span><span class="p">)</span>

<span class="n">Please</span> <span class="n">transfer</span> <span class="n">file</span> <span class="n">with</span> <span class="n">XMODEM</span> <span class="n">protocol</span><span class="p">...</span>
<span class="n">CCCC</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The above log is for reference purpose and content might change based on latest software available in processor SDK release</p>
</div>
<ol class="arabic simple" start="5">
<li>Now transfer the application binary to be tested over UART using serial console utility.</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For example in Teraterm, use the following option to transfer the application binary.
File -&gt; Transfer -&gt; XMODEM -&gt; Send</p>
</div>
<ol class="arabic simple" start="6">
<li>Upon success, the apploader loads and executes the application.</li>
<li>Following is the sample output (using UART Diagnostic application), on the serial console.</li>
</ol>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Xmodem</span> <span class="n">received</span> <span class="mi">46848</span> <span class="n">bytes</span>

<span class="n">Copying</span> <span class="n">application</span> <span class="n">image</span> <span class="n">from</span> <span class="n">UART</span> <span class="n">to</span> <span class="n">RAM</span> <span class="n">is</span> <span class="n">done</span>
<span class="n">Begin</span> <span class="n">parsing</span> <span class="n">user</span> <span class="n">application</span>
<span class="n">Jumping</span> <span class="n">to</span> <span class="n">user</span> <span class="n">application</span><span class="p">...</span>

<span class="o">*********************************************</span>
<span class="o">*</span>                 <span class="n">UART</span> <span class="n">Test</span>                 <span class="o">*</span>
<span class="o">*********************************************</span>

<span class="n">Testing</span> <span class="n">UART</span> <span class="n">print</span> <span class="n">to</span> <span class="n">console</span> <span class="n">at</span> <span class="mf">115.2</span><span class="n">k</span> <span class="n">baud</span> <span class="n">rate</span>
<span class="n">Press</span> <span class="sc">&#39;y&#39;</span> <span class="n">to</span> <span class="n">verify</span> <span class="n">pass</span><span class="o">:</span> <span class="n">y</span>
<span class="nl">Received:</span> <span class="n">y</span>

<span class="n">Test</span> <span class="n">PASSED</span><span class="o">!</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For SPI Boot Mode:
1. Program Apploader to SPI flash using <a class="reference external" href="index_board.html#programming-binaries-to-flash-device">Uniflash</a> and boot the device from SPI flash.
2. Set the sysboot pins to SPI Boot mode</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For MMCSD Boot Mode:
1. Copy MLO to SD card.
2. Rename apploader_Test to app and copy to SD card.
3. Set the sysboot pins to MMCSD Boot mode</p>
</div>
</div>
<div class="section" id="rebuilding-apploader">
<h3>4.6.5.6. Rebuilding AppLoader<a class="headerlink" href="#rebuilding-apploader" title="Permalink to this headline">¶</a></h3>
<p>Apploader pre-built binaries are currently not available for OMAPL137/L138 platforms.
Binaries needs to be manually built for these platforms.</p>
<p>Refer <a class="reference internal" href="index_board.html#rebuild-board-utils"><em>Rebuilding Board-utils</em></a> section to build Apploader.</p>
</div>
</div>
</div>
<div class="section" id="mpm">
<h1>4.7. MPM<a class="headerlink" href="#mpm" title="Permalink to this headline">¶</a></h1>
<p class="rubric" id="introduction">Introduction</p>
<div class="line-block">
<div class="line">The Multiple Proc Manager (MPM) Package distributed with Processor SDK
RTOS installer has multiple software modules.</div>
<div class="line">Broadly the modules can be grouped into two categories:</div>
</div>
<ul class="simple">
<li>Multi Proc Manager Linux module</li>
<li>Modules that facilitate Interprocess communication between the
multiple cores.</li>
</ul>
<p class="rubric" id="multi-proc-manager-linux-module">Multi Proc Manager Linux module</p>
<p>The Multi Proc Manager Linux module is used to load and run DSP images
from ARM Linux user space. The download and run operations can be
exercised by using user space API calls. MPM also provides a MPM Client
Application which can be used to load and run DSP through command line.</p>
<p class="rubric" id="interprocessor-communication-related-packages">Interprocessor Communication related packages</p>
<p>The Multi Proc Manager package also includes couple of software modules
that facilitates Inter processor communication between ARM running linux
and DSP running RTOS. These components provide APIs in both ARM linux as
well as on DSP RTOS.</p>
<p class="rubric" id="mpm-mailbox-module">MPM Mailbox module</p>
<p>Mailbox is used for exchanging control messages between the host and
individual DSP cores.</p>
<p class="rubric" id="mpm-sync-module">MPM Sync module</p>
<p>Sync Module implements support for Multicore Barriers and Locks.</p>
</div>
<div class="section" id="openmp">
<h1>4.8. OpenMP<a class="headerlink" href="#openmp" title="Permalink to this headline">¶</a></h1>
<p class="rubric" id="id65">Introduction</p>
<p>As of April 2016, this article is out of date. Please visit
<a class="reference external" href="http://downloads.ti.com/mctools/esd/docs/openmp-dsp/index.html">here</a>.</p>
<p>This page is intended to be the starting point for all information about
OpenMP on C6000. However, at this writing, that is not the case. The
information in this article is correct if you are using C667x devices
which only contain C66x CorePac DSPs, and not any ARM cores. If you are
using a 66AK2H device, then please see <a class="reference external" href="http://processors.wiki.ti.com/index.php/MCSDK_HPC_3.x_OpenMP">MCSDK HPC 3.x
OpenMP</a>. OpenMP is not supported on
any other C6000 devices.</p>
<p>Still here? After reading this article, you will be able to execute your
own OpenMP code on C6000 under control of Code Composer Studio.</p>
<p class="rubric" id="presumptions">Presumptions</p>
<ul class="simple">
<li>You are experienced at programming OpenMP applications on hosted
systems like Windows or Linux PC&#8217;s.</li>
<li>You have never programmed anything on an embedded system like those
that use C6000 devices.</li>
<li>You have never used any TI development tools such as Code Composer
Studio (CCS).</li>
</ul>
<p class="rubric" id="acronyms-used-in-this-article">Acronyms Used in This Article</p>
<ul class="simple">
<li>CCS - Code Composer Studio. Software development environment for
creating code to execute on TI devices.</li>
<li>SYS/BIOS - Or BIOS for short. Scalable real-time kernel which runs on
the DSP.</li>
<li>MCSDK - Multicore Software Development Kit. Bundles all the software
supplied by TI which runs on the DSP.</li>
</ul>
<p class="rubric" id="conceptual-overview">Conceptual Overview</p>
<p>This section discusses, at a high level, how different pieces of
software from TI work together to form the OpenMP solution.</p>
<p>The OpenMP source code, at the level of OpenMP pragmas and function
calls, is the same. Your code must be organized into a <em>project</em>, as
that term is defined by CCS. A central element of this project is the
SYS/BIOS configuration. SYS/BIOS (or BIOS for short) is a scalable
real-time kernel produced by TI. BIOS implements the multi-threading
features of OpenMP. An initial BIOS configuration (<a href="#id66"><span class="problematic" id="id67">*</span></a>.cfg) is supplied.
Changing this BIOS configuration may never be required. The build is
done within CCS. At the start, system execution is also done within CCS.
Besides BIOS, many other software components execute on the DSP to
comprise the OpenMP solution. All of these components are delivered
together under the name Multicore Software Development Kit (MCSDK).</p>
<p class="rubric" id="installation">Installation</p>
<p>Getting the MCSDK installed calls for you to install and configure
everything else, so this section focuses on the MCSDK.</p>
<p>Start with the <a class="reference external" href="http://www.ti.com/tool/bioslinuxmcsdk">general download
page</a> for all flavors of the
MCSDK. Follow the link for <em>SYS/BIOS MCSDK for C66x</em>. Get MCSDK version
2.1 or later. That page includes a link to a <em>Getting Started Guide</em>.
That is where you will find directions on hardware setup, installing
CCS, and so on. Follow all the steps in the Getting Started Guide, up to
Running the Demonstration Application. (Actually, go ahead and run the
Demo if you want. But it isn&#8217;t required.)</p>
<p class="rubric" id="confidence-test">Confidence Test</p>
<p>If you are familiar with CCS, you may skip over this section. But,
installing and configuring all that software may leave you wondering if
you did it all correctly. In this section, simplify things by pretending
your system only has one core. This allows you to check whether you have
installed most of the software correctly, while ignoring many of the
complicated details.</p>
<p>Please check out <a class="reference external" href="http://processors.wiki.ti.com/index.php/Category:Code_Composer_Studio_v5#Getting_Started">this set of Getting Started
Guides</a>
just for CCS. You only need to go through one of them. Choose the one
that seems best for you. These guides provide a gentle introduction to
those who are new to CCS.</p>
<p>When you load and run your first program, CCS needs to know which core
to run it on. You see a dialog box similar this one:</p>
<img alt="../_images/Select_core.JPG" src="../_images/Select_core.JPG" />
<p>Check the box only for core 0.</p>
<p class="rubric" id="first-openmp-project">First OpenMP Project</p>
<p>This section walks through a simple hello world example project. Four
threads run concurrently. Each thread prints hello world and the thread
ID.</p>
<p class="rubric" id="version-and-hw-information">Version and HW Information</p>
<p>This section was developed with CCS version 5.2.0.00069, MCSDK version
2.1.0.3, and executed on an C6678 EVM. If your environment differs, you
may have to make a few adjustments.</p>
<p class="rubric" id="project-setup">Project Setup</p>
<p>In this section you create a new CCS project. This project is not
written from scratch, but uses example source files that come with CCS.</p>
<p>Put CCS in the Edit Perspective. Select: <strong>Window | Open Perspective |
Other | CCS Edit</strong>. To start this new project select: <strong>Project | New
CCS Project</strong>. Enter a <strong>Project Name</strong>. For <strong>Family</strong> select
<strong>C6000</strong>. For <strong>Variant</strong>, ignore the first drop-down box, and in the
second choose <strong>Generic C66xx Device</strong>. In the box just under <strong>Project
templates and examples</strong> type in <em>hello</em>. Under <em>OMP Examples</em> you will
see some <em>Hello world example</em> projects. Select the best one for your HW
platform. In this screen shot, the selection is for C6678. Select
<strong>Next</strong>.</p>
<img alt="../_images/Omp_h1_project_setup.jpg" src="../_images/Omp_h1_project_setup.jpg" />
<p>The next dialog shows the RTSC Configuration Settings. If only one
version of the MCSDK is installed, then nothing more is required. If
more than one version of the MCSDK is installed, review the version
numbers of the selected packages and insure they are from the desired
MCSDK. Do not forget the drop-down box at the top for the version of the
XDCtools.</p>
<p>Click <strong>Finish</strong>. CCS creates the project, complete with source code,
and adds an entry to the <strong>Project Explorer</strong> window.</p>
<p class="rubric" id="project-modifications">Project Modifications</p>
<p>One modification to the example project is required.</p>
<p>In the <strong>Project Explorer</strong> window, expand the set of files available
under the new project. Open the file <em>omp_config.cfg</em> by double-clicking
on it. The edit window has two tabs on the bottom left. Select the
<strong>Source</strong> tab. Find the source line which begins <em>var OpenMP ...</em>
Change the code as follows ...</p>
<div class="highlight-cpp"><div class="highlight"><pre>var OpenMP = xdc.useModule(&#39;ti.omp.utils.OpenMP&#39;);    // no change
OpenMP.setNumProcessors(4);                           // no change
OpenMP.autoDnldCore = false;                          // add this line
</pre></div>
</div>
<p>The new line disables the feature called auto-download. A side effect of
auto-download is that printf works only on core 0.</p>
<p>Save the change to the configuration file by entering control+S or
selecting <strong>File | Save</strong>.</p>
<p class="rubric" id="build-and-load">Build and Load</p>
<p>The target configuration that should launch when this OpenMP project is
debugged is the same one used for previous single core projects. To
check on this detail, choose <strong>View | Target Configurations</strong>. Find
that target configuration and insure it is the default.</p>
<p>In the <strong>Project Explorer</strong> window, insure the new project is selected.</p>
<p>Select the Debug icon.</p>
<img alt="../_images/Omp_h2_debug_icon.JPG" src="../_images/Omp_h2_debug_icon.JPG" />
<p>Next a dialog will come up which asks which CPU cores to load the
program on. Select cores 0-3, then click <strong>OK</strong>. It will appear similar
to this ...</p>
<img alt="../_images/Omp_h3_select_cores.JPG" src="../_images/Omp_h3_select_cores.JPG" />
<p>The following actions take place automatically:</p>
<ul class="simple">
<li>CCS changes to the Debug perspective</li>
<li>The project is built</li>
<li>The target configuration is launched</li>
<li>The target connection is made</li>
<li>The program is loaded on cores 0-3</li>
<li>The system begins execution and runs to the start of main on core 0</li>
</ul>
<p class="rubric" id="execute-and-see-output">Execute and See Output</p>
<p>Now you are ready to execute. In the Debug window, click the Resume
execution icon.</p>
<img alt="../_images/Omp_h4_resume_icon.JPG" src="../_images/Omp_h4_resume_icon.JPG" />
<p>The console window will show output similar to, but not exactly the same
as, the following ...</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span> <span class="n">Hello</span> <span class="n">World</span> <span class="n">from</span> <span class="kr">thread</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span> <span class="n">Number</span> <span class="n">of</span> <span class="n">threads</span> <span class="o">=</span> <span class="mi">4</span>
<span class="p">[</span><span class="n">C66xx_1</span><span class="p">]</span> <span class="n">Hello</span> <span class="n">World</span> <span class="n">from</span> <span class="kr">thread</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">[</span><span class="n">C66xx_2</span><span class="p">]</span> <span class="n">Hello</span> <span class="n">World</span> <span class="n">from</span> <span class="kr">thread</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">[</span><span class="n">C66xx_3</span><span class="p">]</span> <span class="n">Hello</span> <span class="n">World</span> <span class="n">from</span> <span class="kr">thread</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div>
</div>
<p>Because the threads are executing on the cores concurrently, there is no
control over the order in which the output appears. But you should see
all of these lines.</p>
<p class="rubric" id="tips-on-system-startup">Tips on System Startup</p>
<p>If things do not go smoothly, please see the article
<a class="reference external" href="http://processors.wiki.ti.com/index.php/SystemAnalyzerTutorial7">SystemAnalyzerTutorial7</a>. That
article is about running a tutorial for a tool named Unified
Instrumentation Architecture (UIA). UIA is for analyzing system
performance and behavior. This tutorial contains several tips on how to
use CCS to run OpenMP programs. It is relevant to the versions of the
MCSDK components listed near the beginning.</p>
<p class="rubric" id="second-openmp-project">Second OpenMP Project</p>
<p>Now try another project like hello world, but a bit more complicated. It
will serve as the basis for your future OpenMP projects.</p>
<p class="rubric" id="project-setup-1">Project Setup</p>
<p>Start it the same way as the hello world project. But give it a
different name, look for <em>matrix</em> among the examples, and choose the
<em>OpenMP matrix vector multiplication example</em> for your system.</p>
<img alt="../_images/Omp_h5_matvec_setup.JPG" src="../_images/Omp_h5_matvec_setup.JPG" />
<p class="rubric" id="build-and-execute">Build and Execute</p>
<p>All the remaining steps are the same as with the hello world project.</p>
<p>Upon executing, output in the console window should appear similar to
...</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span> <span class="n">Starting</span> <span class="n">values</span> <span class="n">of</span> <span class="n">matrix</span> <span class="n">A</span> <span class="n">and</span> <span class="n">vector</span> <span class="n">b</span><span class="o">:</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>   <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span> <span class="mf">2.0</span> <span class="mf">3.0</span> <span class="mf">4.0</span> <span class="mf">5.0</span> <span class="mf">6.0</span> <span class="mf">7.0</span> <span class="mf">8.0</span> <span class="mf">9.0</span> <span class="mf">10.0</span>   <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>   <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span> <span class="mf">2.0</span> <span class="mf">3.0</span> <span class="mf">4.0</span> <span class="mf">5.0</span> <span class="mf">6.0</span> <span class="mf">7.0</span> <span class="mf">8.0</span> <span class="mf">9.0</span> <span class="mf">10.0</span>   <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span> <span class="mf">2.0</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>   <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span> <span class="mf">2.0</span> <span class="mf">3.0</span> <span class="mf">4.0</span> <span class="mf">5.0</span> <span class="mf">6.0</span> <span class="mf">7.0</span> <span class="mf">8.0</span> <span class="mf">9.0</span> <span class="mf">10.0</span>   <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span> <span class="mf">3.0</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>   <span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span> <span class="mf">2.0</span> <span class="mf">3.0</span> <span class="mf">4.0</span> <span class="mf">5.0</span> <span class="mf">6.0</span> <span class="mf">7.0</span> <span class="mf">8.0</span> <span class="mf">9.0</span> <span class="mf">10.0</span>   <span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span> <span class="mf">4.0</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>   <span class="n">A</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span> <span class="mf">2.0</span> <span class="mf">3.0</span> <span class="mf">4.0</span> <span class="mf">5.0</span> <span class="mf">6.0</span> <span class="mf">7.0</span> <span class="mf">8.0</span> <span class="mf">9.0</span> <span class="mf">10.0</span>   <span class="n">b</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span> <span class="mf">5.0</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>   <span class="n">A</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span> <span class="mf">2.0</span> <span class="mf">3.0</span> <span class="mf">4.0</span> <span class="mf">5.0</span> <span class="mf">6.0</span> <span class="mf">7.0</span> <span class="mf">8.0</span> <span class="mf">9.0</span> <span class="mf">10.0</span>   <span class="n">b</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">=</span> <span class="mf">6.0</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>   <span class="n">A</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span> <span class="mf">2.0</span> <span class="mf">3.0</span> <span class="mf">4.0</span> <span class="mf">5.0</span> <span class="mf">6.0</span> <span class="mf">7.0</span> <span class="mf">8.0</span> <span class="mf">9.0</span> <span class="mf">10.0</span>   <span class="n">b</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">=</span> <span class="mf">7.0</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>   <span class="n">A</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span> <span class="mf">2.0</span> <span class="mf">3.0</span> <span class="mf">4.0</span> <span class="mf">5.0</span> <span class="mf">6.0</span> <span class="mf">7.0</span> <span class="mf">8.0</span> <span class="mf">9.0</span> <span class="mf">10.0</span>   <span class="n">b</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">=</span> <span class="mf">8.0</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>   <span class="n">A</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span> <span class="mf">2.0</span> <span class="mf">3.0</span> <span class="mf">4.0</span> <span class="mf">5.0</span> <span class="mf">6.0</span> <span class="mf">7.0</span> <span class="mf">8.0</span> <span class="mf">9.0</span> <span class="mf">10.0</span>   <span class="n">b</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">=</span> <span class="mf">9.0</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>   <span class="n">A</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span> <span class="mf">2.0</span> <span class="mf">3.0</span> <span class="mf">4.0</span> <span class="mf">5.0</span> <span class="mf">6.0</span> <span class="mf">7.0</span> <span class="mf">8.0</span> <span class="mf">9.0</span> <span class="mf">10.0</span>   <span class="n">b</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="o">=</span> <span class="mf">10.0</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span> <span class="n">Results</span> <span class="n">by</span> <span class="kr">thread</span><span class="o">/</span><span class="n">row</span><span class="o">:</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>   <span class="kr">thread</span> <span class="mi">0</span> <span class="n">did</span> <span class="n">row</span> <span class="mi">0</span>   <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mf">55.00</span> <span class="n">Running</span> <span class="n">total</span><span class="o">=</span> <span class="mf">55.00</span>
<span class="p">[</span><span class="n">C66xx_3</span><span class="p">]</span>   <span class="kr">thread</span> <span class="mi">3</span> <span class="n">did</span> <span class="n">row</span> <span class="mi">9</span>   <span class="n">c</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="o">=</span><span class="mf">550.00</span>    <span class="n">Running</span> <span class="n">total</span><span class="o">=</span> <span class="mf">605.00</span>
<span class="p">[</span><span class="n">C66xx_1</span><span class="p">]</span>   <span class="kr">thread</span> <span class="mi">1</span> <span class="n">did</span> <span class="n">row</span> <span class="mi">3</span>   <span class="n">c</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="mf">220.00</span>    <span class="n">Running</span> <span class="n">total</span><span class="o">=</span> <span class="mf">825.00</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>   <span class="kr">thread</span> <span class="mi">0</span> <span class="n">did</span> <span class="n">row</span> <span class="mi">1</span>   <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mf">110.00</span>    <span class="n">Running</span> <span class="n">total</span><span class="o">=</span> <span class="mf">935.00</span>
<span class="p">[</span><span class="n">C66xx_1</span><span class="p">]</span>   <span class="kr">thread</span> <span class="mi">1</span> <span class="n">did</span> <span class="n">row</span> <span class="mi">4</span>   <span class="n">c</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="mf">275.00</span>    <span class="n">Running</span> <span class="n">total</span><span class="o">=</span> <span class="mf">1210.00</span>
<span class="p">[</span><span class="n">C66xx_2</span><span class="p">]</span>   <span class="kr">thread</span> <span class="mi">2</span> <span class="n">did</span> <span class="n">row</span> <span class="mi">6</span>   <span class="n">c</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">=</span><span class="mf">385.00</span>    <span class="n">Running</span> <span class="n">total</span><span class="o">=</span> <span class="mf">1595.00</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>   <span class="kr">thread</span> <span class="mi">0</span> <span class="n">did</span> <span class="n">row</span> <span class="mi">2</span>   <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="mf">165.00</span>    <span class="n">Running</span> <span class="n">total</span><span class="o">=</span> <span class="mf">1760.00</span>
<span class="p">[</span><span class="n">C66xx_1</span><span class="p">]</span>   <span class="kr">thread</span> <span class="mi">1</span> <span class="n">did</span> <span class="n">row</span> <span class="mi">5</span>   <span class="n">c</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">=</span><span class="mf">330.00</span>    <span class="n">Running</span> <span class="n">total</span><span class="o">=</span> <span class="mf">2090.00</span>
<span class="p">[</span><span class="n">C66xx_2</span><span class="p">]</span>   <span class="kr">thread</span> <span class="mi">2</span> <span class="n">did</span> <span class="n">row</span> <span class="mi">7</span>   <span class="n">c</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">=</span><span class="mf">440.00</span>    <span class="n">Running</span> <span class="n">total</span><span class="o">=</span> <span class="mf">2530.00</span>
<span class="p">[</span><span class="n">C66xx_2</span><span class="p">]</span>   <span class="kr">thread</span> <span class="mi">2</span> <span class="n">did</span> <span class="n">row</span> <span class="mi">8</span>   <span class="n">c</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">=</span><span class="mf">495.00</span>    <span class="n">Running</span> <span class="n">total</span><span class="o">=</span> <span class="mf">3025.00</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span> <span class="n">Matrix</span><span class="o">-</span><span class="n">vector</span> <span class="n">total</span> <span class="o">-</span> <span class="n">sum</span> <span class="n">of</span> <span class="n">all</span> <span class="n">c</span><span class="p">[]</span> <span class="o">=</span> <span class="mf">3025.00</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>
</pre></div>
</div>
<p>The parts before and after <em>Results by thread/row</em> should match,
particularly the final result of 3025.00. The <em>thread N</em> lines will
vary, but there should be one line for each row 0-9.</p>
<p class="rubric" id="start-your-openmp-project">Start Your OpenMP Project</p>
<p>Build your OpenMP project out of the matrix multiply project. In the
<strong>Project Explorer</strong> window, select the matrix multiply project,
right-click and choose <strong>Copy</strong>. Right-click again and choose <strong>Paste</strong>.
Give the new project a name. It starts as a copy of the matrix multiply
project in every respect, except the name. Remove files, add files, and
make the project your own. Modifications to the omp_config.cfg file are
not required for base functionality.</p>
<p class="rubric" id="debugging-tips">Debugging Tips</p>
<p>Suppose you want to immediately execute one of those example projects
again. You need to reset the CPU cores, reload the program, and run
again. Here is a good way to do that.</p>
<p>In the <strong>Debug</strong> window, select cores 0-3, right-click and choose
<strong>Group Core(s)</strong>.</p>
<img alt="../_images/Omp_h6_group_cores.JPG" src="../_images/Omp_h6_group_cores.JPG" />
<p>Now reset the cores in the newly formed group. Select the group and
click the <strong>CPU Reset</strong> icon near the top right of the <strong>Debug</strong> window.</p>
<p>CPU Reset icon</p>
<img alt="../_images/Omp_h7_cpu_reset.JPG" src="../_images/Omp_h7_cpu_reset.JPG" />
<p>Then reload the program with the menu selection <strong>Run | Load | Reload
Program</strong>. Now you are ready to resume execution as before. Compare with
the output you got last time, and see how some lines are in a different
order.</p>
<p class="rubric" id="how-to-obtain-support">How to Obtain Support</p>
<p>Post your questions and suspected bugs to the <a class="reference external" href="http://e2e.ti.com/support/development_tools/compiler/f/343.aspx">compiler
forum</a>
with the tag <tt class="docutils literal"><span class="pre">openmp</span></tt>. Please use the tag. Use of the tag triggers an
e-mail to the current support team. Without the tag, the issue may go
unnoticed for some time.</p>
</div>
<div class="section" id="pktlib">
<h1>4.9. PKTLIB<a class="headerlink" href="#pktlib" title="Permalink to this headline">¶</a></h1>
<p class="rubric" id="id68">Introduction</p>
<p>The packet library (PKTLIB) provides higher layer of abstraction for
underlying CPPI hardware descriptors to application layer.
Functionalities include:</p>
<ul class="simple">
<li>Zero copy operation for:<ul>
<li>Packet split/merge operations</li>
<li>Cloning operations</li>
<li>Headroom/Tail room addition through merge operation</li>
</ul>
</li>
<li>Allocations of packet buffer and descriptors during startup time</li>
<li>Allows packet allocation by HW at Rx CPPI DMA</li>
<li>Efficient recycling of data buffers including the case of buffers
being referenced by multiple CPPI descriptors</li>
</ul>
<p class="rubric" id="modes-of-operation">Modes of Operation</p>
<p>A pktlib heap can be created in on of the following two modes:</p>
<ul class="simple">
<li>Private: only visible on the core where the heap was created</li>
<li>Shared: visible across multiple cores</li>
</ul>
<p class="rubric" id="driver-configuration-pktlib">Driver Configuration</p>
<p>Applications can use Pktlib_createHeap() API to create heap(s) in the
system and heap properties are specified by the Pktlib_HeapCfg
configuration structure. This configuration structure should be
populated by the application and passed to the PKTLIB module when a heap
is being created via the Pktlib_createHeap() API. Multiple heaps can
exist in the system where each heaps properties are specified by the
Pktlib_HeapCfg configuration structure.</p>
<p>For details about individual fields of this structure, see the Doxygen
help by opening
PDK_INSTALL_DIRpackagestiruntimepktlibdocsdoxygenhtmlindex.html.</p>
<p class="rubric" id="apis"><strong>APIs</strong></p>
<p>API reference for application can be found in below file:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &lt;ti/runtime/pktlib/pktlib.h&gt;</span>
</pre></div>
</div>
<p class="rubric" id="example">Example</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
<th class="head">Expected Results</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>pktlibUnitTest
Application</td>
<td><div class="first last line-block">
<div class="line">Unit Test
application to test
all APIs</div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">User observes the
output printed over
the CCS console</div>
</div>
</td>
</tr>
</tbody>
</table>
<p class="rubric" id="additional-references">Additional References</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Document</strong></td>
<td><strong>Location</strong></td>
</tr>
<tr class="row-even"><td>API Reference Manual</td>
<td>$(TI_PDK_INSTALL_DIR)packagesti
runtimepktlibdocsdoxygenhtml
index.html</td>
</tr>
<tr class="row-odd"><td>Release Notes</td>
<td>$(TI_PDK_INSTALL_DIR)packagesti
runtimepktlibdocsReleaseNotes
_pktlib.pdf</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="network">
<h1>4.10. Network<a class="headerlink" href="#network" title="Permalink to this headline">¶</a></h1>
<div class="section" id="cclink">
<h2>4.10.1. CCLink<a class="headerlink" href="#cclink" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id69">
<h3>4.10.1.1. Introduction<a class="headerlink" href="#id69" title="Permalink to this headline">¶</a></h3>
<p>CC-Link is an open-architecture network that was originally developed
by the Mitsubishi Electric Corporation.It have been widely used in
Process control, building automation etc. CLPA (CC-Link Partner
Association) maintains the network technology and support many
manufacturer supporting the application. CC-Link is available in
multiple flavours i.e. CC-Link, CC-Link LT, CC-Link Safety, CC-Link IE
(Industrial Ethernet) - Control and CC-Link IE Field. For further
details regarding CCLink and its flavours please refer the CLPA
website.<a class="reference external" href="http://am.cc-link.org/en/index.html">[1]</a></p>
</div>
<div class="section" id="protocol-overview">
<h3>4.10.1.2. Protocol Overview<a class="headerlink" href="#protocol-overview" title="Permalink to this headline">¶</a></h3>
<p>The implementation will demonstrate how to create, run and test CC-Link
IE Field Network Basic examples on TI platforms. The following shows the
CC-Link IE Field Network Basic Overview:</p>
<ul class="simple">
<li>1 Gbit/s Ethernet based network</li>
<li>Ethernet physical layer (Cat5e cable &amp; RJ45 connectors)</li>
<li>254 stations per network</li>
<li>100 meters between stations</li>
<li>Completely deterministic without using switches</li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="code-organization">
<h3>4.10.1.3. Code Organization<a class="headerlink" href="#code-organization" title="Permalink to this headline">¶</a></h3>
<p>The Directory structure for CC-Link IE Field Network Basic source code
and examples for both NIMU and NIMU_ICSS is shown in the following
table.</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td colspan="2"><strong>CCLink for CPSW i.e. NIMU</strong></td>
</tr>
<tr class="row-even"><td rowspan="2"><strong>Master Station Source code</strong></td>
<td rowspan="2">$(TI_PDK_INSTALL_DIR)/packages/ti/transport/ndk/nimu/example/CCLink/cclink_master</td>
</tr>
<tr class="row-odd"></tr>
<tr class="row-even"><td rowspan="2"><strong>SLave Station Source code</strong></td>
<td rowspan="2">$(TI_PDK_INSTALL_DIR)/packages/ti/transport/ndk/nimu/example/CCLink/cclink_slave</td>
</tr>
<tr class="row-odd"></tr>
<tr class="row-even"><td rowspan="2"><strong>Test Examples script</strong></td>
<td rowspan="2">$(TI_PDK_INSTALL_DIR)/packages/ti/transport/ndk/nimu/example/CCLink/&lt;SOC&gt;</td>
</tr>
<tr class="row-odd"></tr>
<tr class="row-even"><td rowspan="2"><strong>Test Examples main code</strong></td>
<td rowspan="2">$(TI_PDK_INSTALL_DIR)/packages/ti/transport/ndk/nimu/example/CCLink/src</td>
</tr>
<tr class="row-odd"></tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td colspan="2"><strong>CCLink for ICSS i.e. NIMU_ICSS</strong></td>
</tr>
<tr class="row-even"><td rowspan="2"><strong>Master Station Source code</strong></td>
<td rowspan="2">$(TI_PDK_INSTALL_DIR)/packages/ti/transport/ndk/nimu_icss/example/CCLink/cclink_master</td>
</tr>
<tr class="row-odd"></tr>
<tr class="row-even"><td rowspan="2"><strong>Slave Station Source code</strong></td>
<td rowspan="2">$(TI_PDK_INSTALL_DIR)/packages/ti/transport/ndk/nimu_icss/example/CCLink/cclink_slave</td>
</tr>
<tr class="row-odd"></tr>
<tr class="row-even"><td rowspan="2"><strong>Test Examples script</strong></td>
<td rowspan="2">$(TI_PDK_INSTALL_DIR)/packages/ti/transport/ndk/nimu_icss/example/CCLink/&lt;SOC&gt;</td>
</tr>
<tr class="row-odd"></tr>
<tr class="row-even"><td rowspan="2"><strong>Test Examples main code</strong></td>
<td rowspan="2">$(TI_PDK_INSTALL_DIR)/packages/ti/transport/ndk/nimu_icss/example/CCLink/src</td>
</tr>
<tr class="row-odd"></tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="building-the-examples">
<h3>4.10.1.4. Building the Examples<a class="headerlink" href="#building-the-examples" title="Permalink to this headline">¶</a></h3>
<p>Use pdkProjectCreate.sh for Linux environment or pdkProjectCreate.bat
for Windows.
This can be found under the &lt;PDK&gt;/packages folder. The only
modification to these scripts, if any, is to update the
CCS_INSTALL_PATH variable to point to CCS location if its not in the
c:ticcsv6 directory . Please refer to <a class="reference external" href="index_how_to_guides.html#rebuild-drivers-from-pdk-directory">Rebuilding
PDK</a> for details of example project
creation and how to run the example projects using CCS.</p>
<div class="section" id="cc-link-ie-field-network-basic-example-description">
<h4>4.10.1.4.1. CC-Link IE Field Network Basic Example Description<a class="headerlink" href="#cc-link-ie-field-network-basic-example-description" title="Permalink to this headline">¶</a></h4>
<p>For each EVM Type supported, there is a cclink example which demonstates
cyclic data communication between master and slave station. Once the
application is loaded via CCS and run, you will be able to see master
sending cyclic data packets and slave receiving the packet. For example,
the config file for NIMU for CPSW for idkAM572x, can be found in
ti/transport/ndk/nimu/example/CCLink/am572x/armv7/bios/cclink_idkAM572x.cfg.
The default IP address for master is 192.168.3.100 and for slave it is
192.168.3.4. If you wish to re-configure the IP address of the CPSW
interface you will need to modify the following configuration
parameters. make sure master and slave are in same network.</p>
<ul class="simple">
<li>Ip.address = &#8220;new ip address&#8221;</li>
<li>Ip.mask = &#8220;new ip mask&#8221;</li>
<li>Ip.gatewayIpAddr = &#8220;new gatewayIpAddr&#8221;</li>
</ul>
<p>If you do change these settings, you will be required to re-build the
Example Project using CCS.</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
<th class="head">EVM Configuration</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>NIMU_CCLinkMaster_&lt;ev
m/idk&gt;XXXX_&lt;arm/c66x/
m4&gt;Exampleproject.txt</td>
<td><div class="first last line-block">
<div class="line">Example
demonstrates CCLink
master station
sending cyclic
packet to slave.</div>
</div>
</td>
<td><div class="first line-block">
<div class="line">icev2AM335x:
Jumpers J18 and J19
need to be set
properly to select
CPSW or ICSS mode.</div>
</div>
<div class="line-block">
<div class="line">Pin2 and Pin3 need
to be connected for
ICSS mode and Pin1
and Pin2 for CPSW
mode.</div>
</div>
<p class="last">Update *.cfg file
with static IP to
test. NIMU for CPSW
test Tests requires
connection of
configured Ethernet
port under test to
external PC on same
subnet.</p>
</td>
</tr>
<tr class="row-odd"><td>NIMU_CCLinkSlave_&lt;evm
/idk&gt;XXXX_&lt;arm/c66x/m
4&gt;Exampleproject.txt</td>
<td><div class="first last line-block">
<div class="line">Example
demonstrates CCLink
slave station
receiving cyclic
packet from master
and sending a
response back.</div>
</div>
</td>
<td><div class="first line-block">
<div class="line">icev2AM335x:
Jumpers J18 and J19
need to be set
properly to select
CPSW or ICSS mode.</div>
</div>
<div class="line-block">
<div class="line">Pin2 and Pin3 need
to be connected for
ICSS mode and Pin1
and Pin2 for CPSW
mode.</div>
</div>
<p class="last">Update *.cfg file
with static IP to
test. NIMU for CPSW
test Tests requires
connection of
configured PRU-ICSS
Ethernet port under
test to external PC
on same subnet.</p>
</td>
</tr>
<tr class="row-even"><td>NIMU_ICSS_CCLinkMaste
r_&lt;evm/idk&gt;XXXX_&lt;arm/
c66x/m4&gt;Exampleprojec
t.txt</td>
<td><div class="first last line-block">
<div class="line">Example
demonstrates CCLink
master station
sending cyclic
packet to slave.</div>
</div>
</td>
<td><div class="first line-block">
<div class="line">icev2AM335x:
Jumpers J18 and J19
need to be set
properly to select
CPSW or ICSS mode.</div>
</div>
<div class="line-block">
<div class="line">Pin2 and Pin3 need
to be connected for
ICSS mode and Pin1
and Pin2 for CPSW
mode.</div>
</div>
<p class="last">Update *.cfg file
with static IP to
test. NIMU for CPSW
test Tests requires
connection of
configured Ethernet
port under test to
external PC on same
subnet.</p>
</td>
</tr>
<tr class="row-odd"><td>NIMU_ICSS_CCLinkSlave
_&lt;evm/idk&gt;XXXX_&lt;arm/c
66x/m4&gt;Exampleproject
.txt</td>
<td><div class="first last line-block">
<div class="line">Example
demonstrates CCLink
slave station
receiving cyclic
packet from master
and sending a
response back.</div>
</div>
</td>
<td><div class="first line-block">
<div class="line">icev2AM335x:
Jumpers J18 and J19
need to be set
properly to select
CPSW or ICSS mode.</div>
</div>
<div class="line-block">
<div class="line">Pin2 and Pin3 need
to be connected for
ICSS mode and Pin1
and Pin2 for CPSW
mode.</div>
</div>
<p class="last">Update *.cfg file
with static IP to
test. NIMU for CPSW
test Tests requires
connection of
configured PRU-ICSS
Ethernet port under
test to external PC
on same subnet.</p>
</td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="running-cc-link-ie-field-network-basic-example">
<h4>4.10.1.4.2. Running CC-Link IE Field Network Basic example<a class="headerlink" href="#running-cc-link-ie-field-network-basic-example" title="Permalink to this headline">¶</a></h4>
<p>The following is the test setup needed to run the example for CCLink
demonstration on TI platform. Connect the tested eth port of the evm to
a switch for master station. Do the same connection for slave station to
same switch.</p>
<img alt="../_images/Cclink_setup_pic.PNG" src="../_images/Cclink_setup_pic.PNG" />
<div class="line-block">
<div class="line"><br /></div>
<div class="line">Once the connection is done, load master and slave station code on
both evm and run them simultaneously. You would see following output
on uart port of master station.</div>
</div>
<img alt="../_images/Cclink_master_screeshot_linux.png" src="../_images/Cclink_master_screeshot_linux.png" />
<p>You would see following output on uart port of slave station.</p>
<img alt="../_images/Cclink_slave_screenshot_linux.png" src="../_images/Cclink_slave_screenshot_linux.png" />
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
</div>
<div class="section" id="ndk">
<h2>4.10.2. NDK<a class="headerlink" href="#ndk" title="Permalink to this headline">¶</a></h2>
<div class="section" id="ndk-overview">
<h3>4.10.2.1. NDK Overview<a class="headerlink" href="#ndk-overview" title="Permalink to this headline">¶</a></h3>
<p>The Network Development Kit (NDK) is a platform for development and
demonstration of network enabled RTOS applications on TI processors and
includes demonstration software showcasing capabilities across a range
of network enabled applications. The NDK serves as a rapid prototype
platform for the development of network and packet processing
applications, or to add network connectivity to existing applications
for communications, configuration, and control. Using the components
provided in the NDK, developers can quickly move from development
concepts to working implementations attached to the network.</p>
<p>The NDK provides an IPv6 and IPv4 compliant TCP/IP stack working with
the TI-RTOS Kernel real-time operating system. Its primary focus is on
providing the core Layer 3 and Layer 4 stack services along with
additional higher-level network applications such as HTTP server and
DHCP.</p>
<p>The NDK itself does not include any platform or device specific
software. The NDK interfaces through well-defined transport interface,
Network Interface Management UNIT(NIMU) to the PDK and platform
software elements needed for operation. NIMU support. NIMU provides an
interface between the stack and the device drivers through which the
stack can talk to multiple instances of a single or various device
drivers concurrently.</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td colspan="2"><strong>Network Development Kit Summary</strong></td>
</tr>
<tr class="row-even"><td><strong>Component Type</strong></td>
<td>Library</td>
</tr>
<tr class="row-odd"><td><strong>Install Package</strong></td>
<td>NDK</td>
</tr>
<tr class="row-even"><td><strong>Install Directory</strong></td>
<td>ndk_&lt;version&gt;packagestindk</td>
</tr>
<tr class="row-odd"><td><strong>Project Type</strong></td>
<td><a class="reference external" href="http://www.eclipse.org/rtsc/">Eclipse RTSC</a></td>
</tr>
<tr class="row-even"><td><strong>Endian Support</strong></td>
<td>Little</td>
</tr>
<tr class="row-odd"><td><strong>Library Name</strong></td>
<td>For details of the libraries delivered as part of the NDK component,
please refer to <a class="reference external" href="http://www-s.ti.com/sc/techlit/spru523.pdf">[1]</a></td>
</tr>
<tr class="row-even"><td><strong>Library Path</strong></td>
<td>$(NDK_INSTALL_DIR)packagestindk</td>
</tr>
<tr class="row-odd"><td><strong>Include Paths</strong></td>
<td>NDK_INSTALL_DIR is set automatically by CCS based on the version of
NDK you have checked to build with.
${NDK_INSTALL_DIR}packagestindkinc
${NDK_INSTALL_DIR}packagestindkinctools</td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="nimu-transport">
<h3>4.10.2.2. NIMU Transport<a class="headerlink" href="#nimu-transport" title="Permalink to this headline">¶</a></h3>
<p>The NDK transport component of the PDK currently provided 2
implementations for the NIMU layer as described in the sections below.
The following diagram is a high level depiction of the NDK/NIMU
architecture with reference to the NIMU implementations. For details
for the NDK/NIMU architecture, please refer to NDK Programmer&#8217;s
Reference Guide <a class="reference external" href="http://www-s.ti.com/sc/techlit/spru524.pdf">[2]</a></p>
<img alt="../_images/NDK_ARCH.png" src="../_images/NDK_ARCH.png" />
</div>
<div class="section" id="nimu-for-cpsw">
<h3>4.10.2.3. NIMU for CPSW<a class="headerlink" href="#nimu-for-cpsw" title="Permalink to this headline">¶</a></h3>
<p>NIMU for CPSW provides a common CPSW interface library for NDK to
communicate with when network stack is being implemented in the TI&#8217;s
Common Platform Ethernet Switch for ethernet packet processing. The
library uses the CSL-R based API interfaces to provide NIMU interface
for NDK. This package has NDK unit test examples for all supported EVMS
as indicated in the table above.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This module is only intended to be used with NDK. As such,
users should not tie up to its API directly.</p>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td colspan="2"><strong>NIMU for CPSW Summary</strong></td>
</tr>
<tr class="row-even"><td><strong>Component Type</strong></td>
<td>Library</td>
</tr>
<tr class="row-odd"><td><strong>Install Package</strong></td>
<td>PDK</td>
</tr>
<tr class="row-even"><td><strong>Install Directory</strong></td>
<td>$(TI_PDK_INSTALL_DIR)packagestitransportndknimu</td>
</tr>
<tr class="row-odd"><td><strong>Project Type</strong></td>
<td><a class="reference external" href="http://www.eclipse.org/rtsc/">Eclipse RTSC</a></td>
</tr>
<tr class="row-even"><td><strong>Endian Support</strong></td>
<td>Little</td>
</tr>
<tr class="row-odd"><td><strong>Library Path</strong></td>
<td>$(TI_PDK_INSTALL_DIR)packagestitransportndknimulib</td>
</tr>
<tr class="row-even"><td><strong>Reference Guides</strong></td>
<td>None</td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="nimu-for-icss">
<h3>4.10.2.4. NIMU for ICSS<a class="headerlink" href="#nimu-for-icss" title="Permalink to this headline">¶</a></h3>
<p>NIMU for ICSS (PRU-ICSS is Programmable Real-Time Unit Industrial
Communications Subsystem) provides a common PRU-ICSS interface library
for NDK to communicate with when network stack is being implemented in
the PRU-ICSS subsytem for ethernet packet processing (firmware based
switch running on PRU&#8217;s which are part of the ICSS). The library used
the ICSS_EMAC LLD to provide NIMU interface for NDK. This package has
NDK unit test examples for all supported Devices as indicated in the
table above. For details of the PRU-ICSS, please refer to
<a class="reference external" href="/index.php/Processor_SDK_RTOS_ICSS-EMAC">ICCS-EMAC</a>.</p>
<div class="line-block">
<div class="line"><strong>Note</strong>: This module is only intended to be used with NDK and
requires ICSS-EMAC low level driver. As such, users should not tie up
to its API directly.</div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td colspan="2"><strong>NIMU for ICSS Summary</strong></td>
</tr>
<tr class="row-even"><td><strong>Component Type</strong></td>
<td>Library</td>
</tr>
<tr class="row-odd"><td><strong>Install Package</strong></td>
<td>PDK</td>
</tr>
<tr class="row-even"><td><strong>Install Directory</strong></td>
<td>$(TI_PDK_INSTALL_DIR)packagestitransportndknimu_icss</td>
</tr>
<tr class="row-odd"><td><strong>Project Type</strong></td>
<td><a class="reference external" href="http://www.eclipse.org/rtsc/">Eclipse RTSC</a></td>
</tr>
<tr class="row-even"><td><strong>Endian Support</strong></td>
<td>Little</td>
</tr>
<tr class="row-odd"><td><strong>Library Path</strong></td>
<td>$(TI_PDK_INSTALL_DIR)packagestitransportndknimu_icsslib</td>
</tr>
<tr class="row-even"><td><strong>Reference Guides</strong></td>
<td>None</td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="examples">
<h3>4.10.2.5. Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h3>
<div class="section" id="ping-example">
<h4>4.10.2.5.1. PING Example<a class="headerlink" href="#ping-example" title="Permalink to this headline">¶</a></h4>
<p>All NDK examples using CPSW interface can be found at the following
location:</p>
<ul class="simple">
<li>$(TI_PDK_INSTALL_DIR)/packages/ti/transport/ndk/nimu/example</li>
</ul>
<p>All NDK examples using PRU-ICSS interface can be found at the following
location:</p>
<ul class="simple">
<li>$(TI_PDK_INSTALL_DIR)/packages/ti/transport/ndk/nimu_icss/example</li>
</ul>
<div class="section" id="building-the-ndk-examples">
<h5>4.10.2.5.1.1. Building the NDK examples<a class="headerlink" href="#building-the-ndk-examples" title="Permalink to this headline">¶</a></h5>
<div class="line-block">
<div class="line">Use pdkProjectCreate.sh for Linux environment or pdkProjectCreate.bat
for Windows.</div>
<div class="line">This can be found under the &lt;PDK&gt;/packages folder. The only
modification to these scripts, if any, is to update the
CCS_INSTALL_PATH variable to point to CCS location if its not in the
c:ticcsv6 directory . Please refer to <a class="reference external" href="index_how_to_guides.html#rebuild-drivers-from-pdk-directory">Rebuilding
PDK</a> for details of example project
creation and how to run the example projects using CCS.</div>
</div>
</div>
<div class="section" id="ndk-example-description">
<h5>4.10.2.5.1.2. NDK Example Description<a class="headerlink" href="#ndk-example-description" title="Permalink to this headline">¶</a></h5>
<p>For each EVM Type supported, there is a example which demonstates &#8220;ping&#8221;
use case. Once the application is loaded via CCS and run, you will be
able to ping the configured IP address as specificed int he examples
config file. For example, the config file for NIMU for CPSW for
idkAM572x, can be found in
ti/transport/ndk/nimu/example/am572x/armv7/bios/nimu_idk.cfg. If you
wish to re-configure the IP address of the CPSW interface you will need
to modify the following configuration parameters</p>
<ul class="simple">
<li>Ip.address = &#8220;new ip address&#8221;</li>
<li>Ip.mask = &#8220;new ip mask&#8221;</li>
<li>Ip.gatewayIpAddr = &#8220;new gatewayIpAddr&#8221;</li>
</ul>
<div class="line-block">
<div class="line">If you you do change these settings, you will be required to re-build
the Example Project using CCS.</div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
<th class="head">EVM
Configuration</th>
<th class="head">Expected
Results</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>NIMU_BasicExamp
le_evmXXXX_armE
xampleproject</td>
<td><div class="first last line-block">
<div class="line">Example
demonstrates
ping from
external
source to
Gigabit
Ethernet port
on EVM.</div>
</div>
</td>
<td><div class="first line-block">
<div class="line">icev2AM335x:
Jumpers J18
and J19 need
to be set
properly to
select CPSW
or ICSS mode.</div>
</div>
<div class="line-block">
<div class="line">Pin2 and Pin3
need to be
connected for
ICSS mode and
Pin1 and Pin2
for CPSW
mode.</div>
</div>
<p class="last">Update *.cfg
file with
static IP to
test. NIMU for
CPSW test Tests
requires
connection of
configured
Ethernet port
under test to
external PC on
same subnet.</p>
</td>
<td><div class="first line-block">
<div class="line">Run ping from
any other PC
in the same
subnet</div>
</div>
<p class="last">Ping response
from the EVM
verifies
successful
execution of
example.</p>
</td>
</tr>
<tr class="row-odd"><td>NIMU_ICSS_Basic
Example_evmXXXX
_armExampleproj
ect</td>
<td><div class="first last line-block">
<div class="line">Example
demonstrates
ping from
external
source to
PRU-ICSS
Ethernet port
on EVM.</div>
</div>
</td>
<td><div class="first line-block">
<div class="line">icev2AM335x:
Jumpers J18
and J19 need
to be set
properly to
select CPSW
or ICSS mode.</div>
</div>
<div class="line-block">
<div class="line">Pin2 and Pin3
need to be
connected for
ICSS mode and
Pin1 and Pin2
for CPSW
mode.</div>
</div>
<p class="last">Update *.cfg
file with
static IP to
test. NIMU for
CPSW test Tests
requires
connection of
configured
PRU-ICSS
Ethernet port
under test to
external PC on
same subnet.</p>
</td>
<td><p class="first">Run ping from
any other PC in
the same subnet</p>
<p class="last">Ping response
from the EVM
verifies
successful
execution of
example.</p>
</td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="running-ndk-example-on-arm-core-of-keystone-ii-devices">
<h5>4.10.2.5.1.3. Running NDK example on ARM core of Keystone II devices<a class="headerlink" href="#running-ndk-example-on-arm-core-of-keystone-ii-devices" title="Permalink to this headline">¶</a></h5>
<p>Before running the NDK example on ARM core of Keystone II
devices(K2H/L/E/G), the following steps need to be performed.</p>
<ul class="simple">
<li>Increase the NS_BootTask stack from 2048 to 4096 in netctrl.c:</li>
</ul>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">TaskCreate</span><span class="p">(</span> <span class="n">NS_BootTask</span><span class="p">,</span> <span class="s">&quot;ConfigBoot&quot;</span><span class="p">,</span> <span class="n">OS_TASKPRINORM</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,(</span><span class="n">UINT32</span><span class="p">)</span><span class="n">hCfg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li>Rebuild the NDK</li>
<li>Rebuild NIMU driver</li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
</div>
<div class="section" id="cclink-example">
<h3>4.10.2.6. CCLink Example<a class="headerlink" href="#cclink-example" title="Permalink to this headline">¶</a></h3>
<p>Refer
<a class="reference external" href="index_Foundational_Components.html#cclink">Processor_SDK_RTOS_CCLINK</a> for
details on steps for running cclink master and slave examples on NDK.</p>
</div>
<div class="section" id="faq">
<h3>4.10.2.7. FAQ<a class="headerlink" href="#faq" title="Permalink to this headline">¶</a></h3>
<div class="section" id="how-to-check-which-versions-of-nimu-driver-is-for-my-soc">
<h4>4.10.2.7.1. How to check which versions of NIMU driver is for my SOC?<a class="headerlink" href="#how-to-check-which-versions-of-nimu-driver-is-for-my-soc" title="Permalink to this headline">¶</a></h4>
<p>There are several versions of NIMU driver for different SOCs. Please
check packagestitransportndknimubuildmakefile.mk</p>
<ul class="simple">
<li>V0: C6657</li>
<li>V1: C6678</li>
<li>V2: K2H, K2K</li>
<li>V3: K2L, K2E</li>
<li>V4: AM572x, AM571x, AM437x, AM335x</li>
<li>V5: K2G</li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="is-there-any-multicast-streams-limitation-using-the-ndk">
<h4>4.10.2.7.2. Is there any multicast streams limitation using the NDK?<a class="headerlink" href="#is-there-any-multicast-streams-limitation-using-the-ndk" title="Permalink to this headline">¶</a></h4>
<p>In the NDK, the limit is defined by a macro at ti/ndk/stack/igmp/igmp.c:
#define IGMP_MAX_GROUP 32 It is then used to create an array of IGMP
records: static IGMP_REC igmp[IGMP_MAX_GROUP]; The IGMP_MAX_GROUP value
can be increased, then rebuild the NDK stack.</p>
</div>
</div>
<div class="section" id="additional-documentation-references">
<h3>4.10.2.8. Additional Documentation References<a class="headerlink" href="#additional-documentation-references" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Document</strong></td>
<td><strong>Location</strong></td>
</tr>
<tr class="row-even"><td>NDK Programmer&#8217;s Reference Guide</td>
<td><a class="reference external" href="http://www-s.ti.com/sc/techlit/spru524.pdf">http://www-s.ti.com/sc/techlit/spru524.pdf</a></td>
</tr>
<tr class="row-odd"><td>NDK User&#8217;s Guide</td>
<td><a class="reference external" href="http://www-s.ti.com/sc/techlit/spru523.pdf">http://www-s.ti.com/sc/techlit/spru523.pdf</a></td>
</tr>
<tr class="row-even"><td>Network Developers Kit FAQ</td>
<td><a class="reference external" href="http://processors.wiki.ti.com/index.php/Network_Developers_Kit_FAQ">Network Developers Kit FAQ</a></td>
</tr>
<tr class="row-odd"><td>NDK Support Package Ethernet
Driver Design Guide</td>
<td><a class="reference external" href="http://www-s.ti.com/sc/techlit/sprufp2.pdf">http://www-s.ti.com/sc/techlit/sprufp2.pdf</a></td>
</tr>
<tr class="row-even"><td>Rebuilding_the_NDK_Core
Rebuilding NDK Core</td>
<td><a class="reference external" href="http://processors.wiki.ti.com/index.php/">http://processors.wiki.ti.com/index.php/</a>
Rebuilding_the_NDK_Core</td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p class="rubric" id="id70">Introduction</p>
<div class="line-block">
<div class="line">The NWAL (Network Adaptation Layer) driver provides a well-defined set
of APIs which could be used for applications interfacing with NetCP
(Network Coprocessor) module in Keystone family of SOCs (C66x, K2x).</div>
</div>
<p class="rubric" id="driver-features">Driver Features</p>
<ul class="simple">
<li>Initialization of NetCP low level driver resources</li>
<li>Initialization of Packet DMA related resources associated with NetCP</li>
<li>Classification of incoming packets based on L2: MAC header fields</li>
<li>Classification of incoming packets based on L3: IPv4/IPv6 header
fields</li>
<li>Routing of packets to host based on L4: UDP/TCP/GTP-U</li>
<li>Unidirectional IPSec SA creation and deletion</li>
<li>In band offload of IPSec encryption/decryption for the outgoing
packets</li>
<li>Access to SA data mode acceleration for data plane applications.</li>
<li>Supports offload of the following features to NETCP Hardware during
transmission of packets:<ul>
<li>IPv4 checksum/L4:TCP/UDP checksum/IPSec Encryption</li>
<li>Redirection of packets through a specific MAC port</li>
<li>Software Insertion of L2/L3/L4 header</li>
</ul>
</li>
<li>Upon reception of packet, module provides additional meta data
details including:<ul>
<li>Status of IP checksum/UDP/TCP checksum results</li>
<li>Offset to L2/L3/L4 protocol offsets. Appropriate layer offset will
be valid only if classification or routing is enabled at NETCP</li>
<li>Ingress MAC port information</li>
</ul>
</li>
</ul>
<p class="rubric" id="id71">Modes of Operation</p>
<p>Following modes of operations are supported by NWAL when sending control
configuration request to configure NetCP firmware. <strong>BLOCKING Mode</strong>: In
this mode, status of API request used to configure NetCP is returned
back in API call context.</p>
<p><strong>Non-BLOCKING Mode</strong>: In this mode, application can invoke a separate
poll routine to retrieve status response result.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p class="rubric" id="driver-configuration-nwal">Driver Configuration</p>
<p>The driver configures the NWAL subsystem using the nwalGlobCfg_t
structure.</p>
<p>This structure must be initialized before the nwal_create() function API
is called and cannot be changed afterwards. For details regarding
individual fields of this structure, see the Doxygen help by opening
PDK_INSTALL_DIRpackagestidrvnwaldocsdoxygenhtmlindex.html.</p>
<p class="rubric" id="id72"><strong>APIs</strong></p>
<p>API reference for application can be found in below file:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &lt;ti/drv/nwal/nwal.h&gt;</span>
</pre></div>
</div>
<p class="rubric" id="id73">Example</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
<th class="head">Expected Results</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>nwalUnitTest
Application</td>
<td><div class="first last line-block">
<div class="line">Unit Test
application to test
all APIs</div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">User observes the
output printed over
the CCS console</div>
</div>
</td>
</tr>
</tbody>
</table>
<p class="rubric" id="id74">Additional References</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Document</strong></td>
<td><strong>Location</strong></td>
</tr>
<tr class="row-even"><td>API Reference Manual</td>
<td>$(TI_PDK_INSTALL_DIR)packagesti
drvnwaldocsdoxygenhtmlindex
.html</td>
</tr>
<tr class="row-odd"><td>Release Notes</td>
<td>$(TI_PDK_INSTALL_DIR)packagesti
drvnwaldocsReleaseNotes_NWAL_
LLD.pdf</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="section" id="transport">
<h1>4.11. Transport<a class="headerlink" href="#transport" title="Permalink to this headline">¶</a></h1>
<div class="section" id="timesync-ptp">
<h2>4.11.1. TimeSync (PTP)<a class="headerlink" href="#timesync-ptp" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id75">
<h3>4.11.1.1. Overview<a class="headerlink" href="#id75" title="Permalink to this headline">¶</a></h3>
<div class="section" id="terms-and-abbreviations">
<h4>4.11.1.1.1. Terms and Abbreviations<a class="headerlink" href="#terms-and-abbreviations" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="48%" />
<col width="52%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Acronym</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>PTP</td>
<td>Precision Time Protocol</td>
</tr>
<tr class="row-odd"><td>P2P</td>
<td>Peer to Peer</td>
</tr>
<tr class="row-even"><td>E2E</td>
<td>End to End</td>
</tr>
<tr class="row-odd"><td>TC</td>
<td>Transparent Clock</td>
</tr>
<tr class="row-even"><td>OC</td>
<td>Ordinary Clock</td>
</tr>
<tr class="row-odd"><td>BC</td>
<td>Boundary Clock</td>
</tr>
<tr class="row-even"><td>Master</td>
<td>PTP master</td>
</tr>
<tr class="row-odd"><td>Slave</td>
<td>PTP Slave</td>
</tr>
<tr class="row-even"><td>BMCA</td>
<td>Best Master Clock Algorithm</td>
</tr>
<tr class="row-odd"><td>RCF</td>
<td>Synchronization/(Frequency
Compensation) Factor</td>
</tr>
<tr class="row-even"><td>IEC 61558</td>
<td>PTP profile for network control
systems</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id76">
<h4>4.11.1.1.2. Introduction<a class="headerlink" href="#id76" title="Permalink to this headline">¶</a></h4>
<p>This document details the user guide aspects of PTP/1588 v2 master/slave implementation on PRU-ICSS.</p>
<p>Dual EMAC firmware implementation supports P2P and the implementation is unique to Emac.
The master capability added to the TimeSync driver is currently limitted to sending Sync and
Announce frames. The BMCA/Management part of PTP master is not implemented.</p>
<p>TimeSync (PTP) driver does the task of</p>
<ol class="arabic simple">
<li>Running BMCA</li>
<li>Calculating RCF and Sync packet interval.</li>
<li>Performing clock synchronization</li>
<li>Calculating peer and line delay</li>
<li>Sending Delay Request and Delay Response frames (includes Pdelay Req and Pdelay Res)</li>
</ol>
<p class="rubric" id="driver-configuration-timesync">Driver Configuration</p>
<p class="rubric" id="board-specific-configuration"><strong>Board Specific Configuration</strong></p>
<p>All board specific configurations like enabling clock and pin-mux are
required before calling any driver APIs. By default Board_Init() API
available under board module supports all initialization sequence for TI
supported EVMs. In addition it initializes UART instance for
Console/STDIO. Refer <a class="reference external" href="index_board.html#board-support">Processor SDK RTOS Board
Support</a> for additional
details.</p>
<p class="rubric" id="timesync-configuration-structure"><strong>TimeSync Configuration Structure</strong></p>
<p>The TimeSync driver needs to be initialized/configured with initial parameters during the driver initialization.</p>
<p>icss_timeSync_init.c binds driver with TimeSync parameters.</p>
<p>TimeSync_drvInit() API triggers all static configuration information available through parameters. Once initialization is complete the driver is ready for use.</p>
<p>Please refer to TimeSync_ParamsHandle structure defined under &#8216;&lt;pdk&gt;/packages/ti/transport/timeSync/include/icss_timeSyncApi.h&#8217;</p>
</div>
<div class="section" id="id77">
<h4>4.11.1.1.3. APIs<a class="headerlink" href="#id77" title="Permalink to this headline">¶</a></h4>
<p>API reference for Application:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &lt;ti/transport/timeSync/icss_timeSync.h&gt;</span>
</pre></div>
</div>
<p>Below sequence indicates API calling sequence for a simple use case of
timeSync master operation</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="p">...</span>
<span class="n">Board_init</span><span class="p">(</span><span class="n">boardCfg</span><span class="p">);</span>
<span class="n">timeSync_example_configureInterrupts</span><span class="p">(</span><span class="n">EMAC_PORT_NUM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">emacCfg</span><span class="p">);</span>
<span class="n">ICSS_EmacSocSetInitCfg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">emacBaseAddr</span><span class="p">);</span>
<span class="n">ICSS_EmacInit</span><span class="p">();</span>
<span class="cm">/* Assumption: firmware is downloaded and ICSS_EMAC driver is initialized */</span>
<span class="n">TimeSync_drvInit</span><span class="p">(</span><span class="n">timeSyncHandle</span><span class="p">);</span>
<span class="n">TimeSync_drvEnable</span><span class="p">(</span><span class="n">timeSyncHandle</span><span class="p">);</span>
<span class="n">TimeSync_enableMaster</span><span class="p">();</span>
<span class="n">While</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Delay</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Below sequence indicates API calling sequence for a simple use case of
timeSync slave operation</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="p">...</span>
<span class="n">Board_init</span><span class="p">(</span><span class="n">boardCfg</span><span class="p">);</span>
<span class="n">timeSync_example_configureInterrupts</span><span class="p">(</span><span class="n">EMAC_PORT_NUM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">emacCfg</span><span class="p">);</span>
<span class="n">ICSS_EmacSocSetInitCfg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">emacBaseAddr</span><span class="p">);</span>
<span class="n">ICSS_EmacInit</span><span class="p">();</span>
<span class="cm">/* Assumption: firmware is downloaded and ICSS_EMAC driver is initialized */</span>
<span class="n">TimeSync_drvInit</span><span class="p">(</span><span class="n">timeSyncHandle</span><span class="p">);</span>
<span class="n">TimeSync_drvEnable</span><span class="p">(</span><span class="n">timeSyncHandle</span><span class="p">);</span>
<span class="n">TimeSync_disableMaster</span><span class="p">();</span>
<span class="n">While</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Delay</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>NOTE</strong>
:</p>
<ol class="arabic simple">
<li>The TimeSync Tx callback interrupt is mapped to the ISR TimeSync_txTSIsr(), where the two PRU interrupts configured to ARM interrupt txIntNum are PRU_ARM_EVENT_6 and PRU_ARM_EVENT_7.</li>
<li>The PTP frames are received via the Real Time (RT) call back from ICSS_EMAC driver and hence RT call back needs to be implemented at the application for ICSS-EMAC driver.</li>
</ol>
</div>
<div class="section" id="tasks-internally-created-from-timesync-drvinit">
<h4>4.11.1.1.4. Tasks Internally created from TimeSync_drvInit()<a class="headerlink" href="#tasks-internally-created-from-timesync-drvinit" title="Permalink to this headline">¶</a></h4>
<p>Below tasks would be created after Application calls TimeSync_drvInit() function. The sample osal implementation is provided under &lt;pdk&gt;/packages/ti/transport/timeSync/example/src/common/timeSync_example_osal.c implementing these tasks.</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="26%" />
<col width="18%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Handle Name</th>
<th class="head"><div class="first last line-block">
<div class="line">Function Name</div>
</div>
</th>
<th class="head" colspan="2"><div class="first last line-block">
<div class="line">What it does</div>
</div>
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>timeSync_pDelayReqSendTask</td>
<td>TimeSync_PdelayReqSendTask()</td>
<td colspan="2"><div class="first last line-block">
<div class="line">Send Peer Delay Requests periodically on both ports.
Delay is configurable. Only applicable for P2P configuration</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>timeSync_delayReqSendTask</td>
<td>TimeSync_delayReqSendTask()</td>
<td colspan="2"><div class="first last line-block">
<div class="line">Send Delay requests to PTP Master. This is currently done for
every Sync frame. Pends indefinitely on a semaphore.</div>
</div>
</td>
</tr>
<tr class="row-even"><td rowspan="2">timeSync_TxTSTaskP1</td>
<td rowspan="2">TimeSync_TxTSTask_P1()</td>
<td colspan="2" rowspan="2"><div class="first last line-block">
<div class="line">Process Tx timestamp for Port 1. Pends on an event posted by
Tx ISR indefinitely.</div>
</div>
</td>
</tr>
<tr class="row-odd"></tr>
<tr class="row-even"><td rowspan="2">timeSync_TxTSTaskP2</td>
<td rowspan="2">TimeSync_TxTSTask_P2()</td>
<td colspan="2" rowspan="2"><div class="first last line-block">
<div class="line">Process Tx timestamp for Port 2. Pends on an event posted by
Tx ISR indefinitely.</div>
</div>
</td>
</tr>
<tr class="row-odd"></tr>
<tr class="row-even"><td rowspan="2">timeSync_syncTxTask</td>
<td rowspan="2">TimeSync_SyncTxTask()</td>
<td colspan="2" rowspan="2"><div class="first last line-block">
<div class="line">Sends Sync frames on both ports in Master mode.
Pends indefinitely on a semaphore posted by the DM Timer ISR</div>
</div>
</td>
</tr>
<tr class="row-odd"></tr>
<tr class="row-even"><td>timeSync_announceTxTask</td>
<td>TimeSync_AnnounceTxTask()</td>
<td colspan="2"><div class="first last line-block">
<div class="line">Sends Announce frames on both ports periodically</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>timeSync_NRT_Task</td>
<td>TimeSync_NRT_Task()</td>
<td colspan="2"><div class="first last line-block">
<div class="line">NRT stands for non real time. Processes Peer delay frames in
the background and calculate peer delay.</div>
</div>
</td>
</tr>
<tr class="row-even"><td>timeSync_backgroundTask</td>
<td>TimeSync_BackgroundTask()</td>
<td colspan="2"><div class="first last line-block">
<div class="line">Checks for Sync timeout and performs offset stabilization.</div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="building-timesync-examples-unit-test">
<h4>4.11.1.1.5. Building timeSync Examples/Unit Test<a class="headerlink" href="#building-timesync-examples-unit-test" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Setup the build environment <a class="reference external" href="http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/index_overview.html#setup-environment">SetupBuildEnvironment</a></li>
<li>Follow the steps as mentioned under <a class="reference external" href="http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/index_overview.html#pdk-example-and-test-project-creation">SDK example and test CCS Project Creation</a>  for creating the CCS based example and test projects creation</li>
</ul>
</div>
<div class="section" id="sample-examples">
<h4>4.11.1.1.6. Sample Examples<a class="headerlink" href="#sample-examples" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="32%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
<th class="head"><div class="first last line-block">
<div class="line">Expected Results</div>
</div>
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>timeSync_BasicExample</td>
<td>Simple timeSync
example demonstrating
sync between Master
and Slave</td>
<td><div class="first last line-block">
<div class="line">Clock Sync
results at Slave</div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id78">
<h3>4.11.1.2. Additional References<a class="headerlink" href="#id78" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Document</strong></td>
<td><strong>Location</strong></td>
</tr>
<tr class="row-even"><td>API Reference Manual</td>
<td>$(TI_PDK_INSTALL_DIR)/packages/ti
/transport/timeSync/docs/doxygen/html/index
.html</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="section" id="tools">
<h1>4.12. Tools<a class="headerlink" href="#tools" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference external" href="http://processors.wiki.ti.com/index.php/Processor_SDK_RTOS_Tools">Processor SDK RTOS Tools</a></li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><img alt="../_images/E2e.jpg" class="first last" src="../_images/E2e.jpg" />
</td>
<td>For technical support please post your questions at <a class="reference external" href="http://e2e.ti.com/">http://e2e.ti.com</a>.</td>
</tr>
</tbody>
</table>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="DSP_Software.html" class="btn btn-neutral float-right" title="5. DSP Software" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Foundational_Components.html" class="btn btn-neutral" title="4. Foundational Components" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
      <a href="http://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyight 1995-2018</a>, Texas Instruments Incorporated. All rights reserved. <br>
      <a href="http://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="http://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="http://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="http://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'05_03_00',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    <script src="http://www.ti.com/assets/js/headerfooter/analytics.js" type="text/javascript" charset="utf-8"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
        });

      var menuHeight = window.innerHeight;

      var contentOffset = $(".wy-nav-content-wrap").offset();
      var contentHeight = $(".wy-nav-content-wrap").height();
      var contentBottom = contentOffset.top + contentHeight;

      function setNavbarTop() {
          var scrollTop = $(window).scrollTop();
          var maxTop = scrollTop + menuHeight;

          // If past the header
          if (scrollTop > contentOffset.top && maxTop < contentBottom) {
            stickyTop = scrollTop - contentOffset.top;
          } else if (maxTop > contentBottom) {
            stickyTop = scrollTop - contentOffset.top - (maxTop - contentBottom);
          } else {
            stickyTop = 0;
          }

          $(".wy-nav-side").css("top", stickyTop);
      }

      $(document).ready(function() {
        setNavbarTop();
        $(window).scroll(function () {
          setNavbarTop();
        });

        $('body').on("mousewheel", function () {
            // Remove default behavior
            event.preventDefault();
            // Scroll without smoothing
            var wheelDelta = event.wheelDelta;
            var currentScrollPosition = window.pageYOffset;
            window.scrollTo(0, currentScrollPosition - wheelDelta);
        });
      });
  </script>
   

</body>
</html>