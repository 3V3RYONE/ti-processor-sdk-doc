

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>4.1. TI-RTOS Kernel &mdash; Processor SDK RTOS Documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="Processor SDK RTOS Documentation" href="../index.html"/>
        <link rel="up" title="4. Foundational Components" href="Foundational_Components.html"/>
        <link rel="next" title="5. DSP Software" href="DSP_Software.html"/>
        <link rel="prev" title="4. Foundational Components" href="Foundational_Components.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">
  <header id="tiHeader">
    <div class="top">
      <ul>
        <li id="top_logo">
          <a href="http://www.ti.com">
            <img src="../_static/img/ti_logo.png"/>
          </a>
        </li>
      </ul>
    </div>
    <div class="nav"></div>
  </header>
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Processor SDK RTOS
          

          
          </a>

          
            
            
              <div class="version">
                06_01_00
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Overview.html">1. Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="Release_Specific.html">2. Release Specific</a></li>
<li class="toctree-l1"><a class="reference internal" href="Board_EVM_Abstration.html">3. Board/EVM Abstration</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Foundational_Components.html">4. Foundational Components</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">4.1. TI-RTOS Kernel</a></li>
<li class="toctree-l2"><a class="reference internal" href="#xdais">4.2. XDAIS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fc">4.3. FC</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ipc">4.4. IPC</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ipc-user-s-guide">4.4.1. IPC User’s Guide</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#other-ti-ipc-related-links-for-host-running-linux">4.4.1.1. Other TI IPC related links for Host Running Linux</a></li>
<li class="toctree-l4"><a class="reference internal" href="#other-ti-ipc-useful-links">4.4.1.2. Other TI IPC useful links</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ipc-install-guides">4.4.1.3. IPC Install Guides</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id1">4.4.2. IPC Install Guides</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#bios-install-guide">4.4.2.1. BIOS Install Guide</a></li>
<li class="toctree-l4"><a class="reference internal" href="#linux-install-guide">4.4.2.2. Linux Install Guide</a></li>
<li class="toctree-l4"><a class="reference internal" href="#qnx-install-guide">4.4.2.3. QNX Install Guide</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#porting-ipc">4.4.3. Porting IPC</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#interfaces-to-implement">4.4.3.1. Interfaces to Implement</a></li>
<li class="toctree-l4"><a class="reference internal" href="#other-porting-tasks">4.4.3.2. Other Porting Tasks</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#optimizing-ipc-applications">4.4.4. Optimizing IPC Applications</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#compiler-and-linker-optimization">4.4.4.1. Compiler and Linker Optimization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#optimizing-runtime-performance">4.4.4.2. Optimizing Runtime Performance</a></li>
<li class="toctree-l4"><a class="reference internal" href="#optimizing-notify-and-messageq-latency">4.4.4.3. Optimizing Notify and MessageQ Latency</a></li>
<li class="toctree-l4"><a class="reference internal" href="#choosing-and-configuring-notify-drivers">4.4.4.4. Choosing and Configuring Notify Drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#choosing-and-configuring-messageq-transports">4.4.4.5. Choosing and Configuring MessageQ Transports</a></li>
<li class="toctree-l4"><a class="reference internal" href="#optimizing-shared-memory-usage">4.4.4.6. Optimizing Shared Memory Usage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#optimizing-local-memory-usage">4.4.4.7. Optimizing Local Memory Usage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#optimizing-code-size">4.4.4.8. Optimizing Code Size</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#rebuilding-ipc">4.4.5. Rebuilding IPC</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#build-procedure">4.4.5.1. Build Procedure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pointing-a-ccs-project-at-a-rebuilt-ipc">4.4.5.2. Pointing a CCS Project at a Rebuilt IPC</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ti-sdo-ipc-package">4.4.6. TI SDO IPC Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id18">4.4.6.1. Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ipc-module">4.4.6.2. IPC Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#messageq-module">4.4.6.3. MessageQ Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#listmp-module">4.4.6.4. ListMP Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#heapmp-module">4.4.6.5. HeapMP Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gatemp-module">4.4.6.6. GateMP Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gatemp-support-for-uio-and-misc-driver">4.4.6.7. GateMP Support for UIO and Misc Driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#notify-module">4.4.6.8. Notify Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#shared-region-module">4.4.6.9. Shared Region Module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ti-sdo-utils-package">4.4.7. TI SDO Utils Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#list-module">4.4.7.1. List Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multiproc-module">4.4.7.2. MultiProc Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nameserver-module">4.4.7.3. NameServer Module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#use-cases-for-ipc">4.4.8. Use Cases for IPC</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#minimal-use-scenario-bios-to-bios-only">4.4.8.1. Minimal Use Scenario (BIOS-to-BIOS only)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#data-passing-scenario-bios-to-bios-only">4.4.8.2. Data Passing Scenario (BIOS-to-BIOS only)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dynamic-allocation-scenario-bios-to-bios-only">4.4.8.3. Dynamic Allocation Scenario (BIOS-to-BIOS only)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#powerful-but-easy-to-use-messaging-with-messageq-hlos-and-bios">4.4.8.4. Powerful But Easy-to-Use Messaging with MessageQ (HLOS and BIOS)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ipc-examples">4.4.9. IPC Examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">4.4.9.1. Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#generating-examples">4.4.9.2. Generating Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tools">4.4.9.3. Tools</a></li>
<li class="toctree-l4"><a class="reference internal" href="#source-code">4.4.9.4. Source Code</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id31">4.4.9.5. Build</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ipc-examples-details">4.4.9.6. IPC examples: Details</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ipc-tests">4.4.10. IPC Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id42">4.4.10.1. Overview</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ipc-daemon">4.4.11. IPC Daemon</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ipc-daemon-aka-lad">4.4.11.1. IPC Daemon (aka LAD)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ipc-transports">4.4.12. IPC Transports</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id51">4.4.12.1. Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#modes-of-operation">4.4.12.2. Modes of Operation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id52">4.4.12.3. Transport Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#source-delivery-and-recompilation">4.4.12.4. Source Delivery and Recompilation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tests-examples">4.4.12.5. Tests &amp; Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="#additional-references">4.4.12.6. Additional References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ipc-benchmarking">4.4.13. IPC Benchmarking</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#messageqbench">4.4.13.1. MessageQBench</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ipc-performance">4.4.13.2. IPC Performance</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ipc-3-x">4.4.14. IPC 3.x</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id73">4.4.14.1. Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#changes">4.4.14.2. Changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#development">4.4.14.3. Development</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ipc-training">4.4.14.4. IPC Training</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id76">4.4.14.5. See Also</a></li>
<li class="toctree-l4"><a class="reference internal" href="#resource-custom-table">4.4.14.6. Resource Custom Table</a></li>
<li class="toctree-l4"><a class="reference internal" href="#resource-usage">4.4.14.7. Resource Usage</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ipc-faq">4.4.15. IPC FAQ</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#i-have-a-question-that-s-not-answered-here-what-now">4.4.15.1. I have a question that’s not answered here, what now?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#does-ipc-3-x-support-smp-bios">4.4.15.2. Does IPC 3.x support SMP BIOS?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#build-questions">4.4.15.3. Build Questions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#when-should-ipc-start-be-called">4.4.15.4. When should Ipc_start() be called?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#linux-ipc-start-failures">4.4.15.5. Linux Ipc_start() Failures</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hlos-loading-failures">4.4.15.6. HLOS loading failures</a></li>
<li class="toctree-l4"><a class="reference internal" href="#disabling-runtime-auto-suspend">4.4.15.7. Disabling runtime auto-suspend</a></li>
<li class="toctree-l4"><a class="reference internal" href="#faq-for-keystone-devices">4.4.15.8. FAQ For Keystone Devices</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#opencl">4.5. OpenCL</a></li>
<li class="toctree-l2"><a class="reference internal" href="#boot">4.6. Boot</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#fc-boot-label">4.6.1. Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#boot-modes">4.6.2. Boot Modes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#mmcsd">4.6.2.1. MMCSD</a></li>
<li class="toctree-l4"><a class="reference internal" href="#qspi">4.6.2.2. QSPI</a></li>
<li class="toctree-l4"><a class="reference internal" href="#uart">4.6.2.3. UART</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mcspi-spi">4.6.2.4. MCSPI/SPI</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nand">4.6.2.5. NAND</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#platforms">4.6.3. Platforms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#am335x-am437x">4.6.3.1. AM335x/AM437x</a></li>
<li class="toctree-l4"><a class="reference internal" href="#am57x">4.6.3.2. AM57x</a></li>
<li class="toctree-l4"><a class="reference internal" href="#am65x-j721e">4.6.3.3. AM65x/J721E</a></li>
<li class="toctree-l4"><a class="reference internal" href="#c66x">4.6.3.4. C66x</a></li>
<li class="toctree-l4"><a class="reference internal" href="#k2g">4.6.3.5. K2G</a></li>
<li class="toctree-l4"><a class="reference internal" href="#k2h-k2e-k2l">4.6.3.6. K2H/K2E/K2L</a></li>
<li class="toctree-l4"><a class="reference internal" href="#omapl137-omapl138-c6748">4.6.3.7. OMAPL137/OMAPL138/C6748</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#bootloader-debugging">4.6.4. Bootloader Debugging</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#common-steps-to-debug-application-boot">4.6.4.1. Common Steps to debug application boot</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#uart-apploader">4.6.5. UART AppLoader</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id149">4.6.5.1. Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#supported-platforms">4.6.5.2. Supported Platforms</a></li>
<li class="toctree-l4"><a class="reference internal" href="#apploader-load-address">4.6.5.3. Apploader Load Address</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pre-requisites">4.6.5.4. Pre-Requisites</a></li>
<li class="toctree-l4"><a class="reference internal" href="#apploader-usage">4.6.5.5. AppLoader Usage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rebuilding-apploader">4.6.5.6. Rebuilding AppLoader</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#mpm">4.7. MPM</a></li>
<li class="toctree-l2"><a class="reference internal" href="#openmp">4.8. OpenMP</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pktlib">4.9. PKTLIB</a></li>
<li class="toctree-l2"><a class="reference internal" href="#network">4.10. Network</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cclink">4.10.1. CCLink</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id159">4.10.1.1. Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#protocol-overview">4.10.1.2. Protocol Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#code-organization">4.10.1.3. Code Organization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#building-the-examples">4.10.1.4. Building the Examples</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ndk">4.10.2. NDK</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ndk-overview">4.10.2.1. NDK Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nimu-transport">4.10.2.2. NIMU Transport</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nimu-for-cpsw">4.10.2.3. NIMU for CPSW</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nimu-for-icss">4.10.2.4. NIMU for ICSS</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id160">4.10.2.5. Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cclink-example">4.10.2.6. CCLink Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="#faq">4.10.2.7. FAQ</a></li>
<li class="toctree-l4"><a class="reference internal" href="#additional-documentation-references">4.10.2.8. Additional Documentation References</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#transport">4.11. Transport</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#timesync-ptp">4.11.1. TimeSync (PTP)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id166">4.11.1.1. Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id169">4.11.1.2. Additional References</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id170">4.12. Tools</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="DSP_Software.html">5. DSP Software</a></li>
<li class="toctree-l1"><a class="reference internal" href="Device_Drivers.html">6. Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="PRU_ICSS.html">7. PRU-ICSS Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="Compilers.html">8. Compilers</a></li>
<li class="toctree-l1"><a class="reference internal" href="Examples_and_Demonstrations.html">9. Examples and Demonstrations</a></li>
<li class="toctree-l1"><a class="reference internal" href="How_to_Guides.html">10. How to Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="FAQ.html">11. Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="Documentation_Tarball.html">12. Documentation Tarball</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Processor SDK RTOS</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
          <li><a href="Foundational_Components.html">4. Foundational Components</a> &raquo;</li>
      
    <li>4.1. TI-RTOS Kernel</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="ti-rtos-kernel">
<h1>4.1. TI-RTOS Kernel<a class="headerlink" href="#ti-rtos-kernel" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p><a class="reference external" href="http://processors.wiki.ti.com/index.php?title=Category:SYSBIOS">SYSBIOS</a></p></li>
</ul>
</div>
<div class="section" id="xdais">
<h1>4.2. XDAIS<a class="headerlink" href="#xdais" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p><a class="reference external" href="http://processors.wiki.ti.com/index.php?title=Category:XDAIS">XDAIS</a></p></li>
</ul>
</div>
<div class="section" id="fc">
<h1>4.3. FC<a class="headerlink" href="#fc" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p><a class="reference external" href="http://processors.wiki.ti.com/index.php?title=Category:Framework_Components">Framework Components</a></p></li>
</ul>
</div>
<div class="section" id="ipc">
<h1>4.4. IPC<a class="headerlink" href="#ipc" title="Permalink to this headline">¶</a></h1>
<p>Inter-Processor Communication (IPC) provides a processor-agnostic API which can be used for communication between processors in a multi-processor environment (inter-core), communication to other threads on same processor (inter-process), and communication to peripherals (inter-device).
The API supports message passing, streams, and linked lists.
IPC can be used to communicate with the following:</p>
<ul class="simple">
<li><p>Other threads on the same processor</p></li>
<li><p>Threads on other processors running SYS/BIOS</p></li>
<li><p>Threads on other processors running an HLOS (e.g., Linux, QNX, Android)</p></li>
</ul>
<img alt="../_images/IPC_comm_features.JPG" src="../_images/IPC_comm_features.JPG" />
<div class="section" id="ipc-user-s-guide">
<h2>4.4.1. IPC User’s Guide<a class="headerlink" href="#ipc-user-s-guide" title="Permalink to this headline">¶</a></h2>
<p>This user’s guide is the new home of the <em>Inter-Processor
Communication (IPC) User’s Guide</em>
(<a class="reference external" href="http://www.ti.com/lit/pdf/sprugo6">SPRUGO6</a>). That PDF-based
document will no longer be updated.</p>
<p>This user’s guide contains the topics in the following list. It also
links to API reference documentation for static configuration (<a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html"><img alt="ipcCfg_Img" src="../_images/Book_cfg.png" /></a>)
and run-time C processing (<a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/index.html"><img alt="ipcRun_Img" src="../_images/Book_run.png" /></a>) for each module.</p>
<ul class="simple">
<li><p><a class="reference external" href="index_Foundational_Components.html#use-cases-for-ipc">Use Cases for IPC</a></p></li>
<li><p><a class="reference external" href="index_Foundational_Components.html#ti-sdo-ipc-package">The ti.sdo.ipc
Package</a>
describes the modules in the ti.sdo.ipc package.</p></li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 35%" />
<col style="width: 23%" />
<col style="width: 21%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Module</p></th>
<th class="head"><p>doc</p></th>
<th class="head"><p>Config API</p></th>
<th class="head"><p>C API</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Ipc Module</strong></p></td>
<td><p><a class="reference external" href="index_Foundational_Components.html#ipc-module"><img alt="ipcWiki_Img1" src="../_images/Book_wiki.png" /></a></p></td>
<td><p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html"><img alt="ipcCfg_Img1" src="../_images/Book_cfg.png" /></a></p></td>
<td><p><a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_ipc_8h.html"><img alt="ipcRun_Img1" src="../_images/Book_run.png" /></a></p></td>
</tr>
<tr class="row-odd"><td><p><strong>MessageQ Module</strong></p></td>
<td><p><a class="reference external" href="index_Foundational_Components.html#messageq-module"><img alt="ipcWiki_Img2" src="../_images/Book_wiki.png" /></a></p></td>
<td><p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html"><img alt="ipcCfg_Img2" src="../_images/Book_cfg.png" /></a></p></td>
<td><p><a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_message_q_8h.html"><img alt="ipcRun_Img2" src="../_images/Book_run.png" /></a></p></td>
</tr>
<tr class="row-even"><td><p><strong>ListMP Module</strong>
(BIOS only)</p></td>
<td><p><a class="reference external" href="index_Foundational_Components.html#listmp-module"><img alt="ipcWiki_Img3" src="../_images/Book_wiki.png" /></a></p></td>
<td><p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html"><img alt="ipcCfg_Img3" src="../_images/Book_cfg.png" /></a></p></td>
<td><p><a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_list_m_p_8h.html"><img alt="ipcRun_Img3" src="../_images/Book_run.png" /></a></p></td>
</tr>
<tr class="row-odd"><td><p><strong>HeapMP Modules</strong>
(BIOS only)</p></td>
<td><p><a class="reference external" href="index_Foundational_Components.html#heapmp-module"><img alt="ipcWiki_Img4" src="../_images/Book_wiki.png" /></a></p></td>
<td><p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html"><img alt="ipcCfg_Img4" src="../_images/Book_cfg.png" /></a></p></td>
<td><p><a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_heap_buf_m_p_8h.html"><img alt="ipcRun_Img4a" src="../_images/Book_run.png" /></a>
<a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_heap_mem_m_p_8h.html"><img alt="ipcRun_Img4b" src="../_images/Book_run.png" /></a>
<a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_heap_multi_buf_m_p_8h.html"><img alt="ipcRun_Img4c" src="../_images/Book_run.png" /></a></p></td>
</tr>
<tr class="row-even"><td><p><strong>GateMP Module</strong></p></td>
<td><p><a class="reference external" href="index_Foundational_Components.html#gatemp-module"><img alt="ipcWiki_Img5" src="../_images/Book_wiki.png" /></a></p></td>
<td><p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html"><img alt="ipcCfg_Img5" src="../_images/Book_cfg.png" /></a></p></td>
<td><p><a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_gate_m_p_8h.html"><img alt="ipcRun_Img5" src="../_images/Book_run.png" /></a></p></td>
</tr>
<tr class="row-odd"><td><p><strong>Notify Module</strong>
(BIOS only)</p></td>
<td><p><a class="reference external" href="index_Foundational_Components.html#notify-module"><img alt="ipcWiki_Img6" src="../_images/Book_wiki.png" /></a></p></td>
<td><p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html"><img alt="ipcCfg_Img6" src="../_images/Book_cfg.png" /></a></p></td>
<td><p><a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_notify_8h.html"><img alt="ipcRun_Img6" src="../_images/Book_run.png" /></a></p></td>
</tr>
<tr class="row-even"><td><p><strong>SharedRegion Module</strong>
(BIOS only)</p></td>
<td><p><a class="reference external" href="index_Foundational_Components.html#shared-region-module"><img alt="ipcWiki_Img7" src="../_images/Book_wiki.png" /></a></p></td>
<td><p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html"><img alt="ipcCfg_Img7" src="../_images/Book_cfg.png" /></a></p></td>
<td><p><a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_shared_region_8h.html"><img alt="ipcRun_Img7" src="../_images/Book_run.png" /></a></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<ul class="simple">
<li><p><a class="reference external" href="index_Foundational_Components.html#ti-sdo-utils-package">The ti.sdo.utils
Package</a>
describes the modules in the ti.sdo.utils package.</p></li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 35%" />
<col style="width: 23%" />
<col style="width: 21%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Module</p></th>
<th class="head"><p>doc</p></th>
<th class="head"><p>Config API</p></th>
<th class="head"><p>C API</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>List Module</strong>
(BIOS only)</p></td>
<td><p><a class="reference external" href="index_Foundational_Components.html#list-module"><img alt="ipcWiki_Img8" src="../_images/Book_wiki.png" /></a></p></td>
<td><p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html"><img alt="ipcCfg_Img8" src="../_images/Book_cfg.png" /></a></p></td>
<td><p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/syslink/latest/docs/html/_list_8h.html"><img alt="ipcRun_Img8" src="../_images/Book_run.png" /></a></p></td>
</tr>
<tr class="row-odd"><td><p><strong>MultiProc Module</strong></p></td>
<td><p><a class="reference external" href="index_Foundational_Components.html#multiproc-module"><img alt="ipcWiki_Img9" src="../_images/Book_wiki.png" /></a></p></td>
<td><p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html"><img alt="ipcCfg_Img9" src="../_images/Book_cfg.png" /></a></p></td>
<td><p><a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_multi_proc_8h.html"><img alt="ipcRun_Img9" src="../_images/Book_run.png" /></a></p></td>
</tr>
<tr class="row-even"><td><p><strong>NameServer Module</strong></p></td>
<td><p><a class="reference external" href="index_Foundational_Components.html#nameserver-module"><img alt="ipcWiki_Img10" src="../_images/Book_wiki.png" /></a></p></td>
<td><p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html"><img alt="ipcCfg_Img10" src="../_images/Book_cfg.png" /></a></p></td>
<td><p><a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_shared_region_8h.html"><img alt="ipcRun_Img10" src="../_images/Book_run.png" /></a></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<div class="line-block">
<div class="line"><br /></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="index_Foundational_Components.html#porting-ipc">Porting IPC</a> provides
an overview of the steps required to port IPC to new devices or
systems.</p></li>
<li><p><a class="reference external" href="index_Foundational_Components.html#optimizing-ipc-applications">Optimizing IPC
Applications</a>
provides hints for improving the runtime performance and shared
memory usage of applications that use IPC.</p></li>
<li><p><a class="reference external" href="index_Foundational_Components.html#rebuilding-ipc">Rebuilding IPC</a>
explains how to rebuild the IPC libraries if you modify the source
files.</p></li>
<li><p><a class="reference external" href="index_Foundational_Components.html#ipc-examples">Examples</a> explains how
to build and generate the IPC examples.</p></li>
<li><p><a class="reference external" href="index_Foundational_Components.html#ipc-tests">Tests</a> explains details of
unit tests part of IPC</p></li>
<li><p><a class="reference external" href="index_Foundational_Components.html#ipc-transports">RTOS IPC
Transports</a>
explains details of the additional RTOS IPC transports provided via
the Processor SDK PDK component.</p></li>
</ul>
<div class="section" id="other-ti-ipc-related-links-for-host-running-linux">
<h3>4.4.1.1. Other TI IPC related links for Host Running Linux<a class="headerlink" href="#other-ti-ipc-related-links-for-host-running-linux" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="index_Foundational_Components.html#resource-custom-table">IPC Custom
ResourceTable</a>
Provides details of customizing the resource table.</p></li>
<li><p><a class="reference external" href="index_Foundational_Components.html#gatemp-support-for-uio-and-misc-driver">IPC GateMP Support for UIO and Misc
Driver</a>
Provides details of IPC GateMP support with UIO driver</p></li>
<li><p><a class="reference external" href="http://processors.wiki.ti.com/index.php/Early_Boot_and_Late_Attach">Early Boot and Late
Attach</a>
Provides details of Early Boot and Late Attach</p></li>
<li><p><a class="reference external" href="http://processors.wiki.ti.com/index.php/Early_Boot_and_Late_Attach_in_Linux">Early Boot and Late Attach in
Linux</a>
Provides details of Early Boot and Late Attach in Linux</p></li>
<li><p><a class="reference external" href="index_Foundational_Components.html#ipc-daemon">IPC
Daemon</a>
Provides details of IPC Daemon</p></li>
</ul>
</div>
<div class="section" id="other-ti-ipc-useful-links">
<h3>4.4.1.2. Other TI IPC useful links<a class="headerlink" href="#other-ti-ipc-useful-links" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="index_Foundational_Components.html#ipc-3-x">IPC 3.x</a>
Provides details of IPC 3.x releases</p></li>
<li><p><a class="reference external" href="http://processors.wiki.ti.com/index.php/IPC_3.x_Migration_Guide">IPC 3.x Migration
Guide</a>
Provides details of migrating to IPC 3.x from previous releases</p></li>
<li><p><a class="reference external" href="index_Foundational_Components.html#ipc-faq">IPC 3.x
FAQ</a>
Frequently asked question on IPC 3.x</p></li>
<li><p><a class="reference external" href="index_Foundational_Components.html#ipc-benchmarking">IPC
Benchmarking</a>
IPC Benchmarking with IPC 3.x</p></li>
</ul>
</div>
<div class="section" id="ipc-install-guides">
<h3>4.4.1.3. IPC Install Guides<a class="headerlink" href="#ipc-install-guides" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="index_Foundational_Components.html#linux-install-guide">IPC Install Guide
Linux</a></p></li>
<li><p><a class="reference external" href="index_Foundational_Components.html#qnx-install-guide">IPC Install Guide
QNX</a></p></li>
<li><p><a class="reference external" href="index_Foundational_Components.html#bios-install-guide">IPC Install Guide BIOS</a></p></li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please see the release notes in your IPC installation before starting to
use IPC. The release notes contain important information about feature
support, issues, and compatibility information for a particular release.</p>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="id1">
<h2>4.4.2. IPC Install Guides<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<div class="section" id="bios-install-guide">
<h3>4.4.2.1. BIOS Install Guide<a class="headerlink" href="#bios-install-guide" title="Permalink to this headline">¶</a></h3>
<div class="section" id="introduction">
<h4>4.4.2.1.1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h4>
<p>Inter/Intra Processor Communication (IPC) is a product designed to
enable communication between processors in a multi-processor
environment. Features of IPC include message passing, multi-processor
gates, shared memory primitives, and more.</p>
<p>IPC is designed for use with processors running SYS/BIOS applications.
This is typically an ARM or DSP. IPC includes support for High Level
Operating Systems (HLOS) like Linux, as well as the SYS/BIOS RTOS. The
breadth of IPC features supported in an HLOS environment is reduced in
an effort to simplify the product.</p>
</div>
<div class="section" id="install">
<h4>4.4.2.1.2. Install<a class="headerlink" href="#install" title="Permalink to this headline">¶</a></h4>
<p>IPC is often distributed and installed within a larger SDK. In those
cases, no installation is required.</p>
<p>Outside of an SDK, <a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/index.html">IPC can be downloaded
here</a>,
and is released as a zip file. To install, simply extract the file.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>buildhost$ unzip ipc_&lt;version&gt;.zip
</pre></div>
</div>
<p>This will extract the IPC product in a directory with its product name
and version information (e.g. <strong>c:/ti/ipc_&lt;version&gt;</strong>)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>This document assumes the IPC install path to be the user’s home
directory on a Linux host machine (<strong>/home/&lt;user&gt;</strong>) or the user’s
main drive on a Windows host machine (<strong>C:\</strong>). The variable
<strong>IPC_INSTALL_DIR</strong> will be used throughout the document. If IPC was
installed at a different location, make appropriate changes to
commands.</p></li>
<li><p>Some customers find value in archiving the released sources in a
configuration management system. This can help in identifying any
changes made to the original sources - often useful when updating to
newer releases.</p></li>
</ul>
</div>
</div>
<div class="section" id="build">
<h4>4.4.2.1.3. Build<a class="headerlink" href="#build" title="Permalink to this headline">¶</a></h4>
<p>The IPC product often comes with prebuilt libraries, so rebuilding them
isn’t necessary. The IPC product downloads contain prebuilt libraries,
and when provided with an SDK, IPC is typically rebuilt to contain only
libraries appropriate for the SDK.</p>
<p>However, if you want to rebuild its libraries, IPC provides GNU
makefile(s) at the base of the product. This section describes the steps
required to rebuild the IPC libraries.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>GNU make version 3.81 or greater is required. The XDC tools (provided
with most SDKs and CCS distributions) includes a pre-compiled version of
GNU make 3.81 in $(XDC_INSTALL_DIR)/gmake.</p>
</div>
<div class="section" id="products-mak">
<h5>4.4.2.1.3.1. products.mak<a class="headerlink" href="#products-mak" title="Permalink to this headline">¶</a></h5>
<p>IPC contains a <strong>products.mak</strong> file at the root of the product that
specifies the necessary paths and options to build IPC for the various
OS support.</p>
<p>Edit <strong>products.mak</strong> and set the following variables:</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please make sure the complete path is specified. (e.g) Don’t use ~ in the path specified.</p>
</div>
<ul class="simple">
<li><p><strong>XDC_INSTALL_DIR</strong> - Path to TI’s XDCTools installation</p></li>
<li><p><strong>BIOS_INSTALL_DIR</strong> - Path to TI’s SYS/BIOS installation</p></li>
<li><p><strong>ti.targets.&lt;device target and file format&gt;</strong> - Path to TI toolchain
for the device.</p>
<ul>
<li><p>Set only the variables to the targets your device supports to
minimize build time.</p></li>
</ul>
</li>
<li><p><strong>gnu.targets.arm.&lt;device target and file format&gt;</strong> - Path to GNU
toolchain for the device.</p>
<ul>
<li><p>Set only the variables to the targets your device supports to
minimize build time.</p></li>
</ul>
</li>
<li><p><strong>PLATFORM</strong> - (Optional) platform for which to build executables</p>
<ul>
<li><p>Introduced in IPC 3.10. Prior releases build executables for
<strong>all</strong> platforms based on that targets/toolchains set above</p></li>
<li><p>If not set, only libraries will be built (not executables)</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The versions used during validation can be found in the IPC Release
Notes provided in the product.</p>
</div>
</div>
<div class="section" id="ipc-bios-mak">
<h5>4.4.2.1.3.2. ipc-bios.mak<a class="headerlink" href="#ipc-bios-mak" title="Permalink to this headline">¶</a></h5>
<p>IPC is built with a GNU makefile. After editing <strong>products.mak</strong>, issue
the following command:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">buildhost</span><span class="o">&gt;</span> <span class="n">make</span> <span class="o">-</span><span class="n">f</span> <span class="n">ipc</span><span class="o">-</span><span class="n">bios</span><span class="p">.</span><span class="n">mak</span> <span class="n">all</span>
</pre></div>
</div>
<p>Based on the number of targets you’re building for, this may take some
time.</p>
</div>
</div>
<div class="section" id="examples">
<h4>4.4.2.1.4. Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h4>
<p>The IPC product contains an examples/archive directory with
device-specific examples. Once identifying your device, the examples can
be unzipped anywhere on your build host. Typically once unzipped, the
user edits the example’s individual <strong>products.mak</strong> file and simply
invokes <strong>make</strong>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A common place to unzip the examples is into the
<strong>IPC_INSTALL_DIR/examples/</strong> directory. Each example’s <strong>products.mak</strong>
file is smart enough to look up two directories (in this case, into
<strong>IPC_INSTALL_DIR</strong>) for a master <strong>products.mak</strong> file, and if found it
uses those variables. This technique enables users to set the dependency
variables in one place, namely <strong>IPC_INSTALL_DIR/products.mak</strong>.</p>
</div>
<p>Each example contains a <strong>readme.txt</strong> with example-specific details.</p>
</div>
<div class="section" id="see-also">
<h4>4.4.2.1.5. See Also<a class="headerlink" href="#see-also" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><a class="reference external" href="index_Foundational_Components.html#ipc-3-x">IPC 3.x</a></p></li>
<li><p><a class="reference external" href="index_Foundational_Components.html#ipc-user-guide">IPC Users Guide</a></p></li>
<li><p><a class="reference external" href="index_Foundational_Components.html#ipc-faq">IPC 3.x FAQ</a></p></li>
<li><p><a class="reference external" href="index_Foundational_Components.html#linux-install-guide">IPC Install Guide Linux</a></p></li>
<li><p><a class="reference external" href="index_Foundational_Components.html#qnx-install-guide">IPC Install Guide QNX</a></p></li>
</ul>
</div>
</div>
<div class="section" id="linux-install-guide">
<h3>4.4.2.2. Linux Install Guide<a class="headerlink" href="#linux-install-guide" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>4.4.2.2.1. Introduction<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Inter/Intra Processor Communication (IPC) is a product designed to
enable communication between processors in a multi-processor
environment. Features of IPC include message passing, multi-processor
gates, shared memory primitives, and more.</p>
<p>IPC is designed for use with processors running SYS/BIOS applications.
This is typically an ARM or DSP. IPC includes support for High Level
Operating Systems (HLOS) like Linux, as well as the SYS/BIOS RTOS. The
breadth of IPC features supported in an HLOS environment is reduced in
an effort to simplify the product.</p>
</div>
<div class="section" id="id3">
<h4>4.4.2.2.2. Install<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>IPC is often distributed and installed within a larger SDK. In those
cases, no installation is required.</p>
<p>Outside of an SDK, <a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/index.html">IPC can be downloaded
here</a>,
and is released as a zip file. To install, simply extract the file.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>buildhost$ unzip ipc_&lt;version&gt;.zip
</pre></div>
</div>
<p>This will extract the IPC product in a directory with its product name
and version information (e.g. <strong>c:/ti/ipc_&lt;version&gt;</strong>)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>This document assumes the IPC install path to be the user’s home
directory on a Linux host machine (<strong>/home/&lt;user&gt;</strong>) or the user’s
main drive on a Windows host machine (<strong>C:\</strong>). The variable
<strong>IPC_INSTALL_DIR</strong> will be used throughout the document. If IPC was
installed at a different location, make appropriate changes to
commands.</p></li>
<li><p>Some customers find value in archiving the released sources in a
configuration management system. This can help in identifying any
changes made to the original sources - often useful when updating to
newer releases.</p></li>
</ul>
</div>
</div>
<div class="section" id="id4">
<h4>4.4.2.2.3. Build<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>The IPC product often comes with prebuilt SYS/BIOS-side libraries, so
rebuilding them isn’t necessary. The Linux-side user libraries may also
be provided prebuilt, but customers often want to change the
configuration (e.g. static, dynamic).</p>
<p>IPC provides GNU makefile(s) to rebuild all its libraries at the base of
the product, details are below.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>GNU make version 3.81 or greater is required. The XDC tools (provided
with most SDKs and CCS distributions) includes a pre-compiled version of
GNU make 3.81 in $(XDC_INSTALL_DIR)/gmake.</p>
</div>
<div class="section" id="id5">
<h5>4.4.2.2.3.1. products.mak<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<p>IPC contains a <strong>products.mak</strong> file at the root of the product that
specifies the necessary paths and options to build IPC for the various
OS support.</p>
<p>Edit <strong>products.mak</strong> and set the following variables:</p>
<ul class="simple">
<li><p>Variables used by <strong>both Linux-side and BIOS-side</strong> build scripts</p>
<ul>
<li><p><strong>PLATFORM</strong> - (Optional) Device to build for</p>
<ul>
<li><p>To find the supported list of platforms, run: <strong>./configure
–help</strong></p></li>
<li><p>If not set, Linux libraries and executables for all supported
platforms will be built.</p></li>
<li><p>If not set, BIOS libraries for all toolchains specified (see
below) will be built, but no BIOS-side executables will be
built.</p>
<ul>
<li><p>BIOS-side builds started leveraging this variable in IPC
3.10. Prior releases built BIOS-side executables for <strong>all</strong>
supported platforms based on that targets/toolchains set
above (which can take a while!)</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Variables used by <strong>Linux-side</strong> build scripts</p>
<ul>
<li><p><strong>TOOLCHAIN_INSTALL_DIR</strong> - Path to the devices ARM Linux
cross-compiler toolchain</p></li>
<li><p><strong>TOOLCHAIN_LONGNAME</strong> - Long name of the devices toolchain (e.g.
arm-none-linux-gnueabi)</p></li>
<li><p><strong>KERNEL_INSTALL_DIR</strong> - Location of your Linux kernel
installation</p>
<ul>
<li><p>In old releases, this variable was optional, and only needed
for platforms that support the MmRpc API (e.g. OMAP5, DRA7XX).
In IPC 3.00.04, 3.10.02, and 3.20+, all platforms began
requiring this variable to interrogate your kernel’s version
(via KERNEL_INSTALL_DIR/linux/version.h) and accommodate
different kernels.</p></li>
</ul>
</li>
<li><p><strong>DRM_PREFIX</strong> - (Optional) Location of your libdrm installation,
used by some MmRpc tests</p>
<ul>
<li><p>This is only used by MmRpc tests, and therefore only should be
set for platforms that support the MmRpc API</p></li>
<li><p>If set, additional MmRpc tests may be built.</p></li>
</ul>
</li>
<li><p><strong>CMEM_INSTALL_DIR</strong> - (Optional) Path to TI Linux Utils package
to locate the pre-built
<a class="reference external" href="http://processors.wiki.ti.com/index.php/Linux_Utils_Overview">CMEM</a>
libraries used by some MessageQ tests</p>
<ul>
<li><p>If set, additional test applications for select platforms may
be built.</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Variables used by <strong>BIOS-side</strong> build scripts</p>
<ul>
<li><p><strong>XDC_INSTALL_DIR</strong> - Path to TI’s XDCTools installation (e.g.
<strong>c:/ti/xdctools_&lt;version&gt;</strong>)</p></li>
<li><p><strong>BIOS_INSTALL_DIR</strong> - Path to TI’s SYS/BIOS installation (e.g.
<strong>c:/ti/bios_&lt;version&gt;</strong>)</p></li>
<li><p><strong>ti.targets.&lt;device target and file format&gt;</strong> - Path to TI
toolchain for the device. (e.g.
<strong>c:/ti/CCS/ccsbase/tools/compiler/c6000_&lt;version&gt;</strong>)</p>
<ul>
<li><p>Set only the variables to the targets your device supports to
minimize build time.</p></li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The specific versions of dependent components can be found in the IPC
Release Notes, provided in the product.</p>
</div>
</div>
<div class="section" id="ipc-linux-mak">
<h5>4.4.2.2.3.2. ipc-linux.mak<a class="headerlink" href="#ipc-linux-mak" title="Permalink to this headline">¶</a></h5>
<p>The Linux-side build is provided as a GNU Autotools (Autoconf, Automake,
Libtool) project. If you are familiar with Autoconf GNU projects, you
can proceed with using the <strong>./configure</strong> script directly to
cross-compile the Linux user libraries and tests.</p>
<p>For those that require some assistance, the IPC package provides a GNU
makefile (<strong>ipc-linux.mak</strong>) to configure the Linux-side build, using
the options and component paths set in the <strong>products.mak</strong> file. To
configure the build using these files, issue the following command:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">buildhost</span><span class="o">&gt;</span> <span class="n">make</span> <span class="o">-</span><span class="n">f</span> <span class="n">ipc</span><span class="o">-</span><span class="n">linux</span><span class="p">.</span><span class="n">mak</span> <span class="n">config</span>
</pre></div>
</div>
<p>There are few additional target goals provided in the ipc-linux.mak file
for commonly used configurations. These goals include:</p>
<ul class="simple">
<li><p>config - (Default) Configure both static and shared (dynamic) Linux
IPC user libraries. Executables (e.g. lad and tests) link against the
shared libraries.</p></li>
<li><p>config-static - Configure static only libraries and executables.</p></li>
<li><p>config-shared - Configure shared (dynamic) only libraries and
executables.</p></li>
</ul>
<p>Once the ‘config’ is complete, and the autotools-generated Makefile has
been created, you can build the Linux side of IPC by issuing the
following:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">buildhost</span><span class="o">&gt;</span> <span class="n">make</span>
</pre></div>
</div>
<p>You can also specify a PLATFORM to (re)configure for on the command line
which overrides any options set in the products.mak file as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">buildhost</span><span class="o">&gt;</span> <span class="n">make</span> <span class="o">-</span><span class="n">f</span> <span class="n">ipc</span><span class="o">-</span><span class="n">linux</span><span class="p">.</span><span class="n">mak</span> <span class="n">config</span> <span class="n">PLATFORM</span><span class="o">=</span><span class="n">omapl138</span>
<span class="o">&lt;</span><span class="n">buildhost</span><span class="o">&gt;</span> <span class="n">make</span>
</pre></div>
</div>
<p>Note that before reconfiguring for a new Linux toolchain or platform,
the autotools-generated files should be clean(ed):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">buildhost</span><span class="o">&gt;</span> <span class="n">make</span> <span class="n">distclean</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="id6">
<h5>4.4.2.2.3.3. ipc-bios.mak<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h5>
<p>The SYS/BIOS-side IPC is built with a GNU makefile. After editing
<strong>products.mak</strong>, issue the following command:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">buildhost</span><span class="o">&gt;</span> <span class="n">make</span> <span class="o">-</span><span class="n">f</span> <span class="n">ipc</span><span class="o">-</span><span class="n">bios</span><span class="p">.</span><span class="n">mak</span> <span class="n">all</span>
</pre></div>
</div>
<p>Based on the number of targets you’re building for, this may take some
time.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The BIOS-side libraries often come pre-built, so in many cases,
rebuilding the BIOS-side is not necessary. Some reasons you may want to
rebuild:</p>
</div>
<ul class="simple">
<li><p>Your distribution of IPC <strong>didn’t</strong> come with the necessary pre-built
libraries</p></li>
<li><p>You intend to run the ‘test’ executables (which often don’t come
pre-built)</p></li>
<li><p>You want to use a specific toolchain or dependency version</p></li>
<li><p>You want to tune some of the compile options</p></li>
</ul>
</div>
</div>
<div class="section" id="run">
<h4>4.4.2.2.4. Run<a class="headerlink" href="#run" title="Permalink to this headline">¶</a></h4>
<p>The IPC product provides a way to install (copy) the necessary IPC
executables and libraries onto the device’s target file-system to
simplify the execution of the applications.</p>
<div class="section" id="configuring-kernel">
<h5>4.4.2.2.4.1. Configuring Kernel<a class="headerlink" href="#configuring-kernel" title="Permalink to this headline">¶</a></h5>
<p>The IPC product provides a set of Linux kernel patches that need to be
applied to the different device supported kernels to add necessary
kernel support. The patches are located in the linux/patches directory
of the IPC installation.</p>
<div class="section" id="omap-l138">
<h6>4.4.2.2.4.1.1. OMAP-L138<a class="headerlink" href="#omap-l138" title="Permalink to this headline">¶</a></h6>
<p>The kernel for the OMAP-L138, can be obtained from <a class="reference external" href="http://gitorious.org/linux-davinci">Gitorious
linux-davinci project</a>.</p>
<p>The patches apply to the following commit id:
<strong>595ab716fc6e648b7dc79a58a01917ebb67b9508</strong></p>
<p>The specific patches needed for this kernel can be found in the
<strong>linux/patches/3.8.0</strong> of your IPC installation.</p>
<p>Once the patches are applied, there are a few key config parameters
needed for rpmsg and socket driver to build/work.</p>
<p>CONFIG_REMOTEPROC=m
CONFIG_DA8XX_REMOTEPROC=m
CONFIG_RPMSG=m
CONFIG_VIRTIO=m
It is also recommended to compile a Linux kernel with the debugfs
facility</p>
<p>CONFIG_DEBUG_FS=y
Re-build the kernel. For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>buildhost$ make ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabi-  uImage
</pre></div>
</div>
<p>You will also need to re-build the kernel modules and install them on
your target’s file system. For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>buildhost$ make ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabi-  modules
buildhost$ make ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabi- INSTALL_MOD_PATH=&lt;target filesystem&gt; modules_install
</pre></div>
</div>
</div>
</div>
<div class="section" id="kernel-boot-up-parameters">
<h5>4.4.2.2.4.2. Kernel Boot-up Parameters<a class="headerlink" href="#kernel-boot-up-parameters" title="Permalink to this headline">¶</a></h5>
<p>IPC requires an argument to be passed to the Linux kernel during boot up
to properly run the tests. The remote processor(s) (rproc) memory
location needs to be set.</p>
<ul class="simple">
<li><p>For example,</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>bootargs console=ttyS2,115200n8 root=/dev/nfs nfsroot=HOST:nfs_root,nolock rw ip=dhcp rproc_mem=16M@0xC3000000
</pre></div>
</div>
<p><em>This is just an example, bootargs may vary depending on available setup</em>
Depending on the memory map used in the final system configuration,
the memory to be reserved for rproc usage may differ.</p>
</div>
<div class="section" id="installing-tests">
<h5>4.4.2.2.4.3. Installing Tests<a class="headerlink" href="#installing-tests" title="Permalink to this headline">¶</a></h5>
<p>To assemble the IPC test executables and libraries into a directory
structure suitable for running on the target’s file-system, issue the
following command in the IPC install directory:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>buildhost$ make install prefix=&lt;target filesystem&gt;/usr
</pre></div>
</div>
<p><em>Depending on you target’s filesystem directory privileges, you may be
required to run **sudo make install*</em> to properly install the files
*</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The test executables and libraries will be installed in the location
path set by the <strong>prefix</strong> variable. If you are installing directly on a
host mounted Network Filesystem(NFS), make sure to specify <strong>usr</strong> at
the end of the <strong>prefix</strong> variable path. As with other variables, you
can override this on the command line:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>buildhost$ sudo make install prefix=&lt;target filesystem&gt;/usr
</pre></div>
</div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>The remote processor’s applications will be loaded via the remote_proc
kernel module but they need to reside on the devices target filesystem
in <strong>/lib/firmware</strong> directory. The location of the remote core
application within the IPC product various based on device.</p>
<div class="section" id="slave-binaries">
<h6>4.4.2.2.4.3.1. Slave Binaries<a class="headerlink" href="#slave-binaries" title="Permalink to this headline">¶</a></h6>
<p>The slave-side test binaries, once built, are found in your
IPC_INSTALL_DIR/packages/ti/ipc/tests/bin/&lt;platform&gt;_&lt;core&gt; directory.</p>
<p>Copy the appropriate slave-side executable onto the devices target
filesystem into the <strong>/lib/firmware</strong> directory. For example, OMAP-L138
developers would do this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>buildhost$ cp IPC_INSTALL_DIR/packages/ti/ipc/tests/bin/ti_platforms_evmOMAPL138_DSP/ &lt;target filesystem&gt;/lib/firmware/.
</pre></div>
</div>
</div>
<div class="section" id="ipc-daemons-and-drivers">
<h6>4.4.2.2.4.3.2. IPC Daemons and Drivers<a class="headerlink" href="#ipc-daemons-and-drivers" title="Permalink to this headline">¶</a></h6>
<p>IPC provides system-wide services across multiple applications, and
utilizes low-level system hardware (e.g. interrupts and shared memory).
To facilitate these services, IPC uses a user-space daemon (LAD) and
several kernel device drivers.</p>
<p class="rubric" id="lad">LAD</p>
<p>System-wide IPC state is managed by a user-space daemon (LAD). This
daemon is specific to a given device, and is named lad_&lt;device&gt;. It will
reside on the target’s filesystem (typically in /usr/bin/) after
following the <a class="reference external" href="index_Foundational_Components.html#installing-tests">#Installing Tests</a> section. To run
LAD, execute:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target# /usr/bin/lad_&lt;device&gt;
</pre></div>
</div>
<p>This forks the LAD daemon and leaves it running in the background.</p>
<p>LAD takes an optional argument to indicate a filename into which log
statements should be emitted. This file will be created in the
<strong>/tmp/LAD/</strong> directory. How to specify the filename varies based on
your IPC release. For example, to instruct LAD to emit log statements
into a ‘lad.txt’ file, start LAD like this:</p>
<ul class="simple">
<li><p>Releases before IPC 3.21:</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target# /usr/bin/lad_&lt;device&gt; lad.txt
</pre></div>
</div>
<ul class="simple">
<li><p>IPC 3.21 and after:</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target# /usr/bin/lad_&lt;device&gt; -l lad.txt
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p class="rubric" id="drivers">Drivers</p>
<p>The kernel drivers/modules added by the Linux patches must be inserted
into the kernel for IPC applications to run correctly. Refer to the
<a class="reference external" href="index_Foundational_Components.html#configuring-kernel">#Configuring Kernel</a> section. The required
modules must be configured, built and loaded onto the target’s
filesystem.</p>
<p>Prior to loading the modules, a directory (/debug) must be created at
the root of your devices filesystem. This directory will be mounted as a
debugfs (debug filesystem) which the kernel modules will use to provide
details about the slaves (e.g. running state, trace output, etc). If the
/debug directory doesn’t exist, simply create it as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target# mkdir /debug
</pre></div>
</div>
<p class="rubric" id="omap-l138-1">OMAP-L138</p>
<p>On OMAP-L138, the kernel modules can be loaded with the following
command on the target’s file-system:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target# depmod -a
target# mount -t debugfs none /debug
target# modprobe remoteproc
target# modprobe da8xx_remoteproc da8xx_fw_name=messageq_single.xe674
target# modprobe virtio_rpmsg_bus
target# modprobe rpmsg_proto
</pre></div>
</div>
<p>The kernel modules can be unloaded by issuing the following command on
the target’s file-system:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target# umount /debug
target# rmmod rpmsg_proto
target# rmmod virtio_rpmsg_bus
target# rmmod da8xx_remoteproc
target# rmmod remoteproc
</pre></div>
</div>
<p class="rubric" id="omap54xx">OMAP54XX</p>
<p>On OMAP54XX, the kernel modules can be loaded with the following command
on the target’s file-system:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target# depmod -a
target# mount -t debugfs none /debug
target# modprobe remoteproc
target# modprobe omap_remoteproc
target# modprobe virtio_rpmsg_bus
target# modprobe rpmsg_proto
</pre></div>
</div>
</div>
<div class="section" id="running-test-applications">
<h6>4.4.2.2.4.3.3. Running Test Applications<a class="headerlink" href="#running-test-applications" title="Permalink to this headline">¶</a></h6>
<p>The test applications are already on the target’s filesystem in /usr/bin
assuming the <a class="reference external" href="index_Foundational_Components.html#installing-tests">#Installing Tests</a> section has been
followed.</p>
<p>To run the test application’s, execute the following on the target’s
filesystem:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target# /usr/bin/MessageQApp_&lt;device&gt;
</pre></div>
</div>
<p class="rubric" id="omap-l138-2">OMAP-L138</p>
<p>The expected output on the Linux-side should be:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>Using numLoops: 100; procId : 1
Entered MessageQApp_execute
Local MessageQId: 0x1
Remote queueId  [0x10000]
Exchanging 100 messages with remote processor DSP...
MessageQ_get #0 Msg = 0x15328
Exchanged 1 messages with remote processor DSP
MessageQ_get #1 Msg = 0x15328
...
...
Exchanged 99 messages with remote processor DSP
MessageQ_get #99 Msg = 0x15328
Exchanged 100 messages with remote processor DSP
Sample application successfully completed!
Leaving MessageQApp_execute
</pre></div>
</div>
<p>The output on the remote processor, can be obtained by running the
following on the target filesystem:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target# cat /debug/remoteproc/remoteproc0/trace0
</pre></div>
</div>
<p>The expected output on the remote processor should be:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>3 Resource entries at 0xc3100000
messageq_single.c:main: MultiProc id = 1
registering rpmsg-proto service on 61 with HOST
tsk1Fxn: created MessageQ: SLAVE_DSP; QueueID: 0x10000
Awaiting sync message from host...
[t=0x00000001:67984156] ti.ipc.rpmsg.MessageQCopy: MessageQCopy_send: no object for endpoint: 53
[t=0x00000001:67f626ed] ti.ipc.rpmsg.MessageQCopy: MessageQCopy_send: no object for endpoint: 53
Received msg from (procId:remoteQueueId): 0x0:0x1
       payload: 8 bytes; loops: 100 with printing.
Got msg #0 (40 bytes) from procId 0
Sending msg Id #0 to procId 0
Got msg #1 (40 bytes) from procId 0
Sending msg Id #1 to procId 0
...
...
Got msg #98 (40 bytes) from procId 0
Sending msg Id #98 to procId 0
Got msg #99 (40 bytes) from procId 0
Sending msg Id #99 to procId 0
Awaiting sync message from host...
[t=0x00000015:7b46c4c2] ti.ipc.rpmsg.MessageQCopy: MessageQCopy_send: no object for endpoint: 53
[t=0x00000015:7b6315fb] ti.ipc.rpmsg.MessageQCopy: MessageQCopy_send: no object for endpoint: 53
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id7">
<h4>4.4.2.2.5. See Also<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><a class="reference external" href="index_Foundational_Components.html#ipc-3-x">IPC 3.x</a></p></li>
<li><p><a class="reference external" href="index_Foundational_Components.html#ipc-user-guide">IPC Users Guide</a></p></li>
<li><p><a class="reference external" href="index_Foundational_Components.html#ipc-faq">IPC 3.x FAQ</a></p></li>
<li><p><a class="reference external" href="index_Foundational_Components.html#qnx-install-guide">IPC Install Guide QNX</a></p></li>
<li><p><a class="reference external" href="index_Foundational_Components.html#bios-install-guide">IPC Install Guide BIOS</a></p></li>
</ul>
</div>
</div>
<div class="section" id="qnx-install-guide">
<h3>4.4.2.3. QNX Install Guide<a class="headerlink" href="#qnx-install-guide" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id8">
<h4>4.4.2.3.1. Introduction<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>Inter/Intra Processor Communication (IPC) is a product designed to
enable communication between processors in a multi-processor
environment. Features of IPC include message passing, multi-processor
gates, shared memory primitives, and more.</p>
<p>IPC is designed for use with processors running SYS/BIOS applications.
This is typically an ARM or DSP. IPC includes support for High Level
Operating Systems (HLOS) like Linux, as well as the SYS/BIOS RTOS. The
breadth of IPC features supported in an HLOS environment is reduced in
an effort to simplify the product.</p>
</div>
<div class="section" id="id9">
<h4>4.4.2.3.2. Install<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<p>IPC is often distributed and installed within a larger SDK. In those
cases, no installation is required.</p>
<p>Outside of an SDK, <a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/index.html">IPC can be downloaded
here</a>,
and is released as a zip file. To install, simply extract the file.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>buildhost$ unzip ipc_&lt;version&gt;.zip
</pre></div>
</div>
<p>This will extract the IPC product in a directory with its product name
and version information (e.g. <strong>c:/ti/ipc_&lt;version&gt;</strong>)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>This document assumes the IPC install path to be the user’s home
directory on a Linux host machine (<strong>/home/&lt;user&gt;</strong>) or the user’s
main drive on a Windows host machine (<strong>C:\</strong>). The variable
<strong>IPC_INSTALL_DIR</strong> will be used throughout the document. If IPC was
installed at a different location, make appropriate changes to
commands.</p></li>
<li><p>Some customers find value in archiving the released sources in a
configuration management system. This can help in identifying any
changes made to the original sources - often useful when updating to
newer releases.</p></li>
</ul>
</div>
</div>
<div class="section" id="id10">
<h4>4.4.2.3.3. Build<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<p>The IPC product often comes with prebuilt SYS/BIOS-side libraries, so
rebuilding them isn’t necessary. The QNX-side libraries/binaries may
also be provided prebuilt by SDK programs, but the standalone IPC
release does not currently pre-build them.</p>
<p>IPC provides GNU makefile(s) to rebuild all its libraries at the base of
the product, details are below.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>GNU make version 3.81 or greater is required. The XDC tools (provided
with most SDKs and CCS distributions) includes a pre-compiled version of
GNU make 3.81 in $(XDC_INSTALL_DIR)/gmake.</p>
</div>
<div class="section" id="id11">
<h5>4.4.2.3.3.1. products.mak<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h5>
<p>IPC contains a <strong>products.mak</strong> file at the root of the product that
specifies the necessary paths and options to build IPC for the various
OS support.</p>
<p>Edit <strong>products.mak</strong> and set the following variables:</p>
<ul class="simple">
<li><p>Variables used by both QNX and BIOS</p>
<ul>
<li><p><strong>PLATFORM</strong> - Device to build for</p>
<ul>
<li><p>QNX started using this variable in IPC 3.20. Prior releases
required setting “DEVICE” for QNX and “PLATFORM” for BIOS. The
two variables were consolidated in IPC 3.20.</p></li>
<li><p>BIOS started leveraging this variable in IPC 3.10. Prior
releases built BIOS-side executables for <strong>all</strong> supported
platforms based on that targets/toolchains set above (which can
take a while!)</p></li>
</ul>
</li>
</ul>
</li>
<li><p>QNX</p>
<ul>
<li><p><strong>QNX_INSTALL_DIR</strong> - Path to your QNX installation directory.</p></li>
<li><p><strong>DESTDIR</strong> - Path to which target binaries will be exported when
running the ‘make install’ goal.</p></li>
<li><p><strong>DEVICE</strong> - (only required for releases prior to IPC 3.20) Device
to build for</p></li>
</ul>
</li>
<li><p>SYS/BIOS</p>
<ul>
<li><p><strong>XDC_INSTALL_DIR</strong> - Path to TI’s XDCTools installation</p></li>
<li><p><strong>BIOS_INSTALL_DIR</strong> - Path to TI’s SYS/BIOS installation</p></li>
<li><p><strong>ti.targets.&lt;device target and file format&gt;</strong> - Path to TI
toolchain for the device.</p>
<ul>
<li><p>Set only the variables to the targets your device supports to
minimize build time.</p></li>
</ul>
</li>
<li><p><strong>gnu.targets.arm.&lt;device target and file format&gt;</strong> - Path to GNU
toolchain for the device.</p>
<ul>
<li><p>Set only the variables to the targets your device supports to
minimize build time.</p></li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The versions used during validation can be found in the IPC Release
Notes provided in the product.</p>
</div>
<p class="rubric" id="ipc-qnx-mak">ipc-qnx.mak</p>
<p>The QNX-side build is performed using QNX makefiles. To build using the
components paths set in the <strong>products.mak</strong> file, issue the following
command:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">buildhost</span><span class="o">&gt;</span> <span class="n">make</span> <span class="o">-</span><span class="n">f</span> <span class="n">ipc</span><span class="o">-</span><span class="n">qnx</span><span class="p">.</span><span class="n">mak</span> <span class="n">all</span>
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h5>4.4.2.3.3.2. ipc-bios.mak<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h5>
<p>The SYS/BIOS-side IPC is built with a GNU makefile. After editing
<strong>products.mak</strong>, issue the following command:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">buildhost</span><span class="o">&gt;</span> <span class="n">make</span> <span class="o">-</span><span class="n">f</span> <span class="n">ipc</span><span class="o">-</span><span class="n">bios</span><span class="p">.</span><span class="n">mak</span> <span class="n">all</span>
</pre></div>
</div>
<p>Based on the number of targets you’re building for, this may take some
time.</p>
<p><strong>Note for Windows users:</strong> If you are building with a Windows host
machine and it has the QNX tools installed, you will instead need to run
the following in a separate command prompt window (cmd.exe) to build the
SYS/BIOS side outside of the QNX build environment:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>&lt;buildhost&gt; set PATH=C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem
&lt;buildhost&gt; &lt;XDC_INSTALL_DIR&gt;\gmake -f ipc-bios.mak all
</pre></div>
</div>
<p>where &lt;XDC_INSTALL_DIR&gt; should be replaced with the installation
directory of your XDC tools, same as the path you have used in
products.mak.</p>
</div>
</div>
<div class="section" id="id13">
<h4>4.4.2.3.4. Run<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<p>The IPC product provides a way to install (copy) the necessary IPC
executables and libraries onto the device’s target file-system to
simplify the execution of the applications. The details can vary across
OS’s, so this description has been separated into OS-specific sections.</p>
<div class="section" id="configuring-the-bsp">
<h5>4.4.2.3.4.1. Configuring the BSP<a class="headerlink" href="#configuring-the-bsp" title="Permalink to this headline">¶</a></h5>
<p>Some of the provided IPC tests that use a utility called
SharedMemoryAllocator require a carveout to be created in the QNX-owned
memory. To reserve this memory, you must make the following change in
the file &lt;QNX BSP installation
directory&gt;srchardwarestartupboards&lt;board name&gt;build in the QNX
BSP. E.g.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">startup</span><span class="o">-</span><span class="n">omap5432uevm</span> <span class="o">-</span><span class="n">r</span> <span class="mh">0xBA300000</span><span class="p">,</span><span class="mh">0x5A00000</span> <span class="o">-</span><span class="n">vvvvv</span> <span class="o">-</span><span class="n">P2</span> <span class="o">-</span><span class="n">W</span>
</pre></div>
</div>
<p>Save the file, then rebuild the QNX OS image (ifs-<a href="#id14"><span class="problematic" id="id15">*</span></a>.bin) and replace
your existing one with the new one.</p>
</div>
<div class="section" id="installing-tests-in-qnx">
<h5>4.4.2.3.4.2. Installing Tests in QNX<a class="headerlink" href="#installing-tests-in-qnx" title="Permalink to this headline">¶</a></h5>
<p>To assemble the IPC resource manager, shared libraries and test
executables into a directory structure suitable for running on the
device’s file-system, issue the following command in the IPC_INSTALL_DIR
directory:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>buildhost$ make -f ipc-qnx.mak install
</pre></div>
</div>
<p>This will install the binaries into the directory specified by DESTDIR
in products.mak. It this assumed that DESTDIR is a directory visible to
the target filesystem. If not, you should copy its contents to such a
location (e.g. onto an SD card that can be accessed by the EVM).</p>
<p>When building in Windows, some users might get build messages that
report a version mismatch in cygwin:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>C:/QNX650/host/win32/x86/usr/bin/make -j 1 -Cle.v7 -fMakefile install
      1 [main] ? (5984) C:\QNX650\host\win32\x86\usr\photon\bin\find.exe: *** fa
tal error - system shared memory version mismatch detected - 0x8A88009C/0x2D1E009C.
This problem is probably due to using incompatible versions of the cygwin DLL.
Search for cygwin1.dll using the Windows Start-&gt;Find/Search facility
and delete all but the most recent version.  The most recent version *should*
reside in x:\cygwin\bin, where &#39;x&#39; is the drive on which you have
installed the cygwin distribution.  Rebooting is also suggested if you
are unable to find another cygwin DLL.
</pre></div>
</div>
<p>Based on what we observed the binaries are still exported correctly
despite the messages. If you do want to eliminate them, you should
replace the file cygwin1.dll in
&lt;QNX_INSTALL_DIR&gt;hostwin32x86usrphotonbin with the newest
cygwin1.dll you can find on your host machine (do a search on your PC’s
filesystem in Windows).</p>
<p>Some of the tests rely on corresponding remote core applications to be
run on the slave processor(s). The remote processor’s applications are
loaded when launching the resource manager. See section
<a class="reference external" href="index_Foundational_Components.html#ipc-resource-manager">#IPC_resource_manager</a> for details on
launching the resource manager.</p>
<p>The location of the remote core applications within the IPC product
varies based on device.</p>
<div class="section" id="installing-remote-core-applications">
<h6>4.4.2.3.4.2.1. Installing remote core applications<a class="headerlink" href="#installing-remote-core-applications" title="Permalink to this headline">¶</a></h6>
<p>Remote core applications can be found in
&lt;IPC_INSTALL_DIR&gt;/packages/ti/ipc/tests/bin/ti_platform_&lt;your platform
name&gt;_* directories.</p>
<p>For example, you can copy the messageq_single.xem4 for OMAP54xx uEVM’s
IPU onto the device’s target filesystem into the <strong>bin</strong> directory as
follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>buildhost$ copy &lt;IPC_INSTALL_DIR&gt;/packages/ti/ipc/tests/bin/ti_platform_omap54xx_ipu/messageq_single.xem4 &lt;DESTDIR&gt;/armle-v7/bin
</pre></div>
</div>
<p>‘ti_platform_omap54xx_ipu’ indicates the platform is ‘omap54xx’ and the
remote core name is ‘IPU’. You only need to copy the binaries relevant
to your platform.</p>
</div>
</div>
<div class="section" id="ipc-resource-manager">
<h5>4.4.2.3.4.3. IPC resource manager<a class="headerlink" href="#ipc-resource-manager" title="Permalink to this headline">¶</a></h5>
<p>Much of the functionality of IPC is provided by the resource manager. It
can be launched as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target# cd &lt;target directory corresponding to DESTDIR&gt;/armle-v7/bin
target# export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:&lt;target directory corresponding to DESTDIR&gt;/armle-v7/usr/lib
target# ipc &lt;CORE1&gt; &lt;remote executable 1&gt; &lt;CORE2&gt; &lt;remote executable 2&gt; ...
</pre></div>
</div>
<p>&lt;CORE&gt; should correspond to the name of the remote core on which you
want the remote executable to be loaded. As a rule of thumb, it is the
capitalized version of the core name specified by the name of the
directory from which the executable was copied in the <a class="reference external" href="index_Foundational_Components.html#installing-remote-core-applications">#Installing remote core applications</a>
section. For example, if the executable is copied from
“ti_platform_omap54xx_**ipu**/test_omx_ipu_omap5.xem4”, then you should
load it as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target# ipc IPU test_omx_ipu_omap5.xem4
</pre></div>
</div>
<p>The resource manager will register devices in the pathname space for
communicating with the IPC. Communication with the IPC is only possible
once the needed devices are registered. The following devices are
registered by default when the IPC resource manager is launched:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Device</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>/dev/tiipc</p></td>
<td><p>Provides the “ti-ipc” protocol. Needed by MessageQ APIs.</p></td>
</tr>
<tr class="row-odd"><td><p>/dev/ipc</p></td>
<td><p>Provides the HWSpinLock functionality. Needed by GateMP APIs.</p></td>
</tr>
</tbody>
</table>
<p>Additionally, more devices may be registered by the remote core firmware
if using the “rpmsg-rpc” protocol. In that case, the name that appears
in the pathname space is specified by the remote core firmware.</p>
<p>Later, when you are done running applications that use IPC and no longer
need the resource manager, it can be terminated as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target# cd &lt;target directory corresponding to DESTDIR&gt;/armle-v7/bin
target# slay ipc
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h5>4.4.2.3.4.4. Running Test Applications<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h5>
<p>The QNX-side of the test applications are already on the target’s
filesystem in &lt;target directory corresponding to DESTDIR&gt;/armle-v7/bin
and &lt;target directory corresponding to DESTDIR&gt;/armle-v7/bin/tests,
assuming the <a class="reference external" href="index_Foundational_Components.html#installing-tests-in-qnx">#Installing Tests in QNX</a> and
<a class="reference external" href="index_Foundational_Components.html#ipc-resource-manager">#IPC resource manager</a> sections have been
followed and that the resource manager has loaded the remote core(s)
with the executable corresponding to the test you’d like to run.</p>
<p>To find out the syntax to use for running the test (say MessageQApp),
run</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target# cd &lt;target directory corresponding to DESTDIR&gt;/armle-v7/bin/tests
target# use MessageQApp
</pre></div>
</div>
<p>To run a test application, execute it on the target’s filesystem:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target# cd &lt;target directory corresponding to DESTDIR&gt;/armle-v7/bin/tests
target# ./MessageQApp 10
</pre></div>
</div>
<p>Here is a list of the main tests that are available in the IPC product:</p>
<ul class="simple">
<li><p>MessageQApp: Test that creates a single thread that sends messages
from host to remote core using MessageQ</p>
<ul>
<li><p>messageq_single.x* need to be loaded by the resource manager</p></li>
</ul>
</li>
<li><p>MessageQMulti: Test that creates multiple threads which send messages
from host to remote core using MessageQ</p>
<ul>
<li><p>messageq_multi.x* need to be loaded by the resource manager</p></li>
</ul>
</li>
<li><p>mmrpc_test: Test that exercises MMRPC</p>
<ul>
<li><p>test_omx_ipu_&lt;platform&gt;.x* need to be loaded by the resource
manager</p></li>
<li><p>Aside from the IPC resource manager, this test also needs the
shmemallocator resource manager to be launched beforehand:</p></li>
</ul>
</li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target# cd &lt;target directory corresponding to DESTDIR&gt;/armle-v7/bin
target# shmemallocator
target# cd tests
target# mmrpc_test 1
</pre></div>
</div>
<p class="rubric" id="expected-output">Expected output</p>
<p>To give you an idea, the expected output for MessageQApp on the QNX-side
should look similar to this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>Using numLoops: 10; procId : 1
Entered MessageQApp_execute
Local MessageQId: 0x1
Remote queueId  [0x10000]
Exchanging 10 messages with remote processor IPU...
MessageQ_get #0 Msg = 0x11c9f0
Exchanged 1 messages with remote processor IPU
MessageQ_get #1 Msg = 0x11c9f0
Exchanged 2 messages with remote processor IPU
MessageQ_get #2 Msg = 0x11c9f0
...
...
Exchanged 9 messages with remote processor IPU
MessageQ_get #9 Msg = 0x11c9f0
Exchanged 10 messages with remote processor IPU
Sample application successfully completed!
Leaving MessageQApp_execute
</pre></div>
</div>
<p>The output on the remote processor can be obtained by running the
following on the target filesystem:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target# cat /dev/ipc-trace/IPU
</pre></div>
</div>
<p>The expected output on the remote processor should look similar to this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>[0][      0.000] 16 Resource entries at 0x3000
[0][      0.000] messageq_single.c:main: MultiProc id = 1
[0][      0.000] [t=0x006c565d] ti.ipc.transports.TransportVirtioSetup: TransportVirtio
Setup_attach: remoteProcId: 0
[0][      0.000] registering rpmsg-proto:rpmsg-proto service on 61 with HOST
[0][      0.000] [t=0x0072625b] ti.ipc.rpmsg.MessageQCopy: MessageQCopy_create: endPt c
reated: 61
[0][      0.000] [t=0x0073e8d9] ti.ipc.rpmsg.MessageQCopy: callback_availBufReady: virt
Queue_toHost kicked
[0][      0.000] [t=0x00753771] ti.ipc.rpmsg.MessageQCopy: callback_availBufReady: virt
Queue_fromHost kicked
[0][      0.000] [t=0x0076cb49] ti.ipc.rpmsg.MessageQCopy: MessageQCopy_swiFxn:
[0][      0.000]        Received msg: from: 0x5a, to: 0x35, dataLen: 72
[0][      0.000] [t=0x007872e9] ti.ipc.rpmsg.MessageQCopy: MessageQCopy_send: no object
for endpoint: 53
[0][      0.000] tsk1Fxn: created MessageQ: SLAVE_CORE0; QueueID: 0x10000
[0][      0.000] Awaiting sync message from host...
[0][     51.992] [t=0x0c475268] ti.ipc.rpmsg.MessageQCopy: callback_availBufReady: virt
Queue_fromHost kicked
[0][     51.992] [t=0x0c48eb28] ti.ipc.rpmsg.MessageQCopy: MessageQCopy_swiFxn:
[0][     51.993]        Received msg: from: 0x400, to: 0x3d, dataLen: 176
[0][     51.993] [t=0x0c4ad220] ti.ipc.rpmsg.MessageQCopy: MessageQCopy_send: calling c
allback with data len: 176, from: 1024
[0][     51.993]
[0][     52.995] [t=0x0c873ded] ti.ipc.rpmsg.MessageQCopy: callback_availBufReady: virt
Queue_fromHost kicked
[0][     52.996] [t=0x0c88b029] ti.ipc.rpmsg.MessageQCopy: MessageQCopy_swiFxn:
[0][     52.996]        Received msg: from: 0x406, to: 0x3d, dataLen: 40
[0][     52.996] [t=0x0c8a8a87] ti.ipc.rpmsg.MessageQCopy: MessageQCopy_send: calling c
allback with data len: 40, from: 1030
[0][     52.996]
[0][     52.996] Received msg from (procId:remoteQueueId): 0x0:0x1
[0][     52.996]        payload: 8 bytes; loops: 10 with printing.
[0][     52.997] [t=0x0c8eab7e] ti.ipc.rpmsg.MessageQCopy: callback_availBufReady: virt
Queue_fromHost kicked
[0][     52.997] [t=0x0c9031bc] ti.ipc.rpmsg.MessageQCopy: MessageQCopy_swiFxn:
[0][     52.997]        Received msg: from: 0x406, to: 0x3d, dataLen: 40
[0][     52.997] [t=0x0c9208fa] ti.ipc.rpmsg.MessageQCopy: MessageQCopy_send: calling c
allback with data len: 40, from: 1030
[0][     52.997]
[0][     52.997] Got msg #0 (40 bytes) from procId 0
[0][     52.997] Sending msg Id #0 to procId 0
[0][     52.998] [t=0x0c959f33] ti.ipc.rpmsg.MessageQCopy: callback_availBufReady: virt
Queue_fromHost kicked
[0][     52.998] [t=0x0c971df7] ti.ipc.rpmsg.MessageQCopy: MessageQCopy_swiFxn:
[0][     52.998]        Received msg: from: 0x406, to: 0x3d, dataLen: 40
[0][     52.998] [t=0x0c98f3e7] ti.ipc.rpmsg.MessageQCopy: MessageQCopy_send: calling c
allback with data len: 40, from: 1030
[0][     52.998]
[0][     52.999] Got msg #1 (40 bytes) from procId 0
[0][     52.999] Sending msg Id #1 to procId 0
[0][     52.999] [t=0x0c9c7a00] ti.ipc.rpmsg.MessageQCopy: callback_availBufReady: virt
Queue_fromHost kicked
[0][     52.999] [t=0x0c9df7fc] ti.ipc.rpmsg.MessageQCopy: MessageQCopy_swiFxn:
[0][     52.999]        Received msg: from: 0x406, to: 0x3d, dataLen: 40
[0][     52.999] [t=0x0c9fce5a] ti.ipc.rpmsg.MessageQCopy: MessageQCopy_send: calling c
allback with data len: 40, from: 1030
[0][     52.999]
[0][     53.000] Got msg #2 (40 bytes) from procId 0
[0][     53.000] Sending msg Id #2 to procId 0
[0][     53.000] [t=0x0ca36e79] ti.ipc.rpmsg.MessageQCopy: callback_availBufReady: virt
Queue_fromHost kicked
[0][     53.000] [t=0x0ca4ea95] ti.ipc.rpmsg.MessageQCopy: MessageQCopy_swiFxn:
[0][     53.000]        Received msg: from: 0x406, to: 0x3d, dataLen: 40
[0][     53.001] [t=0x0ca6c975] ti.ipc.rpmsg.MessageQCopy: MessageQCopy_send: calling c
allback with data len: 40, from: 1030
[0][     53.001]
[0][     53.001] Got msg #3 (40 bytes) from procId 0
[0][     53.001] Sending msg Id #3 to procId 0
...
...
[0][     53.007] Got msg #8 (40 bytes) from procId 0
[0][     53.007] Sending msg Id #8 to procId 0
[0][     53.007] [t=0x0cccd3d7] ti.ipc.rpmsg.MessageQCopy: callback_availBufReady: virt
Queue_fromHost kicked
[0][     53.007] [t=0x0cce50ed] ti.ipc.rpmsg.MessageQCopy: MessageQCopy_swiFxn:
[0][     53.007]        Received msg: from: 0x406, to: 0x3d, dataLen: 40
[0][     53.007] [t=0x0cd027bd] ti.ipc.rpmsg.MessageQCopy: MessageQCopy_send: calling c
allback with data len: 40, from: 1030
[0][     53.007]
[0][     53.008] Got msg #9 (40 bytes) from procId 0
[0][     53.008] Sending msg Id #9 to procId 0
[0][     53.008] Awaiting sync message from host...
</pre></div>
</div>
</div>
<div class="section" id="running-standalone-examples">
<h5>4.4.2.3.4.5. Running standalone examples<a class="headerlink" href="#running-standalone-examples" title="Permalink to this headline">¶</a></h5>
<p>On some platforms, there are standalone examples provided to illustrate
how to use specific features in IPC. These standalone examples are
designed to be easily rebuilt outside of the IPC product, and represent
a good starting point for development. If available, the examples are
located in &lt;IPC_INSTALL_DIR&gt;examplesarchive&lt;platform of your choice&gt;.</p>
<p>To use the examples, unzip the example you want in a working directory
of your choice. Update the products.mak file in the example’s directory
with the installation locations of the various dependent components.
Then build it. E.g.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>buildhost$ unzip ex02_messageq.zip
buildhost$ cd ex02_messageq
buildhost$ make clean
buildhost$ make
buildhost$ make install
</pre></div>
</div>
<p>This would produce the host and remote core binaries in an ‘install’
subdirectory. <strong>Tip</strong>: Alternatively, for convenience, you can also
extract and rebuild all examples available for your platform at once
with this series of commands:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>buildhost$ cd &lt;IPC_INSTALL_DIR&gt;/examples
buildhost$ make extract
buildhost$ make
buildhost$ make install
</pre></div>
</div>
<p>Next step is to copy the content of the ‘install’ subdirectory into a
location accessible by your target board (e.g. SD card). Run the example
on the target using IPC by loading the remote cores like you would with
the test applications, then run the example. E.g.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target# ipc IPU ex02_messageq/debug/server_ipu.xem4 DSP ex02_messageq/debug/server_dsp.xe64T
target# cd ex02_messageq/debug/
target# app_host IPU
</pre></div>
</div>
</div>
<div class="section" id="advanced-topics">
<h5>4.4.2.3.4.6. Advanced topics<a class="headerlink" href="#advanced-topics" title="Permalink to this headline">¶</a></h5>
<div class="section" id="load-and-unload-individual-cores-while-ipc-is-running-ipc-3-23-01-and-above">
<h6>4.4.2.3.4.6.1. Load and unload individual cores while IPC is running (IPC 3.23.01 and above)<a class="headerlink" href="#load-and-unload-individual-cores-while-ipc-is-running-ipc-3-23-01-and-above" title="Permalink to this headline">¶</a></h6>
<p>In some applications, there may be a need to load or unload cores after
the IPC resource manager is already up and running – e.g. change the
DSP executable while keeping the IPU running.</p>
<p>In order to load and start a core with an executable, you can do the
following after having launched the resource manager:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target# echo &lt;slave executable file path&gt; &gt; /dev/ipc-file/&lt;core name&gt;
target# echo 1 &gt; /dev/ipc-state/&lt;core name&gt;
</pre></div>
</div>
<p>The first command sets the filename of an executable to be loaded, and
the second command loads and starts the core with that executable.</p>
<p>To stop and unload a core, use the following command:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target# echo 0 &gt; /dev/ipc-state/&lt;core name&gt;
</pre></div>
</div>
<p>Keep in mind that this simply puts the core into reset. If there is any
on-going communication between the given core and the others, it is the
responsibility of the user application to clean up and terminate IPC on
the slave before unloading a core, thus to avoid causing any memory
leaks or communication errors.</p>
</div>
<div class="section" id="inspect-the-state-of-a-slave-core-ipc-3-23-01-and-above">
<h6>4.4.2.3.4.6.2. Inspect the state of a slave core (IPC 3.23.01 and above)<a class="headerlink" href="#inspect-the-state-of-a-slave-core-ipc-3-23-01-and-above" title="Permalink to this headline">¶</a></h6>
<p>To find out the state of a slave core (whether it is running or in
reset), issue the following command:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target# cat /dev/ipc-state/&lt;core name&gt;
</pre></div>
</div>
</div>
<div class="section" id="tracing">
<h6>4.4.2.3.4.6.3. Tracing<a class="headerlink" href="#tracing" title="Permalink to this headline">¶</a></h6>
<p>When an issue arises, sometimes it is useful to see the output of
internal traces from IPC. This section talks about how to view IPC trace
from both the host and the slave cores on the QNX command prompt.</p>
<p class="rubric" id="host-side-trace-output">Host-side trace output</p>
<p class="rubric" id="trace-from-ipc-user-libraries-ipc-3-35-and-above">Trace from IPC user libraries (IPC 3.35 and above)</p>
<p>Trace output from the IPC user libraries is controlled using the
environment variable <em>IPC_DEBUG</em>, when launching an application that
uses IPC. E.g.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target# IPC_DEBUG=&lt;level&gt; app_host
</pre></div>
</div>
<p>where &lt;level&gt; can be set to a value between 1 and 3, with 3 being the
most verbose.</p>
<p class="rubric" id="trace-from-ipc-resource-manager-ipc-3-35-and-above">Trace from IPC resource manager (IPC 3.35 and above)</p>
<p>To show the trace output of the IPC resource manager in the QNX system
log, run the following command:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target# sloginfo -m42
</pre></div>
</div>
<p>The verbosity of the trace can be controlled using the environment
variable <em>IPC_DEBUG_SLOG_LEVEL</em> when launching the IPC resource manager.
E.g.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target# IPC_DEBUG_SLOG_LEVEL=&lt;level&gt; ipc DSP1 ex02_messageq/debug/server_dsp1.xe66
</pre></div>
</div>
<p>where &lt;level&gt; can be set to a value between 0 and 7, with 7 being the
most verbose. The default level is 2.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p class="rubric" id="slave-side-trace-output">Slave-side trace output</p>
<p>To show all trace output (including IPC’s) on a given slave core, simply
run the following</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target# cat /dev/ipc-trace/&lt;core name&gt;
</pre></div>
</div>
<p>where &lt;core name&gt; corresponds to the name of the slave core which trace
output you are interested in (e.g. DSP1, IPU1 or IPU2 for DRA7xx)</p>
<p>Note that older versions of IPC may use a slightly different path that
is based on the MultiProc id of the core of interest:
/dev/ipc-trace&lt;id&gt;.</p>
</div>
<div class="section" id="building-the-ipc-resource-manager-in-debug-mode-ipc-3-35-and-above">
<h6>4.4.2.3.4.6.4. Building the IPC resource manager in debug mode (IPC 3.35 and above)<a class="headerlink" href="#building-the-ipc-resource-manager-in-debug-mode-ipc-3-35-and-above" title="Permalink to this headline">¶</a></h6>
<p>When debugging an issue, the user may wish to have the ability to step
through the source code in the IPC resource manager. For this to happen,
the IPC resource manager needs to be built in debug mode with debug
symbols. Adding IPC_DEBUG=1 to the file &lt;IPC_INSTALL_DIR&gt;/qnx/Makefile
and rebuilding IPC would do the trick:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>ipc3x_dev: utils
    @cd src/ipc3x_dev; \
        make IPC_PLATFORM=$(IPC_PLATFORM) SMP=1 QNX_CFLAGS=$(QNX_CFLAGS) IPC_DEBUG=1
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target# make -f ipc-qnx.mak clean
target# make -f ipc-qnx.mak all
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id17">
<h4>4.4.2.3.5. See Also<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><a class="reference external" href="index_Foundational_Components.html#ipc-3-x">IPC 3.x</a></p></li>
<li><p><a class="reference external" href="index_Foundational_Components.html#ipc-user-guide">IPC Users Guide</a></p></li>
<li><p><a class="reference external" href="index_Foundational_Components.html#ipc-faq">IPC 3.x FAQ</a></p></li>
<li><p><a class="reference external" href="index_Foundational_Components.html#linux-install-guide">IPC Install Guide Linux</a></p></li>
<li><p><a class="reference external" href="index_Foundational_Components.html#bios-install-guide">IPC Install Guide BIOS</a></p></li>
</ul>
</div>
</div>
</div>
<div class="section" id="porting-ipc">
<h2>4.4.3. Porting IPC<a class="headerlink" href="#porting-ipc" title="Permalink to this headline">¶</a></h2>
<div class="section" id="interfaces-to-implement">
<h3>4.4.3.1. Interfaces to Implement<a class="headerlink" href="#interfaces-to-implement" title="Permalink to this headline">¶</a></h3>
<p>When porting IPC to new devices, you may need to create custom
implementations of the following interfaces. You may find that the
provided implementations of these interfaces meet your needs, so don’t
assume that you will need to create custom implementation in all cases.</p>
<ul class="simple">
<li><p>“IInterrupt”? for use by Notify. The interface definition is in
ti.sdo.ipc.notifyDrivers.IInterrupt.</p></li>
<li><p>“IGateMPSupport”? for use by GateMP. The interface definition is in
ti.sdo.ipc.interfaces.IGateMPSupport.</p></li>
<li><p>“IMessageQTransport”? and “ITransportSetup”? for use by MessageQ.
Interface definitions are in ti.sdo.ipc.interfaces.IMessageQTransport
and ti.sdo.ipc.interfaces.ITransportSetup.</p></li>
<li><p>“INotifyDriver”? for use by Notify. The interface definition is in
ti.sdo.ipc.interfaces.INotifyDriver.</p></li>
<li><p>“INotifySetup”? module, which defines interrupt mappings, for use by
Notify. The interface definition is in
ti.sdo.ipc.interfaces.INotifySetup.</p></li>
</ul>
<p>For details about the interfaces, see the IPC online documentation.</p>
</div>
<div class="section" id="other-porting-tasks">
<h3>4.4.3.2. Other Porting Tasks<a class="headerlink" href="#other-porting-tasks" title="Permalink to this headline">¶</a></h3>
<p>You will likely need to specify custom shared region(s) in your
configuration file. For details, see <a class="reference external" href="index_Foundational_Components.html#shared-region-module">SharedRegion
Module</a>.</p>
<p>Optionally, you may implement custom Heaps and hardware-specific
versions of other IPC modules.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="optimizing-ipc-applications">
<h2>4.4.4. Optimizing IPC Applications<a class="headerlink" href="#optimizing-ipc-applications" title="Permalink to this headline">¶</a></h2>
<div class="section" id="compiler-and-linker-optimization">
<h3>4.4.4.1. Compiler and Linker Optimization<a class="headerlink" href="#compiler-and-linker-optimization" title="Permalink to this headline">¶</a></h3>
<p>You can optimize your application for better performance and code size
or to give you more debugging information by selecting different ways of
compiling and linking your application. For example, you can do this by
linking with versions of the SYS/BIOS and IPC libraries that were
compiled differently.</p>
<p>The choices you can make related to compiler and linker optimization are
located in the following places:</p>
<ul class="simple">
<li><p><strong>RTSC Build-Profile.</strong> You see this field when you are creating a
new CCS project or modifying the CCS Build settings. We recommend
that you use the “release” setting. The “release” option is preferred
even when you are creating and debugging an application; the “debug”
option is mainly intended for internal use by Texas Instruments. The
“release” option results in a somewhat smaller executable that can
still be debugged. This build profile primarily affects how Codec
Engine and some device drivers are built.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The “whole_program” and “whole_program_debug” options for the RTSC
Build-Profile have been deprecated, and are no longer recommended.
The option that provides the most similar result is to set the
BIOS.libType configuration property to BIOS.LibType_Custom.</p>
</div>
<ul class="simple">
<li><p><strong>CCS Build Configuration.</strong> This setting in the CCS Build settings
allows you to choose between and customize multiple build
configurations. Each configuration can have the compiler and linker
settings you choose.</p></li>
<li><p><strong>BIOS.libType configuration property.</strong> You can set this property in
XGCONF or by editing the .cfg file in your project. This property
lets you select from two pre-compiled versions of the SYS/BIOS and
IPC libraries or to have a custom version of the SYS/BIOS and IPC
libraries compiled based on the needs of your application. See the
table and discussion that follow for more information.</p></li>
</ul>
<p>The options for the BIOS.libType configuration property are as follows:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>BIOS.libTyp
e</p></th>
<th class="head"><p>Compile
Time</p></th>
<th class="head"><p>Logging</p></th>
<th class="head"><p>Code Size</p></th>
<th class="head"><p>Run-Time
Performance</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Instrumente
d
(BIOS.LibTy
pe_Instrume
nted)</p></td>
<td><p>Fast</p></td>
<td><p>On</p></td>
<td><p>Good</p></td>
<td><p>Good</p></td>
</tr>
<tr class="row-odd"><td><p>Non-Instrum
ented
(BIOS.LibTy
pe_NonInstr
umented)</p></td>
<td><p>Fast</p></td>
<td><p>Off</p></td>
<td><p>Better</p></td>
<td><p>Better</p></td>
</tr>
<tr class="row-even"><td><p>Custom
(BIOS.LibTy
pe_Custom)</p></td>
<td><p>Fast (slow
first time)</p></td>
<td><p>As
configured</p></td>
<td><p>Best</p></td>
<td><p>Best</p></td>
</tr>
<tr class="row-odd"><td><p>Debug
(BIOS.LibTy
pe_Debug)</p></td>
<td><p>Slower</p></td>
<td><p>As
configured</p></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li><p><strong>Instrumented.</strong> (default) This option links with pre-built SYS/BIOS
(and IPC) libraries that have instrumentation available. All Asserts
and Diags settings are checked. Your configuration file can enable or
disable various Diags and logging related settings. However, note
that the checks to see if Diags are enabled before outputting a Log
event are always performed, which has an impact on performance even
if you use the ALWAYS_ON or ALWAYS_OFF setting. The resulting code
size when using this option may be too large to fit on some targets,
such as C28x and MSP430. This option is easy to use and debug and
provides a fast build time.</p></li>
<li><p><strong>Non-Instrumented.</strong> This option links with pre-built SYS/BIOS (and
IPC) libraries that have instrumentation turned off. No Assert or
Diag settings are checked, and logging information is not available
at run-time. The checking for Asserts and Diags is compiled out of
the libraries, so run-time performance and code size are optimized.
Checking of Error_Blocks and handling errors in ways other than
logging an event are still supported. This option is easy to use and
provides a fast build time.</p></li>
<li><p><strong>Custom.</strong> This option builds custom versions of the SYS/BIOS (and
IPC) libraries that contain the modules and APIs that your
application needs to access. If you have not used a particular module
in your .cfg file or your C code (and it is not required internally
by a SYS/BIOS module that is used), that module is not contained in
the custom libraries compiled for your application. This option
provides the best run-time performance and best code size given the
needs of your application. Instrumentation is available to whatever
extent your application configures it.</p>
<p>The first time you build a project with the custom libType, the build
will be longer. The custom libraries are stored in the “src”
directory of your project. Subsequent builds may be faster; libraries
do not need to be rebuilt unless you change one of the few
configuration properties that affect the build settings, or you use
an additional module that wasn’t already used in the previous
configuration.:</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you disable SYS/BIOS Task or Swi scheduling, you must use the
“custom” option in order to successfully link your application.</p>
<p>The custom option uses program optimization that removes many
initialized constants and small code fragments (often “glue” code)
from the final executable image. Such classic optimizations as
constant folding and function inlining are used, including across
module boundaries. The custom build preserves enough debug
information to make it still possible to step through the optimized
code in CCS and locate global variables.:</p>
</div>
<ul class="simple">
<li><p><strong>Debug.</strong> This option is not recommended; it is intended for
internal use by Texas Instruments developers.</p></li>
</ul>
<p>The following example statements set the BIOS.libType configuration
property:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>var BIOS = xdc.useModule(&#39;ti.sysbios.BIOS&#39;);
BIOS.libType = BIOS.LibType_Custom;
</pre></div>
</div>
<p>If you use the custom option for the BIOS.libType, you can also set the
BIOS.customCCOpts property to customize the C compiler command-line
options used when compiling the SYS/BIOS libraries. If you want to
change this property, it is important to first examine and understand
the default command-line options used to compile the SYS/BIOS libraries
for your target. You can see the default in XGCONF or by placing the
following statement in your configuration script and building the
project:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">print</span><span class="p">(</span><span class="s">&quot;customCCOpts =&quot;</span><span class="p">,</span> <span class="n">BIOS</span><span class="p">.</span><span class="n">customCCOpts</span><span class="p">);</span>
</pre></div>
</div>
<p>Be careful not to cause problems for the SYS/BIOS compilation when you
modify this property. For example, the –program_level_compile option is
required. (Some –define and –include_path options are used on the
compiler command line but are not listed in the customCCOpts definition;
these also cannot be removed.)
For example, to create a debuggable custom library, you can remove the
-o3 option from the BIOS.customCCOpts definition by specifying it with
the following string for a C64x+ target:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">BIOS</span><span class="p">.</span><span class="n">customCCOpts</span> <span class="o">=</span> <span class="s">&quot;-mv64p --abi=eabi -q -mi10 -mo -pdr -pden -pds=238 -pds=880</span>
  <span class="o">-</span><span class="n">pds1110</span>  <span class="o">--</span><span class="n">embed_inline_assembly</span> <span class="o">--</span><span class="n">program_level_compile</span> <span class="o">-</span><span class="n">g</span><span class="s">&quot;;</span>
</pre></div>
</div>
</div>
<div class="section" id="optimizing-runtime-performance">
<h3>4.4.4.2. Optimizing Runtime Performance<a class="headerlink" href="#optimizing-runtime-performance" title="Permalink to this headline">¶</a></h3>
<p>You can use one or more of the following techniques to improve the
runtime performance of IPC applications:</p>
<ul class="simple">
<li><p>After you have finished debugging an application, you can disable
asserts and logging with the following configuration statements:</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>var Diags = xdc.useModule(&quot;xdc.runtime.Diags&quot;);
var Defaults = xdc.useModule(&#39;xdc.runtime.Defaults&#39;);
Defaults.common$.diags_ASSERT = Diags.ALWAYS_OFF;
Defaults.common$.logger = null;
</pre></div>
</div>
<ul class="simple">
<li><p>If shared memory has the same address on all processors, you can use
the following configuration statement to set the
SharedRegion.translate property to false. See <a class="reference external" href="index_Foundational_Components.html#shared-region-module">SharedRegion
Module</a> for more
about SharedRegion configuration.</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">SharedRegion</span><span class="p">.</span><span class="n">translate</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Ensure that code, data, and shared data are all placed in cacheable
memory. Refer to the SYS/BIOS documentation for information on how to
configure a cache. See the <em>TI SYS/BIOS Real-time</em> <em>Operating System
v6.x User’s Guide</em> (<a class="reference external" href="http://www.ti.com/lit/pdf/SPRUEX3">SPRUEX3</a>)
for details.</p></li>
<li><p>You can reduce contention between multiple processors and multiple
threads by creating a new gate for use by a new IPC module instance.
Leaving the params.gate property set to NULL causes the default
system GateMP instance to be used for context protection. However, in
some cases it may be optimal to create a new GateMP instance and
supply it to the instance creation. See <a class="reference external" href="index_Foundational_Components.html#gatemp-module">GateMP
Module</a> for more
information. For example:</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">GateMP_Params</span> <span class="n">gateParams</span><span class="p">;</span>
<span class="n">GateMP_Handle</span> <span class="n">gateHandle</span><span class="p">;</span>
<span class="n">HeapBufMP_Params</span> <span class="n">heapParams</span><span class="p">;</span>

<span class="n">GateMP_Params_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gateParams</span><span class="p">);</span>
<span class="n">gateHandle</span> <span class="o">=</span> <span class="n">GateMP_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gateParams</span><span class="p">);</span>

<span class="n">HeapBufMP_Params_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heapParams</span><span class="p">);</span>
<span class="n">heapParams</span><span class="p">.</span><span class="n">gate</span> <span class="o">=</span> <span class="n">gateHandle</span><span class="p">;</span>
</pre></div>
</div>
<ul>
<li><p>If a unicache is shared between two cores in shared memory and you
expect to share certain IPC instances (such as a GateMP or ListMP)
solely between those two cores, you may be able to improve
performance by creating a SharedRegion with cache disabled for use
between those two cores only. Since region 0 needs to be accessible
by all cores on a system, region 1 can be created with a cache line
size of 0 and a cacheEnable configuration of FALSE. Any IPC instance
created within a SharedRegion inherits the cache settings (the
cacheEnabled flag and the cacheLineSize) from this region. Therefore,
unnecessary cache operations can be avoided by creating an instance
in region 1.</p>
<p>The following configuration statements create a SharedRegion with the
cache disabled (on OMAP4430):</p>
</li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>    <span class="n">SharedRegion</span><span class="p">.</span><span class="n">setEntryMeta</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="cm">/* Create shared region 1 */</span>
        <span class="p">{</span>   <span class="nl">base</span><span class="p">:</span> <span class="mh">0x86000000</span><span class="p">,</span>
            <span class="nl">len</span><span class="p">:</span> <span class="mh">0x10000</span><span class="p">,</span>
            <span class="nl">ownerProcId</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="nl">isValid</span><span class="p">:</span> <span class="nb">true</span><span class="p">,</span>
            <span class="nl">cacheEnabled</span><span class="p">:</span> <span class="nb">false</span><span class="p">,</span> <span class="cm">/* Cache operations unneeded */</span>
            <span class="nl">cacheLineSize</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* Cache padding unneeded */</span>
            <span class="nl">name</span><span class="p">:</span> <span class="s">&quot;DDR2&quot;</span><span class="p">,</span>
        <span class="p">});</span>


<span class="n">The</span> <span class="n">following</span> <span class="n">C</span> <span class="n">code</span> <span class="n">creates</span> <span class="n">a</span> <span class="n">HeapBufMP</span> <span class="n">instance</span> <span class="n">in</span> <span class="k">this</span>
<span class="n">SharedRegion</span><span class="o">::</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>    <span class="n">HeapBufMP_Params</span> <span class="n">heapParams</span><span class="p">;</span>
    <span class="n">HeapBufMP_Handle</span> <span class="n">heapHandle</span><span class="p">;</span>

    <span class="n">HeapBufMP_Params_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heapParams</span><span class="p">);</span>
    <span class="n">heapParams</span><span class="p">.</span><span class="n">regionId</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">heapHandle</span> <span class="o">=</span> <span class="n">HeapBufMP_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heapParams</span><span class="p">);</span>

<span class="n">This</span> <span class="n">heap</span> <span class="n">can</span> <span class="n">be</span> <span class="n">used</span> <span class="n">by</span> <span class="n">either</span> <span class="n">of</span> <span class="n">the</span> <span class="n">Cortex</span> <span class="n">M3</span> <span class="n">cores</span> <span class="n">on</span> <span class="n">an</span>
<span class="n">OMAP4430</span><span class="p">,</span> <span class="n">because</span> <span class="n">they</span> <span class="n">both</span> <span class="n">share</span> <span class="n">a</span> <span class="n">unicache</span><span class="p">.</span> <span class="n">Do</span> <span class="n">not</span> <span class="n">use</span> <span class="k">this</span> <span class="n">heap</span>
<span class="p">(</span><span class="n">or</span> <span class="n">anything</span> <span class="k">else</span> <span class="n">belonging</span> <span class="n">to</span> <span class="n">a</span> <span class="n">SharedRegion</span> <span class="n">with</span> <span class="n">caching</span> <span class="n">disabled</span><span class="p">)</span>
<span class="n">from</span> <span class="n">any</span> <span class="n">other</span> <span class="n">processor</span> <span class="k">if</span> <span class="n">the</span> <span class="n">shared</span> <span class="n">memory</span> <span class="n">belonging</span> <span class="n">to</span> <span class="n">the</span>
<span class="n">SharedRegion</span> <span class="n">is</span> <span class="n">cacheable</span><span class="p">.</span>
</pre></div>
</div>
</div>
<div class="section" id="optimizing-notify-and-messageq-latency">
<h3>4.4.4.3. Optimizing Notify and MessageQ Latency<a class="headerlink" href="#optimizing-notify-and-messageq-latency" title="Permalink to this headline">¶</a></h3>
<p>By default, IPC applications are configured to use the
ti.sdo.ipc.notifyDrivers.NotifyDriverShm Notify driver and the
ti.sdo.ipc.transports.TransportShm MessageQ transport. These modules are
used by default because they offer backward compatibility with older
IPC/SysLink releases. In addition, these modules may offer functionality
not supported by their newer, lower-latency counterparts.</p>
<p>If your application does not need functionality provided only by the
default Notify drivers or MessageQ transport, you can reduce the latency
by switching to alternative MessageQ transports and/or Notify drivers.</p>
</div>
<div class="section" id="choosing-and-configuring-notify-drivers">
<h3>4.4.4.4. Choosing and Configuring Notify Drivers<a class="headerlink" href="#choosing-and-configuring-notify-drivers" title="Permalink to this headline">¶</a></h3>
<p>To switch to a different Notify driver, set the Notify.SetupProxy
configuration to the family-specific Notify setup module. For example,
the following statements configure an application on the DM6446 to use
the NotifyDriverCirc driver for that device:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>var Notify = xdc.useModule(&#39;ti.sdo.ipc.Notify&#39;);
Notify.SetupProxy = xdc.useModule(&#39;ti.sdo.ipc.family.dm6446.NotifyCircSetup&#39;);
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>IPC provides the following Notify drivers. Each has a corresponding
setup module that should be used as the Notify.SetupProxy module.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 51%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Modules and
Description</p></th>
<th class="head"><p>Supports Disabling
and Enabling Events</p></th>
<th class="head"><p>Latency</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ti.sdo.ipc.notifyDrivers.NotifyDriverShm
ti.sdo.ipc.family.&lt;family&gt;.NotifySetup</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>This shared-memory Notify driver offers
room for a single pending notification
in shared memory per event.</p>
</td>
<td><p>Yes</p></td>
<td><p>Default</p></td>
</tr>
<tr class="row-odd"><td><p>ti.sdo.ipc.notifyDrivers.NotifyDriverCirc
ti.sdo.ipc.family.&lt;family&gt;.NotifyCircSetup</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>This shared-memory
Notify driver uses a
circular buffer to
store notifications.
Unlike
NotifyDriverShm, this
driver stores all
notifications in the
same circular buffer
(whose size is
configurable).</p>
</td>
<td><p>No</p></td>
<td><p>Better than
NotifyDriverShm</p></td>
</tr>
<tr class="row-even"><td><p>ti.sdo.ipc.family.ti8
1xx.<strong>NotifyDriverM
bx</strong>
ti.sdo.ipc.family.ti8
1xx.NotifyMbxSetup</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>This TI81xx-only
Notify driver uses
the hardware mailbox.
This driver is not
usable by other
devices.
Notifications are
stored in hardware
mailbox queues
present on TI81xx
devices.</p>
</td>
<td><p>No</p></td>
<td><p>Better than
NotifyDriverCirc and
NotifyDriverShm</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="choosing-and-configuring-messageq-transports">
<h3>4.4.4.5. Choosing and Configuring MessageQ Transports<a class="headerlink" href="#choosing-and-configuring-messageq-transports" title="Permalink to this headline">¶</a></h3>
<p>Similarly, to use an alternative MessageQ transport, configure the
MessageQ.SetupTransportProxy property to use the transport’s
corresponding Transport Setup proxy. For example, to use the
TransportShmNotify module, use the following configuration:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>var MessageQ = xdc.module(&#39;ti.sdo.ipc.MessageQ&#39;);
MessageQ.SetupTransportProxy =
      xdc.module(&#39;ti.sdo.ipc.transports.TransportShmNotifySetup&#39;);
</pre></div>
</div>
<p>Unlike the Notify setup modules, Transport setup modules are generally
not family-specific; most are located in the ti.sdo.ipc.transports
package.
IPC provides the following transports. Each has a corresponding setup
module for use as the MessageQ.SetupTransportProxy module.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Modules and Description</p></th>
<th class="head"><p>Transport Speed</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ti.sdo.ipc.transports.<strong>Transpo
rtShm</strong>
ti.sdo.ipc.transports.TransportSh
mSetup</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>This shared-memory MessageQ
transport uses ListMP to
temporarily queue messages in
shared memory before the messages
are moved to the destination
queue. This transport is
typically slowest because of the
overhead of queuing messages
using a linked list. This is the
default MessageQ transport.</p>
</td>
<td><p>Slowest</p></td>
</tr>
<tr class="row-odd"><td><p>ti.sdo.ipc.transports.<strong>Transpo
rtShmCirc</strong>
ti.sdo.ipc.transports.TransportSh
mCircSetup</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>This shared-memory MessageQ
transport uses a fixed-length
circular buffer to temporarily
queue messages in shared memory
before the messages are moved to
the destination queue. This
transport is typically faster
than TransportShm because of the
efficiencies gained by using a
circular buffer instead of a
linked list.</p>
</td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p>ti.sdo.ipc.transports.<strong>Transpo
rtShmNotify</strong>
ti.sdo.ipc.transports.TransportSh
mNotifySetup</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>This shared-memory MessageQ
transport does no buffering
before the messages are moved to
the destination queue. Because of
the lack of buffering, this
transport tends to offer lower
MessageQ latency than either
TransportShm or TransportShm.
However, If messages aren’t
received quickly enough by the
receiver, the sender may spin
while waiting for the receiver to
move the message to its local
queue.</p>
</td>
<td><p>Fastest, but depends on fast
processing of messages by
receiver</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="optimizing-shared-memory-usage">
<h3>4.4.4.6. Optimizing Shared Memory Usage<a class="headerlink" href="#optimizing-shared-memory-usage" title="Permalink to this headline">¶</a></h3>
<p>You can use one or more of the following techniques to reduce the shared
memory footprint of IPC applications:</p>
<ul class="simple">
<li><p>If some connections between processors are not needed, it is not
necessary to attach to those cores. To selectively attach between
cores, use pair-wise synchronization as described in <a class="reference external" href="index_Foundational_Components.html#ipc-module">Ipc
Module</a>. Your C code must
call Ipc_attach() for processors you want to connect to if you are
using pair-wise synchronization. The following configuration
statement causes the Ipc module to expect pair-wise synchronization.</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ipc</span><span class="p">.</span><span class="n">procSync</span> <span class="o">=</span> <span class="n">Ipc</span><span class="p">.</span><span class="n">ProcSync_PAIR</span><span class="p">;</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>At run-time, only call Ipc_attach() to a remote processor if one or
more of the following conditions is true:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>-  The remote processor is the owner of region 0.
-  It is necessary to send Notifications between this processor and
   the remote processor.
-  It is necessary to send MessageQ messages between this processor
   and the remote processor.
-  It is necessary for either the local or remote processor to open a
   module instance using *MODULE*\ \_open() that has been created on
   the other processor.
</pre></div>
</div>
<ul class="simple">
<li><p>Configure the Ipc.setEntryMeta property to disable components of IPC
that are not required. For example, if an application uses Notify but
not MessageQ, disabling MessageQ avoids the creation of MessageQ
transports during Ipc_attach().</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* To avoid wasting shared mem for MessageQ transports */</span>
<span class="k">for</span> <span class="p">(</span><span class="n">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MultiProc</span><span class="p">.</span><span class="n">numProcessors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Ipc</span><span class="p">.</span><span class="n">setEntryMeta</span><span class="p">({</span>
        <span class="nl">remoteProcId</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nl">setupMessageQ</span><span class="p">:</span> <span class="nb">false</span><span class="p">,</span>
    <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<ul>
<li><p>Configure Notify.numEvents to a lower number. The default value of 32
is often significantly more than the total number of Notify events
required on a system. See <a class="reference external" href="index_Foundational_Components.html#notify-module">Notify
Module</a> for more
information.</p>
<p>For example, a simple MessageQ application may simply use two events
(one for NameServer and one for the MessageQ transport). In this
case, we can optimize memory use with the following configuration:</p>
</li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>var Notify = xdc.useModule(&#39;ti.sdo.ipc.Notify&#39;);

/* Reduce the total number of supported events from 32 to 2 */
Notify.numEvents = 2;

var NameServerRemoteNotify = xdc.useModule(&#39;ti.sdo.ipc.NameServerRemoteNotify&#39;);
NameServerRemoteNotify.notifyEventId = 1;

var TransportShm = xdc.useModule(&#39;ti.sdo.ipc.transports.TransportShm&#39;);
TransportShm.notifyEventId = 0;
</pre></div>
</div>
<ul>
<li><p>Reduce the cacheLineSize property of a SharedRegion to reflect the
actual size of the cache line. IPC uses the cacheLineSize setting to
pad data structures in shared memory. Padding is required so that
cache write-back and invalidate operations on data in shared memory
do not affect the cache status of adjacent data. The larger the
cacheLineSize setting, the more shared memory is used for the sole
purpose of padding. Therefore, the cacheLineSize setting should
optimally be set to the actual size of the cache line. The default
cacheLineSize for SharedRegion is 128. Using the correct size has
both performance and size benefits.</p>
<p>The following example (for C6472) sets the cacheLineSize property to
64 because the shared L2 memory has this cache line size.</p>
</li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">SharedRegion</span><span class="p">.</span><span class="n">setEntryMeta</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">{</span> <span class="nl">base</span><span class="p">:</span> <span class="n">SHAREDMEM</span><span class="p">,</span>
      <span class="nl">len</span><span class="p">:</span> <span class="n">SHAREDMEMSIZE</span><span class="p">,</span>
      <span class="nl">ownerProcId</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="nl">isValid</span><span class="p">:</span> <span class="nb">true</span><span class="p">,</span>
      <span class="nl">cacheLineSize</span><span class="p">:</span> <span class="mi">64</span><span class="p">,</span> <span class="cm">/* SL2 cache line size = 64 */</span>
      <span class="nl">name</span><span class="p">:</span> <span class="s">&quot;SL2_RAM&quot;</span><span class="p">,</span>
    <span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="optimizing-local-memory-usage">
<h3>4.4.4.7. Optimizing Local Memory Usage<a class="headerlink" href="#optimizing-local-memory-usage" title="Permalink to this headline">¶</a></h3>
<p>If the Custom1 and Custom2 GateMP proxies will never be used, make sure
they are both plugged with the ti.sdo.ipc.gates.GateMPSupportNull GateMP
delegate. By default, GateMP plugs the Custom1 proxy with the
GatePeterson delegate. A considerable amount of local memory is reserved
for use by GatePeterson. You can plug the Custom1 proxy with the
GateMPSupportNull delegate by adding the following configuration
statements to your application:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>var GateMP = xdc.useModule(&#39;ti.sdo.ipc.GateMP&#39;);
GateMP.RemoteCustom1Proxy = xdc.useModule(&#39;ti.sdo.ipc.gates.GateMPSupportNull&#39;);
</pre></div>
</div>
</div>
<div class="section" id="optimizing-code-size">
<h3>4.4.4.8. Optimizing Code Size<a class="headerlink" href="#optimizing-code-size" title="Permalink to this headline">¶</a></h3>
<p>This section provides tips and suggestions for minimizing the code size
of a SYS/BIOS-based application that uses IPC.</p>
<ul class="simple">
<li><p>For a number of ways to configure SYS/BIOS that reduce code size by
using custom built SYS/BIOS libraries and by disabling various
features, see Section E.3 of the <em>TI SYS/BIOS Real-time Operating</em>
<em>System v6.x User’s Guide</em>
(<a class="reference external" href="http://www.ti.com/lit/pdf/SPRUEX3">SPRUEX3</a>). In particular,
after you have debugged your code, disabling Asserts as follows helps
reduce the size of your code.</p></li>
</ul>
<dl class="simple">
<dt>::</dt><dd><p>var Defaults = xdc.useModule(‘xdc.runtime.Defaults’);
var Diags = xdc.useModule(‘xdc.runtimg.Diags’);
Defaults.common$.diags_ASSERT = Diags.ALWAYS_OFF;</p>
</dd>
</dl>
<ul class="simple">
<li><p>The NotifyDriverCirc notification driver and the TransportShmNotify
or TransportShmCirc MessageQ transports described in <strong>Optimizing IPC
Applications</strong> use less code space than the default Notify driver and
MessageQ transport.</p></li>
<li><p>You can reduce code size by not using the HeapBufMP Heap
implementation. Since IPC uses the HeapMemMP implementation
internally, using HeapMemMP in your application does not increase the
code size. However, you should be aware that, depending on how your
application uses heaps, HeapMemMP may lead to problems with heap
fragmentation. See <a class="reference external" href="index_Foundational_Components.html#heapmp-module">Heap*MP
Modules</a> for more about
Heap implementations.</p></li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="rebuilding-ipc">
<h2>4.4.5. Rebuilding IPC<a class="headerlink" href="#rebuilding-ipc" title="Permalink to this headline">¶</a></h2>
<p>This page describes how to rebuild the IPC source code.</p>
<p>The IPC product includes source files and build scripts that allow you to modify the IPC sources and rebuild its libraries. You can do this in order to modify, update, or add functionality. If you edit the IPC source code and/or corresponding build scripts, you must also rebuild IPC in order to create new libraries containing these modifications.</p>
<p>Note that you can cause the BIOS-side IPC (and BIOS) libraries to be rebuilt as part of the application build - this is called a ‘Custom Build’. The custom-built libraries will be stored with other output from executing your config script, and will contain only modules and APIs that your application needs to access. You can cause such a Custom Build to occur using the BIOS.libType config param as follows.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>var BIOS = xdc.useModule(&#39;ti.sysbios.BIOS&#39;);
BIOS.libType = BIOS.LibType_Custom;
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This page provides details about rebuilding the IPC source code. We strongly recommend that you copy the IPC installation to a directory with a different name and rebuild that copy, rather than rebuilding the original installation.</p>
</div>
<div class="section" id="build-procedure">
<h3>4.4.5.1. Build Procedure<a class="headerlink" href="#build-procedure" title="Permalink to this headline">¶</a></h3>
<p>The various IPC Install Guides describe the mechanics of rebuilding IPC
libraries. Please consult the Install Guide appropriate for your
environment.</p>
<ul class="simple">
<li><p><a class="reference external" href="index_Foundational_Components.html#bios-install-guide">IPC Install Guide BIOS</a> - for
all-BIOS environments</p></li>
<li><p><a class="reference external" href="index_Foundational_Components.html#linux-install-guide">IPC Install Guide Linux</a> -
for environments with a combination of Linux and BIOS</p></li>
<li><p><a class="reference external" href="index_Foundational_Components.html#qnx-install-guide">IPC Install Guide QNX</a> - for
environments with a combination of QNX and BIOS</p></li>
</ul>
</div>
<div class="section" id="pointing-a-ccs-project-at-a-rebuilt-ipc">
<h3>4.4.5.2. Pointing a CCS Project at a Rebuilt IPC<a class="headerlink" href="#pointing-a-ccs-project-at-a-rebuilt-ipc" title="Permalink to this headline">¶</a></h3>
<p>To build your application using the version of IPC you have rebuilt, you
must point your project to this rebuilt version by following these
steps:</p>
<ol class="arabic">
<li><p>Open CCS and select the application project you want to rebuild.</p></li>
<li><p>Right-click on your project and choose <strong>Build Properties</strong>. If you
have a configuration project that is separate from your application
project, open the build properties for the configuration project.</p></li>
<li><p>In the <strong>CCS Build</strong> category of the Properties dialog, choose the
<strong>RTSC</strong> tab.</p></li>
<li><p>Under the <strong>Products and Repositories</strong> tab, uncheck <em>all</em> the boxes
for IPC. This ensures that no version is selected.</p>
<img alt="../_images/Rebuild_deselect.png" src="../_images/Rebuild_deselect.png" />
</li>
<li><p>Click the <strong>Add</strong> button next to the <strong>Products and Repositories</strong>
tab.</p></li>
<li><p>Choose <strong>Select repository from file-system</strong>, and browse to the
“packages” directory of the location where you copied and rebuilt
IPC. For example, the location may be
C:myIpcBuildscustom_ipc_1_22_##-##packages.</p>
<img alt="../_images/Rebuild_addrep.png" src="../_images/Rebuild_addrep.png" />
</li>
<li><p>Click <strong>OK</strong> to apply these changes to the project.</p></li>
<li><p>You may now rebuild your project using the re-built version of IPC.</p></li>
</ol>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="ti-sdo-ipc-package">
<h2>4.4.6. TI SDO IPC Package<a class="headerlink" href="#ti-sdo-ipc-package" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id18">
<h3>4.4.6.1. Introduction<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
<p>This page introduces the modules in the ti.sdo.ipc package.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This package is not used on HLOS-based cores. Although this is a BIOS-only package,
note that the BIOS-side of a HLOS&lt;-&gt;BIOS IPC-using application will need to bring in a subset of these packages into the BIOS-side configuration scripts.</p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">ti.sdo.ipc</span></code> package contains the following modules that you may use in your applications:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 37%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Module</p></th>
<th class="head"><p>Module Path</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="index_Foundational_Components.html#gatemp-module">GateMP Module</a></p></td>
<td><p>GateMP</p></td>
<td><p>Manages gates for mutual
exclusion of shared resources
by multiple processors and
threads.
See <a class="reference external" href="index_Foundational_Components.html#gatemp-module">GateMP Module</a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="index_Foundational_Components.html#heapmp-module">HeapBufMP Module</a></p></td>
<td><p>ti.sdo.ipc.heaps.HeapBufMP</p></td>
<td><p>Fixed-sized shared memory
Heaps. Similar to SYS/BIOS’s
ti.sysbios.heaps.HeapBuf
module, but with some
configuration differences.
See <a class="reference external" href="index_Foundational_Components.html#heapmp-module">HeapMP Module</a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="index_Foundational_Components.html#heapmp-module">HeapMemMP Module</a></p></td>
<td><p>ti.sdo.ipc.heaps.HeapMemMP</p></td>
<td><p>Variable-sized shared memory
Heaps.
See <a class="reference external" href="index_Foundational_Components.html#heapmp-module">HeapMP Module</a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="index_Foundational_Components.html#heapmp-module">HeapMultiBufMP Module</a></p></td>
<td><p>ti.sdo.ipc.heaps.HeapMultiBufMP</p></td>
<td><p>Multiple fixed-sized shared
memory Heaps.
See <a class="reference external" href="index_Foundational_Components.html#heapmp-module">HeapMP Module</a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="index_Foundational_Components.html#ipc-module">Ipc Module</a></p></td>
<td><p>ti.sdo.ipc.Ipc</p></td>
<td><p>Provides Ipc_start() function
and allows startup sequence
configuration.
See <a class="reference external" href="index_Foundational_Components.html#ipc-module">IPC Module</a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="index_Foundational_Components.html#listmp-module">ListMP Module</a></p></td>
<td><p>ti.sdo.ipc.ListMP</p></td>
<td><p>Doubly-linked list for
shared-memory, multi-processor
applications. Very similar to
the ti.sdo.utils.List module.
See <a class="reference external" href="index_Foundational_Components.html#listmp-module">ListMP Module</a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="index_Foundational_Components.html#messageq-module">MessageQ Module</a></p></td>
<td><p>ti.sdo.ipc.MessageQ</p></td>
<td><p>Variable size messaging
module.
See <a class="reference external" href="index_Foundational_Components.html#messageq-module">MessageQ Module</a></p></td>
</tr>
<tr class="row-odd"><td><p>TransportShm</p></td>
<td><p>ti.sdo.ipc.transports.TransportShm</p></td>
<td><p>Transport used by MessageQ
for remote communication with
other processors via shared
memory.
See <a class="reference external" href="index_Foundational_Components.html#messageq-module">MessageQ Module</a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="index_Foundational_Components.html#notify-module">Notify Module</a></p></td>
<td><p>ti.sdo.ipc.Notify</p></td>
<td><p>Low-level interrupt
mux/demuxer module.
See <a class="reference external" href="index_Foundational_Components.html#notify-module">Notify Module</a></p></td>
</tr>
<tr class="row-odd"><td><p>NotifyDriverShm</p></td>
<td><p>ti.sdo.ipc.notifyDrivers.
NotifyDriverShm</p></td>
<td><p>Shared memory notification
driver used by the Notify
module to communicate between
a pair of processors.
See <a class="reference external" href="index_Foundational_Components.html#notify-module">Notify Module</a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="index_Foundational_Components.html#shared-region-module">SharedRegion Module</a></p></td>
<td><p>ti.sdo.ipc.SharedRegion</p></td>
<td><p>Maintains shared memory for
multiple shared regions.
See <a class="reference external" href="index_Foundational_Components.html#shared-region-module">SharedRegion Module</a></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Additional modules in the subfolders of the ti.sdo.ipc package contain specific implementations of gates,
heaps, notify drivers, transports, and various device family-specific modules.</p>
<p>In addition, the ti.sdo.ipc package defines the following interfaces that you may implement as your own custom modules:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 40%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Module</p></th>
<th class="head"><p>Module Path</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>IGateMPSupport</p></td>
<td><p>ti.sdo.ipc.interfaces.IGateMPSupport</p></td>
</tr>
<tr class="row-odd"><td><p>IInterrupt</p></td>
<td><p>ti.sdo.ipc.notifyDrivers.IInterrupt</p></td>
</tr>
<tr class="row-even"><td><p>IMessageQTransport</p></td>
<td><p>ti.sdo.ipc.interfaces.IMessageQTransport</p></td>
</tr>
<tr class="row-odd"><td><p>INotifyDriver</p></td>
<td><p>ti.sdo.ipc.interfaces.INotifyDriver</p></td>
</tr>
<tr class="row-even"><td><p>INotifySetup</p></td>
<td><p>ti.sdo.ipc.interfaces.INotifySetup</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">&lt;ipc_install_dir&gt;/packages/ti/sdo/ipc</span></code> directory contains the following packages that you may need to know about:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>examples.</strong> Contains examples.</p></li>
<li><p><strong>family.</strong> Contains device-specific support modules (used internally).</p></li>
<li><p><strong>gates.</strong> Contains GateMP implementations (used internally).</p></li>
<li><p><strong>heaps.</strong> Contains multiprocessor heaps.</p></li>
<li><p><strong>interfaces.</strong> Contains interfaces.</p></li>
<li><p><strong>notifyDrivers.</strong> Contains NotifyDriver implementations (used internally).</p></li>
<li><p><strong>transports.</strong> Contains MessageQ transport implementations that are used internally.</p></li>
</ul>
</div></blockquote>
<div class="section" id="including-header-files">
<h4>4.4.6.1.1. Including Header Files<a class="headerlink" href="#including-header-files" title="Permalink to this headline">¶</a></h4>
<p>BIOS applications that use modules in the ti.sdo.ipc or ti.sdo.utils
package should include the common header files provided in
<code class="docutils literal notranslate"><span class="pre">&lt;ipc_install_dir&gt;/packages/ti/ipc/</span></code>. These header files offer a
common API for both SYS/BIOS and HLOS users of IPC.</p>
<p>The following example C code includes header files applications may need
to use. Depending on the APIs used in your application code, you may
need to include different XDC, IPC, and SYS/BIOS header files.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;xdc/std.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>

<span class="cm">/* ---- XDC.RUNTIME module Headers   */</span>
<span class="cp">#include</span> <span class="cpf">&lt;xdc/runtime/Memory.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;xdc/runtime/System.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;xdc/runtime/IHeap.h&gt;</span><span class="cp"></span>

<span class="cm">/* ----- IPC module Headers          */</span>
<span class="cp">#include</span> <span class="cpf">&lt;ti/ipc/GateMP.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ti/ipc/Ipc.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ti/ipc/MessageQ.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ti/ipc/HeapBufMP.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ti/ipc/MultiProc.h&gt;</span><span class="cp"></span>

<span class="cm">/* ---- BIOS6 module Headers         */</span>
<span class="cp">#include</span> <span class="cpf">&lt;ti/sysbios/BIOS.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ti/sysbios/knl/Task.h&gt;</span><span class="cp"></span>

<span class="cm">/* ---- Get globals from .cfg Header */</span>
<span class="cp">#include</span> <span class="cpf">&lt;xdc/cfg/global.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>Note that the appropriate include file location has changed from
previous versions of IPC. The XDCtools-generated header files are still
available in <code class="docutils literal notranslate"><span class="pre">&lt;ipc_install_dir&gt;/packages/ti/sdo/ipc/</span></code>, but these
should not directly be included in runtime .c code.
You should search your applications for “ti/sdo/ipc” and “ti/sdo/utils”
and change the header file references found as needed. Additional
changes to API calls will be needed.</p>
<p><a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/files.html"><img alt="ipcSdoRun_Img1" src="../_images/Book_run.png" /></a> Documentation for all common-header APIs is provided in Doxygen format
in your IPC installation at
<code class="docutils literal notranslate"><span class="pre">&lt;ipc_install_dir&gt;/docs/doxygen/html/index.html</span></code>. The latest version
of that documentation is available
<a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/files.html">online</a>.</p>
</div>
<div class="section" id="standard-ipc-function-call-sequence">
<h4>4.4.6.1.2. Standard IPC Function Call Sequence<a class="headerlink" href="#standard-ipc-function-call-sequence" title="Permalink to this headline">¶</a></h4>
<p>For instance-based modules in IPC, the standard IPC methodology when
creating object dynamically (that is, in C code) is to have the creator
thread first initialize a <em>MODULE</em>_Params structure to its default
values via a <em>MODULE</em>_Params_init() function. The creator thread can
then set individual parameter fields in this structure as needed. After
setting up the <em>MODULE</em>_Params structure, the creator thread calls
the <em>MODULE</em>_create() function to creates the instance and
initializes any shared memory used by the instance. If the instance is
to be opened remotely, a unique name must be supplied in the parameters.</p>
<p>Other threads can access this instance via the <em>MODULE_</em>open()
function, which returns a handle with access to the instance. The name
that was used for instance creation must be used in the
<em>MODULE</em>_open() function.</p>
<p>In most cases, MODULE_open() functions must be called in the context of
a Task. This is because the thread running the MODULE_open() function
needs to be able to block (to pend on a Semaphore in this case) while
waiting for the remote processor to respond. The response from the
remote processor triggers a hardware interrupt, which then posts a
Semaphore to allow to Task to resume execution. The exception to this
rule is that MODULE_open() functions do not need to be able to block
when opening an instance on the local processor.</p>
<p>When the threads have finished using an instance, all threads that
called <em>MODULE_</em>open() must call <em>MODULE</em>_close(). Then, the
thread that called <em>MODULE</em>_create() can call <em>MODULE</em>_delete() to
free the memory used by the instance.</p>
<p>Note that <em>all</em> threads that opened an instance must close that instance
before the thread that created it can delete it. Also, a thread that
calls <em>MODULE</em>_create() cannot call <em>MODULE</em>_close(). Likewise, a
thread that calls <em>MODULE_</em>open() cannot call <em>MODULE</em>_delete().</p>
</div>
<div class="section" id="error-handling-in-ipc">
<h4>4.4.6.1.3. Error Handling in IPC<a class="headerlink" href="#error-handling-in-ipc" title="Permalink to this headline">¶</a></h4>
<p>Many of the APIs provided by IPC return an integer as a status code.
Your application can test the status value returned against any of the
provided status constants. For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MessageQ_Msg</span>     <span class="n">msg</span><span class="p">;</span>
<span class="n">MessageQ_Handle</span>  <span class="n">messageQ</span><span class="p">;</span>
<span class="n">Int</span>              <span class="n">status</span><span class="p">;</span>

<span class="p">...</span>
<span class="n">status</span> <span class="o">=</span> <span class="n">MessageQ_get</span><span class="p">(</span><span class="n">messageQ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="n">MessageQ_FOREVER</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">System_abort</span><span class="p">(</span><span class="s">&quot;Should not happen</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>Status constants have the following format: <code class="docutils literal notranslate"><span class="pre">MODULE_[S|E]_CONDITION</span></code>.
For example, Ipc_S_SUCCESS, MessageQ_E_FAIL, and SharedRegion_E_MEMORY
are status codes that may be returned by functions in the corresponding
modules.
Success codes always have values greater or equal to zero. For example,
Ipc_S_SUCCESS=0 and Ipc_S_ALREADYSETUP=1; both are success codes.
Failure codes always have values less than zero. Therefore, the presence
of an error can be detected by simply checking whether the return value
is negative.</p>
<p>Other APIs provided by IPC return a handle to a created object. If the
handle is NULL, an error occurred when creating the object. For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">messageQ</span> <span class="o">=</span> <span class="n">MessageQ_create</span><span class="p">(</span><span class="n">DSP_MESSAGEQNAME</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">messageQ</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">System_abort</span><span class="p">(</span><span class="s">&quot;MessageQ_create failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Refer to the Doxygen documentation for status codes returned by IPC
functions.</p>
</div>
</div>
<div class="section" id="ipc-module">
<h3>4.4.6.2. IPC Module<a class="headerlink" href="#ipc-module" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" colspan="2"><p>API Reference Links</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/index.html#ti/sdo/ipc/Ipc.html"><img alt="ipcCfg_Ipc_Img1" src="../_images/Book_cfg.png" /></a></p></td>
<td><p><a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_ipc_8h.html"><img alt="ipcRun_Ipc_Img1" src="../_images/Book_run.png" /></a></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The main purpose of the Ipc module is to initialize the various subsystems of IPC. All applications that use IPC modules must call the Ipc_start() API, which does the following:</p>
<ul class="simple">
<li><p>Initializes a number of objects and modules used by IPC</p></li>
<li><p>Synchronizes multiple processors so they can boot in any order</p></li>
</ul>
<p>An application that uses IPC APIs–such as MessageQ–must include the Ipc module header file and call Ipc_start()
before any calls to IPC modules. Here is a BIOS-side example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>   <span class="cp">#include</span> <span class="cpf">&lt;ti/ipc/Ipc.h&gt;</span><span class="cp"></span>

 <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
     <span class="n">Int</span> <span class="n">status</span><span class="p">;</span>

     <span class="cm">/* Call Ipc_start() */</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">Ipc_start</span><span class="p">();</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">System_abort</span><span class="p">(</span><span class="s">&quot;Ipc_start failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
     <span class="p">}</span>

    <span class="n">BIOS_start</span><span class="p">();</span>
     <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>By default, the BIOS implementation of Ipc_start() internally calls Notify_start() if it has not already been called,
then loops through the defined SharedRegions so that it can set up the HeapMemMP and GateMP instances used internally by the IPC modules.
It also sets up MessageQ transports to remote processors.</p>
<p>The SharedRegion with an index of 0 (zero) is often used by BIOS-side IPC_start() to create resource management tables
for internal use by other IPC modules. Thus SharedRegion “0” must be accessible by all processors.
See SharedRegion Module for more about the SharedRegion module.</p>
<div class="section" id="ipc-module-configuration-bios-side-only">
<h4>4.4.6.2.1. Ipc Module Configuration (BIOS-side only)<a class="headerlink" href="#ipc-module-configuration-bios-side-only" title="Permalink to this headline">¶</a></h4>
<p>In an XDCtools configuration file, you configure the Ipc module for use as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>Ipc = xdc.useModule(&#39;ti.sdo.ipc.Ipc&#39;);
</pre></div>
</div>
<p>You can configure what the Ipc_start() API will do–which modules it will start and which objects it will create–by using the Ipc.setEntryMeta
method in the configuration file to set the following properties:</p>
<ul class="simple">
<li><p><strong>setupNotify.</strong> If set to false, the Notify module is not set up. The default is true.</p></li>
<li><p><strong>setupMessageQ.</strong> If set to false, the MessageQ transport instances to remote processors are not set up and
the MessageQ module does not attach to remote processors. The default is true.</p></li>
</ul>
<p>For example, the following statements from the notify example configuration turn off the setup of the MessageQ transports and connections to remote processors:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* To avoid wasting shared memory for MessageQ transports */</span>
<span class="k">for</span> <span class="p">(</span><span class="n">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MultiProc</span><span class="p">.</span><span class="n">numProcessors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Ipc</span><span class="p">.</span><span class="n">setEntryMeta</span><span class="p">({</span>
        <span class="nl">remoteProcId</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span>
        <span class="nl">setupMessageQ</span><span class="p">:</span> <span class="nb">false</span><span class="p">,</span>
    <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You can configure how the IPC module synchronizes processors by configuring the Ipc.procSync property. For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ipc</span><span class="p">.</span><span class="n">procSync</span> <span class="o">=</span> <span class="n">Ipc</span><span class="p">.</span><span class="n">ProcSync_ALL</span><span class="p">;</span>
</pre></div>
</div>
<p>The options are:</p>
<ul>
<li><p>Ipc.ProcSync_ALL. If you use this option, the Ipc_start() API automatically attaches to and synchronizes all remote processors.
If you use this option, your application should never call Ipc_attach().
Use this option if all IPC processors on a device start up at the same time and connections should be established between every possible pair of processors.</p></li>
<li><p>Ipc.ProcSync_PAIR. (Default) If you use this option, you must explicitly call Ipc_attach() to attach to a specific remote processor.</p>
<blockquote>
<div><p>If you use this option, Ipc_start() performs system-wide IPC initialization, but does not make connections to remote processors.
Use this option if any or all of the following are true:
- You need to control when synchronization with each remote processor occurs.
- Useful work can be done while trying to synchronize with a remote processor by yielding a thread after each attempt to Ipc_attach() to the processor.
- Connections to some remote processors are unnecessary and should be made selectively to save memory.
- Ipc.ProcSync_NONE. If you use this option, Ipc_start() doesn’t synchronize any processors before setting up the objects needed by other modules.</p>
</div></blockquote>
<p>Use this option with caution. It is intended for use in cases where the application performs its own synchronization and you want to avoid a potential
deadlock situation with the IPC synchronization.</p>
<p>If you use the ProcSync_NONE option, Ipc_start() works exactly as it does with ProcSync_PAIR. :
However, in this case, Ipc_attach() does not synchronize with the remote processor.
As with other ProcSync options, Ipc_attach() still sets up access to GateMP, SharedRegion,
Notify, NameServer, and MessageQ transports, so your application must still call Ipc_attach()
for each remote processor that will be accessed. Note that an Ipc_attach() call for a remote processor
whose ID is less than the local processor’s ID must occur after the corresponding remote processor has called Ipc_attach() to the local processor.
For example, processor #2 can call Ipc_attach(1) only after processor #1 has called Ipc_attach(2).:</p>
</li>
</ul>
<p>You can configure a function to perform custom actions in addition to the default actions performed when attaching to or detaching from a remote processor.
These functions run near the end of Ipc_attach() and near the beginning of Ipc_detach(), respectively.
Such functions must be non-blocking and must run to completion. The following example configures two attach functions and two detach functions.
Each set of functions will be passed a different argument:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>var Ipc = xdc.useModule(&#39;ti.sdo.ipc.Ipc&#39;);

var fxn = new Ipc.UserFxn;
fxn.attach = &#39;&amp;userAttachFxn1&#39;;
fxn.detach = &#39;&amp;userDetachFxn1&#39;;
Ipc.addUserFxn(fxn, 0x1);

fxn.attach = &#39;&amp;userAttachFxn2&#39;;
fxn.detach = &#39;&amp;userDetachFxn2&#39;;
Ipc.addUserFxn(fxn, 0x2);
</pre></div>
</div>
<p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html"><img alt="ipcCfg_Ipc_Img2" src="../_images/Book_cfg.png" /></a> The latest version of the IPC module configuration documentation is available
<a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html">here</a></p>
</div>
<div class="section" id="ipc-module-apis">
<h4>4.4.6.2.2. Ipc Module APIs<a class="headerlink" href="#ipc-module-apis" title="Permalink to this headline">¶</a></h4>
<p>In addition to the Ipc_start() API, which all applications that use IPC modules are required to call,
the Ipc module also provides the following APIs for processor synchronization:</p>
<ul class="simple">
<li><p>Ipc_attach() Creates a connection to the specified remote processor.</p></li>
<li><p>Ipc_detach() Deletes the connection to the specified remote processor.</p></li>
</ul>
<p>You must call Ipc_start() on a processor before calling Ipc_attach().</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Call Ipc_attach() to the processor that owns shared memory region 0–usually
the processor with an id of 0–before making a connection to any other remote processor.
For example, if there are three processors configured with MultiProc, processor 1 should
attach to processor 0 before it can attach to processor 2.</p>
</div>
<p>Use these functions unless you are using the Ipc.ProcSync_ALL configuration setting.
With that option, Ipc_start() automatically attaches to and synchronizes all remote processors,
and your application should never call Ipc_attach().</p>
<p>The Ipc.ProcSync_PAIR configuration option expects that your application will call
Ipc_attach() for each remote processor with which it should be able to communicate.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In ARM-Linux/DSP-RTOS scenario, Linux application gets the IPC configuration from LAD which has Ipc.ProcSync_ALL configured.
DSP has Ipc.ProcSync_PAIR configured.</p>
</div>
<p>Processor synchronization means that one processor waits until the other processor signals that a particular module is ready for use.
Within Ipc_attach(), this is done for the GateMP, SharedRegion (region 0), and Notify modules and the MessageQ transports.</p>
<p>You can call the Ipc_detach() API to delete internal instances created by Ipc_attach() and to free the memory used by these instances.</p>
<p><a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_ipc_8h.html"><img alt="ipcRun_Ipc_Img2" src="../_images/Book_run.png" /></a> The latest version of the IPC module run-time API documentation is available
<a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_ipc_8h.html">online</a></p>
</div>
</div>
<div class="section" id="messageq-module">
<h3>4.4.6.3. MessageQ Module<a class="headerlink" href="#messageq-module" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" colspan="2"><p>API Reference Links</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html"><img alt="msgCfg_Img1" src="../_images/Book_cfg.png" /></a></p></td>
<td><p><a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_message_q_8h.html"><img alt="msgRun_Img1" src="../_images/Book_run.png" /></a></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The MessageQ module supports the structured sending and receiving of variable length messages.
It is OS independent and works with any threading model. For each MessageQ you create,
there is a single reader and may be multiple writers.</p>
<p>MessageQ is the recommended messaging API for most applications.
It can be used for both homogeneous and heterogeneous multi-processor messaging,
along with single-processor messaging between threads.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The MessageQ module in IPC is similar in functionality to the MSGQ module in DSP/BIOS 5.x.</p>
</div>
<p>The following are key features of the MessageQ module:</p>
<ul class="simple">
<li><p>Writers and readers can be relocated to another processor with no runtime code changes.</p></li>
<li><p>Timeouts are allowed when receiving messages.</p></li>
<li><p>Readers can determine the writer and reply back.</p></li>
<li><p>Receiving a message is deterministic when the timeout is zero.</p></li>
<li><p>Messages can reside on any message queue.</p></li>
<li><p>Supports zero-copy transfers (BIOS only)</p></li>
<li><p>Messages can be sent and received from any type of thread.</p></li>
<li><p>The notification mechanism is specified by the application (BIOS only)</p></li>
<li><p>Allows QoS (quality of service) on message buffer pools. For example, using specific buffer pools for specific message queues. (BIOS only)</p></li>
</ul>
<p>Messages are sent and received via a message queue. A reader is a thread that gets (reads) messages
from a message queue. A writer is a thread that puts (writes) a message to a message queue.
Each message queue has one reader and can have many writers.
A thread may read from or write to multiple message queues.</p>
<ul class="simple">
<li><p><strong>Reader.</strong> The single reader thread calls MessageQ_create(), MessageQ_get(), MessageQ_free(), and MessageQ_delete().</p></li>
<li><p><strong>Writer.</strong> Writer threads call MessageQ_open(), MessageQ_alloc(), MessageQ_put(), and MessageQ_close().</p></li>
</ul>
<p>The following figure shows the flow in which applications typically use the main runtime MessageQ APIs:</p>
<img alt="../_images/IpcUG_ipc_2_3_1.png" src="../_images/IpcUG_ipc_2_3_1.png" />
<p>Conceptually, the reader thread creates and owns the message queue. Writer threads then open a created message queue to get access to them.</p>
<div class="section" id="configuring-the-messageq-module-bios-only">
<h4>4.4.6.3.1. Configuring the MessageQ Module (BIOS only)<a class="headerlink" href="#configuring-the-messageq-module-bios-only" title="Permalink to this headline">¶</a></h4>
<p>On BIOS-based systems, you can configure a number of module-wide properties for MessageQ in your XDCtools configuration file.</p>
<p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html"><img alt="msgCfg_Img2" src="../_images/Book_cfg.png" /></a> A snapshot of the MessageQ module configuration
documentation is available <a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html">online</a>.</p>
<p>To configure the MessageQ module, you must enable the module as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>var MessageQ = xdc.useModule(&#39;ti.sdo.ipc.MessageQ&#39;);
</pre></div>
</div>
<p>Some example Module-wide configuration properties you can set follow; refer to the IPC documentation for details.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Maximum length of MessageQ names</span>
<span class="n">MessageQ</span><span class="p">.</span><span class="n">maxNameLen</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>

<span class="c1">// Max number of MessageQs that can be dynamically created</span>
<span class="n">MessageQ</span><span class="p">.</span><span class="n">maxRuntimeEntries</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="creating-a-messageq-object">
<h4>4.4.6.3.2. Creating a MessageQ Object<a class="headerlink" href="#creating-a-messageq-object" title="Permalink to this headline">¶</a></h4>
<p>You can create message queues dynamically. Static creation is not supported.
A MessageQ object is not a shared resource. That is, it resides on the processor, within the process, that creates it.</p>
<p>The reader thread creates a message queue. To create a MessageQ object dynamically,
use the MessageQ_create() C API, which has the following syntax:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MessageQ_Handle</span> <span class="nf">MessageQ_create</span><span class="p">(</span><span class="n">String</span> <span class="n">name</span><span class="p">,</span> <span class="n">MessageQ_Params</span> <span class="o">*</span><span class="n">params</span><span class="p">);</span>
</pre></div>
</div>
<p>When you create a queue, you specify a name string. This name will be needed by the MessageQ_open() function,
which is called by threads on the same or remote processors that want to send messages to the created message queue.
While the name is not required (that is, it can be NULL), an unnamed queue cannot be opened.</p>
<p>An ISync handle is associated with the message queue via the synchronizer parameter.</p>
<p>If the call is successful, the MessageQ_Handle is returned. If the call fails, NULL is returned.</p>
<p>You initialize the params struct by using the MessageQ_Params_init() function, which initializes the params structure with the default values. A NULL value for params can be passed into the create call, which results in the defaults being used.
The default synchronizer is SyncSem.</p>
<p>The following code creates a MessageQ object using SyncSem as the synchronizer.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MessageQ_Handle</span>   <span class="n">messageQ</span><span class="p">;</span>
<span class="n">MessageQ_Params</span>   <span class="n">messageQParams</span><span class="p">;</span>
<span class="n">SyncSem_Handle</span>    <span class="n">syncSemHandle</span><span class="p">;</span>

<span class="p">...</span>

<span class="n">syncSemHandle</span> <span class="o">=</span> <span class="n">SyncSem_create</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">MessageQ_Params_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">messageQParams</span><span class="p">);</span>
<span class="n">messageQParams</span><span class="p">.</span><span class="n">synchronizer</span> <span class="o">=</span> <span class="n">SyncSem_Handle_upCast</span><span class="p">(</span><span class="n">syncSemHandle</span><span class="p">);</span>
<span class="n">messageQ</span> <span class="o">=</span> <span class="n">MessageQ_create</span><span class="p">(</span><span class="n">CORE0_MESSAGEQNAME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">messageQParams</span><span class="p">);</span>
</pre></div>
</div>
<p>In this example, the CORE0_MESSAGEQNAME constant may be defined in header shared by multiple cores.</p>
<p><a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_message_q_8h.html"><img alt="msgRun_Img2" src="../_images/Book_run.png" /></a> A snapshot of the MessageQ module run-time
API documentation is available <a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_message_q_8h.html">online</a>.</p>
</div>
<div class="section" id="opening-a-message-queue">
<h4>4.4.6.3.3. Opening a Message Queue<a class="headerlink" href="#opening-a-message-queue" title="Permalink to this headline">¶</a></h4>
<p>Writer threads open a created message queue to get access to them.
In order to obtain a handle to a message queue that has been created,
a writer thread must call MessageQ_open(), which has the following syntax.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Int</span> <span class="nf">MessageQ_open</span><span class="p">(</span><span class="n">String</span> <span class="n">name</span><span class="p">,</span> <span class="n">MessageQ_QueueId</span> <span class="o">*</span><span class="n">queueId</span><span class="p">);</span>
</pre></div>
</div>
<p>This function expects a name, which must match with the name of the created object.
Internally MessageQ calls NameServer_get() to find the 32-bit queueId associated with the created message queue.
NameServer looks both locally and remotely.</p>
<p>If no matching name is found on any processor, MessageQ_open() returns MessageQ_E_NOTFOUND.
If the open is successful, the Queue ID is filled in and MessageQ_S_SUCCESS is returned.</p>
<p>The following code opens the MessageQ object created by the processor.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MessageQ_QueueId</span>   <span class="n">remoteQueueId</span><span class="p">;</span>
<span class="n">Int</span>                <span class="n">status</span><span class="p">;</span>

<span class="p">...</span>

<span class="cm">/* Open the remote message queue. Spin until it is ready. */</span>
<span class="k">do</span> <span class="p">{</span>
   <span class="n">status</span> <span class="o">=</span> <span class="n">MessageQ_open</span><span class="p">(</span><span class="n">CORE0_MESSAGEQNAME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">remoteQueueId</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">while</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="allocating-a-message">
<h4>4.4.6.3.4. Allocating a Message<a class="headerlink" href="#allocating-a-message" title="Permalink to this headline">¶</a></h4>
<p>MessageQ manages message allocation via the MessageQ_alloc() and MessageQ_free() functions.
MessageQ uses Heaps for message allocation. MessageQ_alloc() has the following syntax:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MessageQ_Msg</span> <span class="nf">MessageQ_alloc</span><span class="p">(</span><span class="n">UInt16</span>        <span class="n">heapId</span><span class="p">,</span>
                            <span class="n">UInt32</span>        <span class="n">size</span><span class="p">);</span>
</pre></div>
</div>
<p>The allocation size in MessageQ_alloc() must include the size of the message header, which is 32 bytes.</p>
<p>The following code allocates a message:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#define MSGSIZE                  256</span>
<span class="cp">#define HEAPID                     0</span>
<span class="p">...</span>
<span class="n">MessageQ_Msg</span>     <span class="n">msg</span><span class="p">;</span>

<span class="p">...</span>

<span class="n">msg</span> <span class="o">=</span> <span class="n">MessageQ_alloc</span><span class="p">(</span><span class="n">HEAPID</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">MessageQ_MsgHeader</span><span class="p">));</span>
<span class="k">if</span> <span class="p">(</span><span class="n">msg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">System_abort</span><span class="p">(</span><span class="s">&quot;MessageQ_alloc failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Once a message is allocated, it can be sent on any message queue.
Once the reader receives the message, it may either free the message or re-use the message.
Messages in a message queue can be of variable length.
The only requirement is that the first field in the definition of a message must be a MsgHeader structure.
For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">MyMsg</span> <span class="p">{</span>
    <span class="n">MessageQ_MsgHeader</span> <span class="n">header</span><span class="p">;</span>     <span class="c1">// Required</span>
    <span class="n">SomeEnumType</span>       <span class="n">type</span>        <span class="c1">// Can be any field</span>
    <span class="p">...</span>                            <span class="c1">// ...</span>
<span class="p">}</span> <span class="n">MyMsg</span><span class="p">;</span>
</pre></div>
</div>
<p>The MessageQ APIs use the MessageQ_MsgHeader internally. Your application should not
modify or directly access the fields in the MessageQ_MsgHeader structure.</p>
<div class="section" id="messageq-allocation-and-heaps">
<h5>4.4.6.3.4.1. MessageQ Allocation and Heaps<a class="headerlink" href="#messageq-allocation-and-heaps" title="Permalink to this headline">¶</a></h5>
<p>All messages sent via the MessageQ module must be allocated from a xdc.runtime.IHeap implementation, such as ti.sdo.ipc.heaps.HeapBufMP.
The same heap can also be used for other memory allocation not related to MessageQ.</p>
<p>The MessageQ_registerHeap() API assigns a MessageQ heapId to a heap. When allocating a message, the heapId is used, not the heap handle. The heapIds should start at zero and increase.
The maximum number of heaps is determined by the numHeap module configuration property.
See the online documentation for MessageQ_registerHeap() for details.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Register this heap with MessageQ */</span>
<span class="n">status</span> <span class="o">=</span> <span class="n">MessageQ_registerHeap</span><span class="p">(</span> <span class="n">HeapBufMP_Handle_upCast</span><span class="p">(</span><span class="n">heapHandle</span><span class="p">),</span> <span class="n">HEAPID</span><span class="p">);</span>
</pre></div>
</div>
<p>If the registration fails (for example, the heapId is already used), this function returns FALSE.</p>
<p>An application can use multiple heaps to allow an application to regulate its message usage.
For example, an application can allocate critical messages from a heap of fast on-chip memory and non-critical messages from a heap of slower external memory.
Additionally, heaps MessageQ uses can be shared with other modules and/or the application.</p>
<p>MessageQ alternatively supports allocating messages without the MessageQ_alloc() function.</p>
<p>Heaps can be unregistered via MessageQ_unregisterHeap().</p>
</div>
<div class="section" id="messageq-allocation-without-a-heap">
<h5>4.4.6.3.4.2. MessageQ Allocation Without a Heap<a class="headerlink" href="#messageq-allocation-without-a-heap" title="Permalink to this headline">¶</a></h5>
<p>It is possible to send MessageQ messages that are allocated statically instead of being allocated at run-time via MessageQ_alloc().
However the first field of the message must still be a MsgHeader.
To make sure the MsgHeader has valid settings, the application must call MessageQ_staticMsgInit().
This function initializes the header fields in the same way that MessageQ_alloc() does,
except that it sets the heapId field in the header to the MessageQ_STATICMSG constant.</p>
<p>If an application uses messages that were not allocated using MessageQ_alloc(), it cannot free the messages via the MessageQ_free() function,
even if the message is received by a different processor. Also, the transport may internally call MessageQ_free()
and encounter an error.</p>
<p>If MessageQ_free() is called on a statically allocated message, it asserts that the heapId of the message is not MessageQ_STATICMSG.</p>
</div>
</div>
<div class="section" id="sending-a-message">
<h4>4.4.6.3.5. Sending a Message<a class="headerlink" href="#sending-a-message" title="Permalink to this headline">¶</a></h4>
<p>Once a message queue is opened and a message is allocated, the message can be sent to the MessageQ via
the MessageQ_put() function, which has the following syntax.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Int</span> <span class="nf">MessageQ_put</span><span class="p">(</span><span class="n">MessageQ_QueueId</span> <span class="n">queueId</span><span class="p">,</span>
               <span class="n">MessageQ_Msg</span>     <span class="n">msg</span><span class="p">);</span>
</pre></div>
</div>
<p>For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">status</span> <span class="o">=</span> <span class="n">MessageQ_put</span><span class="p">(</span><span class="n">remoteQueueId</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
</pre></div>
</div>
<p>Opening a queue is not required. Instead the message queue ID can be “discovered”
via the MessageQ_getReplyQueue() function, which returns the 32-bit queueId.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MessageQ_QueueId</span> <span class="n">replyQueue</span><span class="p">;</span>
<span class="n">MessageQ_Msg</span>     <span class="n">msg</span><span class="p">;</span>

<span class="cm">/* Use the embedded reply destination */</span>
<span class="n">replyMessageQ</span> <span class="o">=</span> <span class="n">MessageQ_getReplyQueue</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">replyMessageQ</span> <span class="o">==</span> <span class="n">MessageQ_INVALIDMESSAGEQ</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">System_abort</span><span class="p">(</span><span class="s">&quot;Invalid reply queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Send the response back */</span>
<span class="n">status</span> <span class="o">=</span> <span class="n">MessageQ_put</span><span class="p">(</span><span class="n">replyQueue</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">System_abort</span><span class="p">(</span><span class="s">&quot;MessageQ_put was not successful</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>If the destination queue is local, the message is placed on the appropriate priority linked list and the ISync signal function is called.
If the destination queue is on a remote processor, the message is given to the proper transport and returns.</p>
<p>If MessageQ_put() succeeds, it returns MessageQ_S_SUCCESS. If MessageQ_E_FAIL is returned,
an error occurred and the caller still owns the message.</p>
<p>There can be multiple senders to a single message queue. MessageQ handles the thread safety.</p>
<p>Before you send a message, you can use the MessageQ_setMsgId() function to assign a numeric value to the message that can be checked by the receiving thread.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Increment...the remote side will check this */</span>
<span class="n">msgId</span><span class="o">++</span><span class="p">;</span>
<span class="n">MessageQ_setMsgId</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">msgId</span><span class="p">);</span>
</pre></div>
</div>
<p>You can use the MessageQ_setMsgPri() function to set the priority of the message.</p>
</div>
<div class="section" id="receiving-a-message">
<h4>4.4.6.3.6. Receiving a Message<a class="headerlink" href="#receiving-a-message" title="Permalink to this headline">¶</a></h4>
<p>To receive a message, a reader thread calls the MessageQ_get() API.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Int</span> <span class="n">MessageQ_get</span><span class="p">(</span><span class="n">MessageQ_Handle</span> <span class="n">handle</span><span class="p">,</span>
                 <span class="n">MessageQ_Msg</span>    <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
                 <span class="n">UInt</span>            <span class="n">timeout</span><span class="p">)</span>
</pre></div>
</div>
<p>If a message is present, it returned by this function. In this case the ISync’s wait() function is not called.
For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Get a message */</span>
<span class="n">status</span> <span class="o">=</span> <span class="n">MessageQ_get</span><span class="p">(</span><span class="n">messageQ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="n">MessageQ_FOREVER</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">System_abort</span><span class="p">(</span><span class="s">&quot;Should not happen; timeout is forever</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If no message is present and no error occurs, this function blocks while waiting for the timeout period for the message to arrive.
If the timeout period expires, MessageQ_E_FAIL is returned. If an error occurs, the msg argument will be unchanged.</p>
<p>After receiving a message, you can use the following APIs to get information about the message from the message header:</p>
<ul class="simple">
<li><p>MessageQ_getMsgId() gets the ID value set by MessageQ_setMsgId(). For example:</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Get the id and increment it to send back */</span>
<span class="n">msgId</span> <span class="o">=</span> <span class="n">MessageQ_getMsgId</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
<span class="n">msgId</span> <span class="o">+=</span> <span class="n">NUMCLIENTS</span><span class="p">;</span>
<span class="n">MessageQ_setMsgId</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">msgId</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p>MessageQ_getMsgPri() gets the priority set by MessageQ_setMsgPri().</p></li>
<li><p>MessageQ_getMsgSize() gets the size of the message in bytes.</p></li>
<li><p>MessageQ_getReplyQueue() gets the ID of the queue provided by MessageQ_setReplyQueue().</p></li>
</ul>
</div>
<div class="section" id="deleting-a-messageq-object">
<h4>4.4.6.3.7. Deleting a MessageQ Object<a class="headerlink" href="#deleting-a-messageq-object" title="Permalink to this headline">¶</a></h4>
<p>MessageQ_delete() frees a MessageQ object stored in local memory. If any messages are still on the internal linked lists, they will be freed.
The contents of the handle are nulled out by the function to prevent use after deleting.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Void</span> <span class="nf">MessageQ_delete</span><span class="p">(</span><span class="n">MessageQ_Handle</span> <span class="o">*</span><span class="n">handle</span><span class="p">);</span>
</pre></div>
</div>
<p>The queue array entry is set to NULL to allow re-use.</p>
<p>Once a message queue is deleted, no messages should be sent to it. A MessageQ_close() is recommended, but not required.</p>
</div>
<div class="section" id="message-priorities">
<h4>4.4.6.3.8. Message Priorities<a class="headerlink" href="#message-priorities" title="Permalink to this headline">¶</a></h4>
<p>MessageQ supports three message priorities as follows:</p>
<ul class="simple">
<li><p>MessageQ_NORMALPRI = 0</p></li>
<li><p>MessageQ_HIGHPRI = 1</p></li>
<li><p>MessageQ_URGENTPRI = 3</p></li>
</ul>
<p>You can set the priority level for a message before sending it by using the MessageQ_setMsgPri() function:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Void</span> <span class="n">MessageQ_setMsgPri</span><span class="p">(</span><span class="n">MessageQ_Msg</span>        <span class="n">msg</span><span class="p">,</span>
                      <span class="n">MessageQ_Priority</span>   <span class="n">priority</span><span class="p">)</span>
</pre></div>
</div>
<p>Internally a MessageQ object maintains two linked lists: normal and high-priority.
A normal priority message is placed onto the “normal” linked list in FIFO manner.
A high priority message is placed onto the “high-priority” linked list in FIFO manner.
An urgent message is placed at the beginning of the high linked list.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since multiple urgent messages may be sent before a message is read, the order of urgent messages is not guaranteed.</p>
</div>
<p>When getting a message, the reader checks the high priority linked list first.
If a message is present on that list, it is returned. If not, the normal priority linked list is checked.
If a message is present there, it is returned. Otherwise the synchronizer’s wait function is called.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The MessageQ priority feature is enabled by the selecting different MessageQ transports.
Some MessageQ implementations (e.g. Linux) may not support multiple transports and therefore may not support this feature.</p>
</div>
</div>
<div class="section" id="thread-synchronization-bios-only">
<h4>4.4.6.3.9. Thread Synchronization (BIOS only)<a class="headerlink" href="#thread-synchronization-bios-only" title="Permalink to this headline">¶</a></h4>
<p>MessageQ supports reads and writes of different thread models.
It can work with threading models that include SYS/BIOS’s Hwi, Swi, and Task threads.</p>
<p>This flexibility is accomplished by using an implementation of the xdc.runtime.knl.ISync interface.
The creator of the message queue must also create an object of the desired ISync implementation and assign that object as the “synchronizer” of the MessageQ.
Each message queue has its own synchronizer object.</p>
<p>An ISync object has two main functions: signal() and wait().
Whenever MessageQ_put() is called, the signal() function of the ISync implementation is called.
If MessageQ_get() is called when there are no messages on the queue, the wait() function of the ISync implementation is called.
The timeout passed into the MessageQ_get() is directly passed to the ISync wait() API.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since ISync implementations must be binary, the reader thread must drain the MessageQ of all messages before waiting for another signal.</p>
</div>
<p>For example, if the reader is a SYS/BIOS Swi, the instance could be a SyncSwi.
When a MessageQ_put() is called, the Swi_post() API would be called.
The Swi would run and it must call MessageQ_get() until no messages are returned.
If the Swi does not get all the messages, the Swi will not run again, or at least will not run until a new message is placed on the queue.</p>
<p>The calls to ISync functions occurs directly in MessageQ_put() when the call occurs on the same processor where the queue was created. In the remote case, the transport calls MessageQ_put(), which is then a local put, and the signal function is called.</p>
<p>The following are ISync implementations provided by XDCtools and SYS/BIOS:</p>
<ul class="simple">
<li><p><strong>xdc.runtime.knl.SyncNull.</strong> The signal() and wait() functions do nothing. Basically this implementation allows for polling.</p></li>
<li><p><strong>xdc.runtime.knl.SyncSemThread.</strong> An implementation built using the xdc.runtime.knl.Semaphore module, which is a binary semaphore.</p></li>
<li><p><strong>xdc.runtime.knl.SyncGeneric.xdc.</strong> This implementation allows you to use custom signal() and wait() functions as needed.</p></li>
<li><p><strong>ti.sysbios.syncs.SyncSem.</strong> An implementation built using the ti.sysbios.ipc.Semaphore module. The signal() function runs a Semaphore_post(). The wait() function runs a Semaphore_pend().</p></li>
<li><p><strong>ti.sysbios.syncs.SyncSwi.</strong> An implementation built using the ti.sysbios.knl.Swi module. The signal() function runs a Swi_post(). The wait() function does nothing and returns FALSE if the timeout elapses.</p></li>
<li><p><strong>ti.sysbios.syncs.SyncEvent.</strong> An implementation built using the ti.sysbios.ipc.Event module. The signal() function runs an Event_post(). The wait() function does nothing and returns FALSE if the timeout elapses. This implementation allows waiting on multiple events.</p></li>
</ul>
<p>The following code from the “message” example creates a SyncSem instance and assigns it to the synchronizer field in the MessageQ_Params structure before creating the MessageQ instance:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;ti/sysbios/syncs/SyncSem.h&gt;</span><span class="cp"></span>
<span class="p">...</span>

<span class="n">MessageQ_Params</span>   <span class="n">messageQParams</span><span class="p">;</span>
<span class="n">SyncSem_Handle</span>    <span class="n">syncSemHandle</span><span class="p">;</span>

<span class="cm">/* Create a message queue using SyncSem as synchronizer */</span>
<span class="n">syncSemHandle</span> <span class="o">=</span> <span class="n">SyncSem_create</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">MessageQ_Params_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">messageQParams</span><span class="p">);</span>
<span class="n">messageQParams</span><span class="p">.</span><span class="n">synchronizer</span> <span class="o">=</span> <span class="n">SyncSem_Handle_upCast</span><span class="p">(</span><span class="n">syncSemHandle</span><span class="p">);</span>
<span class="n">messageQ</span> <span class="o">=</span> <span class="n">MessageQ_create</span><span class="p">(</span><span class="n">CORE1_MESSAGEQNAME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">messageQParams</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="replyqueue">
<h4>4.4.6.3.10. ReplyQueue<a class="headerlink" href="#replyqueue" title="Permalink to this headline">¶</a></h4>
<p>For some applications, doing a MessageQ_open() on a queue is not realistic.
For example, a server may not want to open all the clients’ queues for sending responses.
To support this use case, the message sender can embed a reply queueId in the message
using the MessageQ_setReplyQueue() function.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Void</span> <span class="n">MessageQ_setReplyQueue</span><span class="p">(</span><span class="n">MessageQ_Handle</span> <span class="n">handle</span><span class="p">,</span>
                          <span class="n">MessageQ_Msg</span> <span class="n">msg</span><span class="p">)</span>
</pre></div>
</div>
<p>This API stores the message queue’s queueId into fields in the MsgHeader.</p>
<p>The MessageQ_getReplyQueue() function does the reverse. For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MessageQ_QueueId</span> <span class="n">replyQueue</span><span class="p">;</span>
<span class="n">MessageQ_Msg</span>     <span class="n">msg</span><span class="p">;</span>
<span class="p">...</span>

<span class="cm">/* Use the embedded reply destination */</span>
<span class="n">replyMessageQ</span> <span class="o">=</span> <span class="n">MessageQ_getReplyQueue</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">replyMessageQ</span> <span class="o">==</span> <span class="n">MessageQ_INVALIDMESSAGEQ</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">System_abort</span><span class="p">(</span><span class="s">&quot;Invalid reply queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The MessageQ_QueueId value returned by this function can then be used in a MessageQ_put() call.</p>
<p>The queue that is embedded in the message does not have to be the sender’s queue.</p>
</div>
<div class="section" id="remote-communication-via-transports-bios-only">
<h4>4.4.6.3.11. Remote Communication via Transports (BIOS only)<a class="headerlink" href="#remote-communication-via-transports-bios-only" title="Permalink to this headline">¶</a></h4>
<p>MessageQ is designed to support multiple processors. To allow this, different transports can be plugged into MessageQ.</p>
<p>In a multi-processor system, MessageQ communicates with other processors via ti.sdo.ipc.interfaces.IMessageQTransport instances.
There can be up to two IMessageQTransport instances for each processor to which communication is desired.
One can be a normal-priority transport and the other for handling high-priority messages.
This is done via the priority parameter in the transport create() function.
If there is only one register to a remote processor (either normal or high), all messages go via that transport.</p>
<p>There can be different transports on a processor. For example, there may be a shared memory transport to processor A and an sRIO one to processor B.</p>
<p>When your application calls Ipc_start(), the default transport instance used by MessageQ is created automatically.
Internally, transport instances are responsible for registering themselves with MessageQ via the MessageQ_registerTransport() function.</p>
<p>IPC provides an implementation of the IMessageQTransport interface called ti.sdo.ipc.transports.TransportShm (shared memory).
You can write other implementations to meet your needs.</p>
<p>When a transport is created via a transport-specific create() call, a remote processor ID (defined via the MultiProc module) is specified.
This ID denotes which processor this instance communicates with.
Additionally there are configuration properties for the transport–such as the message priority handled–that can be defined in a Params structure.
The transport takes these pieces of information and registers itself with MessageQ.
MessageQ now knows which transport to call when sending a message to a remote processor.</p>
<p>Trying to send to a processor that has no transport results in an error.</p>
<div class="section" id="custom-transport-implementations">
<h5>4.4.6.3.11.1. Custom Transport Implementations<a class="headerlink" href="#custom-transport-implementations" title="Permalink to this headline">¶</a></h5>
<p>Transports can register and unregister themselves dynamically. That is, if the transport instance is deleted,
it should unregister with MessageQ.</p>
<p>When receiving a message, transports need to form the MessageQ_QueueId that allows them to call MessageQ_put().
This is accomplished via the MessageQ_getDstQueue() API.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MessageQ_QueueId</span> <span class="n">MessageQ_getDstQueue</span><span class="p">(</span><span class="n">MessageQ_Msg</span> <span class="n">msg</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="sample-runtime-program-flow-dynamic">
<h4>4.4.6.3.12. Sample Runtime Program Flow (Dynamic)<a class="headerlink" href="#sample-runtime-program-flow-dynamic" title="Permalink to this headline">¶</a></h4>
<p>The following figure shows the typical sequence of events when using a MessageQ.
A message queue is created by a Task. An open on the same processor then occurs.
Assume there is one message in the system. The opener allocates the message and
sends it to the created message queue, which gets and frees it.</p>
<img alt="../_images/IpcUG_ipc_2_3_2.png" src="../_images/IpcUG_ipc_2_3_2.png" />
</div>
</div>
<div class="section" id="listmp-module">
<h3>4.4.6.4. ListMP Module<a class="headerlink" href="#listmp-module" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" colspan="2"><p>API Reference Links</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html"><img alt="lmpCfg_Img1" src="../_images/Book_cfg.png" /></a></p></td>
<td><p><a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_list_m_p_8h.html"><img alt="lmpRun_Img1" src="../_images/Book_run.png" /></a></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The ti.sdo.ipc.ListMP module is a linked-list based module designed to be used in a multi-processor environment.
It is designed to provide a means of communication between different processors.
ListMP uses shared memory to provide a way for multiple processors to share, pass, or store data buffers, messages, or state information.
ListMP is a low-level module used by several other IPC modules, including MessageQ, HeapBufMP, and transports, as a building block for
their instance and state structures.</p>
<p>A common challenge that occurs in a multi-processor environment is preventing concurrent data access in shared memory between different processors.
ListMP uses a multi-processor gate to prevent multiple processors from simultaneously accessing the same linked-list.
All ListMP operations are atomic across processors.</p>
<p>You create a ListMP instance dynamically as follows:</p>
<p># Initialize a ListMP_Params structure by calling ListMP_Params_init().
# Specify the name, regionId, and other parameters in the ListMP_Params structure.
# Call ListMP_create().</p>
<p>ListMP uses a ti.sdo.utils.NameServer instance to store the instance information.
The ListMP name supplied must be unique for all ListMP instances in the system.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ListMP_Params</span> <span class="n">params</span><span class="p">;</span>
<span class="n">GateMP_Handle</span> <span class="n">gateHandle</span><span class="p">;</span>
<span class="n">ListMP_Handle</span> <span class="n">handle1</span><span class="p">;</span>

<span class="cm">/* If gateHandle is NULL, the default remote gate will be</span>
<span class="cm">   automatically chosen by ListMP */</span>
<span class="n">gateHandle</span> <span class="o">=</span> <span class="n">GateMP_getDefaultRemote</span><span class="p">();</span>
<span class="n">ListMP_Params_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="p">);</span>
<span class="n">params</span><span class="p">.</span><span class="n">gate</span> <span class="o">=</span> <span class="n">gateHandle</span><span class="p">;</span>
<span class="n">params</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;myListMP&quot;</span><span class="p">;</span>
<span class="n">params</span><span class="p">.</span><span class="n">regionId</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">handle1</span> <span class="o">=</span> <span class="n">ListMP_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</pre></div>
</div>
<p>Once created, another processor or thread can open the ListMP instance by calling ListMP_open().</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="n">ListMP_open</span><span class="p">(</span><span class="s">&quot;myListMP&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ListMP uses SharedRegion pointers (see SharedRegion Module), which are portable across processors, to translate addresses for shared memory.
The processor that creates the ListMP instance must specify the shared memory in terms of its local address space.
This shared memory must have been defined in the SharedRegion module by the application.
The ListMP module has the following constraints:</p>
<ul class="simple">
<li><p>ListMP elements to be added/removed from the linked-list must be stored in a shared memory region.</p></li>
<li><p>The linked list must be on a worst-case cache line boundary for all the processors sharing the list.</p></li>
<li><p>ListMP_open() should be called only when global interrupts are enabled.</p></li>
</ul>
<p>A list item must have a field of type ListMP_Elem as its first field. For example, the following structure could be used for list elements:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Tester</span> <span class="p">{</span>
  <span class="n">ListMP_Elem</span> <span class="n">elem</span><span class="p">;</span>
  <span class="n">Int</span>         <span class="n">scratch</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>
  <span class="n">Int</span>         <span class="n">flag</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Tester</span><span class="p">;</span>
</pre></div>
</div>
<p>Besides creating, opening, and deleting a list instance, the ListMP module provides functions for the following common list operations:</p>
<ul class="simple">
<li><p><strong>ListMP_empty().</strong> Test for an empty ListMP.</p></li>
<li><p><strong>ListMP_getHead().</strong> Get the element from the front of the ListMP.</p></li>
<li><p><strong>ListMP_getTail().</strong> Get the element from the end of the ListMP.</p></li>
<li><p><strong>ListMP_insert().</strong> Insert element into a ListMP at the current location.</p></li>
<li><p><strong>ListMP_next().</strong> Return the next element in the ListMP (non-atomic).</p></li>
<li><p><strong>ListMP_prev().</strong> Return previous element in the ListMP (non-atomic).</p></li>
<li><p><strong>ListMP_putHead().</strong> Put an element at the head of the ListMP.</p></li>
<li><p><strong>ListMP_putTail().</strong> Put an element at the end of the ListMP.</p></li>
<li><p><strong>ListMP_remove().</strong> Remove the current element from the middle of the ListMP.</p></li>
</ul>
<p>This example prints a “flag” field from the list elements in a ListMP instance in order:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">System_printf</span><span class="p">(</span><span class="s">&quot;On the List: &quot;</span><span class="p">);</span>
<span class="n">testElem</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">while</span> <span class="p">((</span><span class="n">testElem</span> <span class="o">=</span> <span class="n">ListMP_next</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="p">(</span><span class="n">ListMP_Elem</span> <span class="o">*</span><span class="p">)</span><span class="n">testElem</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">System_printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span> <span class="n">testElem</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This example prints the same items in reverse order:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">System_printf</span><span class="p">(</span><span class="s">&quot;in reverse: &quot;</span><span class="p">);</span>
<span class="n">elem</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">while</span> <span class="p">((</span><span class="n">elem</span> <span class="o">=</span> <span class="n">ListMP_prev</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">elem</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">System_printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span> <span class="p">((</span><span class="n">Tester</span>  <span class="o">*</span><span class="p">)</span><span class="n">elem</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This example determines if a ListMP instance is empty:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">ListMP_empty</span><span class="p">(</span><span class="n">handle1</span><span class="p">)</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">System_printf</span><span class="p">(</span><span class="s">&quot;Yes, handle1 is empty</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This example places a sequence of even numbers in a ListMP instance:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Add 0, 2, 4, 6, 8 */</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">COUNT</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ListMP_putTail</span><span class="p">(</span><span class="n">handle1</span><span class="p">,</span> <span class="p">(</span><span class="n">ListMP_Elem</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The instance state information contains a pointer to the head of the linked-list, which is stored in shared memory.
Other attributes of the instance stored in shared memory include the version, status, and the size of the shared address.
Other processors can obtain a handle to the linked list by calling ListMP_open().</p>
<p>The following figure shows local memory and shared memory for processors Proc 0 and Proc 1, in which Proc 0 calls ListMP_create() and Proc 1 calls ListMP_open().</p>
<img alt="../_images/IpcUG_ipc_2_4_1.png" src="../_images/IpcUG_ipc_2_4_1.png" />
<p>The cache alignment used by the list is taken from the SharedRegion on a per-region basis. The alignment must be the same across all processors and should be the worst-case cache line boundary.</p>
</div>
<div class="section" id="heapmp-module">
<h3>4.4.6.5. HeapMP Module<a class="headerlink" href="#heapmp-module" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 34%" />
<col style="width: 34%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" colspan="3"><p>API Reference Links</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html"><img alt="hmpCfg_Img1" src="../_images/Book_cfg.png" /></a></p></td>
<td><p><a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_heap_buf_m_p_8h.html"><img alt="hmpRun_Img1" src="../_images/Book_run.png" /></a></p></td>
<td><p>HeapBuf</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html"><img alt="hmpCfg_Img2" src="../_images/Book_cfg.png" /></a></p></td>
<td><p><a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_heap_mem_m_p_8h.html"><img alt="hmpRun_Img2" src="../_images/Book_run.png" /></a></p></td>
<td><p>HeapMem</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html"><img alt="hmpCfg_Img3" src="../_images/Book_cfg.png" /></a></p></td>
<td><p><a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_heap_multi_buf_m_p_8h.html"><img alt="hmpRun_Img3" src="../_images/Book_run.png" /></a></p></td>
<td><p>HeapMultiBuf</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The ti.sdo.ipc.heaps package provides three implementations of
the <a class="reference external" href="http://rtsc.eclipse.org/docs-tip/Using_xdc.runtime_Memory">xdc.runtime.IHeap interface</a>.</p>
<ul class="simple">
<li><p><strong>HeapBufMP.</strong> Fixed-size memory manager. All buffers allocated from a HeapBufMP instance are of the same size.
There can be multiple instances of HeapBufMP that manage different sizes.
The ti.sdo.ipc.heaps.HeapBufMP module is modeled after SYS/BIOS 6’s HeapBuf module (ti.sysbios.heaps.HeapBuf).</p></li>
<li><p><strong>HeapMultiBufMP.</strong> Each instance supports up to 8 different fixed sizes of buffers.
When an allocation request is made, the HeapMultiBufMP instance searches the different buckets to find the smallest one that satisfies the request.
If that bucket is empty, the allocation fails. The ti.sdo.ipc.heaps.HeapMultiBufMP module is modeled after SYS/BIOS 6’s HeapMultiBuf module (ti.sysbios.heaps.HeapMultiBuf).</p></li>
<li><p><strong>HeapMemMP.</strong> Variable-size memory manager. HeapMemMP manages a single buffer in shared memory from which blocks of user-specified length are allocated and freed.
The ti.sdo.ipc.heaps.HeapMemMP module is modeled after SYS/BIOS 6’s HeapMem module (ti.sysbios.heaps.HeapMem).</p></li>
</ul>
<p>The main addition to these modules is the use of shared memory and the management of multi-processor exclusion.</p>
<p>The SharedRegion modules, and therefore the MessageQ module and other IPC modules that use SharedRegion, use a HeapMemMP instance internally.</p>
<p>The following subsections use “Heap*MP” to refer to the HeapBufMP, HeapMultiBufMP, and HeapMemMP modules.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These Heap*MP Modules are only available on SYS/BIOS-based cores, they are not available when running an HLOS (e.g. Linux).
As an HLOS shared memory solution, many Linux SDKs are recommending/providing CMEM.
There are limitations (e.g. you cannot alloc on HLOS and free on RTOS), but these are in line with using the HLOS as a master (owning all resources) and
RTOS as a slave (using resources provided by the master).</p>
</div>
<div class="section" id="configuring-a-heap-mp-module">
<h4>4.4.6.5.1. Configuring a Heap*MP Module<a class="headerlink" href="#configuring-a-heap-mp-module" title="Permalink to this headline">¶</a></h4>
<p>In addition to configuring Heap*MP instances, you can set module-wide configuration properties.
For example, the maxNameLen property lets you set the maximum length of heap names.
The track[Max]Allocs module configuration property enables/disables tracking memory allocation statistics.</p>
<p>A Heap*MP instance uses a NameServer instance to manage name/value pairs.</p>
<p>The Heap*MP modules make the following assumptions:</p>
<ul class="simple">
<li><p>The SharedRegion module handles address translation between a virtual shared address space and the local processor’s address space.
If the memory address spaces are identical across all processors, or if a single processor is being used,
no address translation is required and the SharedRegion module must be appropriately configured.</p></li>
<li><p>Both processors must have the same endianness.</p></li>
</ul>
</div>
<div class="section" id="creating-a-heap-mp-instance">
<h4>4.4.6.5.2. Creating a Heap*MP Instance<a class="headerlink" href="#creating-a-heap-mp-instance" title="Permalink to this headline">¶</a></h4>
<p>Heaps can be created dynamically. You use the Heap*MP_create() functions to dynamically create Heap*MP instances.
As with other IPC modules, before creating a Heap*MP instance, you initialize a Heap*MP_Params structure and set fields in
the structure to the desired values. When you create a heap, the shared memory is initialized and the Heap*MP object is created in local memory.
Only the actual buffers and some shared information reside in shared memory.</p>
<p>The following code example initializes a HeapBufMP_Params structure and sets fields in it.
It then creates and registers an instance of the HeapBufMP module.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Create the heap that will be used to allocate messages. */</span>
<span class="n">HeapBufMP_Params_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heapBufMPParams</span><span class="p">);</span>
<span class="n">heapBufMPParams</span><span class="p">.</span><span class="n">regionId</span>      <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>        <span class="cm">/* use default region */</span>
<span class="n">heapBufMPParams</span><span class="p">.</span><span class="n">name</span>          <span class="o">=</span> <span class="s">&quot;myHeap&quot;</span><span class="p">;</span>
<span class="n">heapBufMPParams</span><span class="p">.</span><span class="n">align</span>         <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
<span class="n">heapBufMPParams</span><span class="p">.</span><span class="n">numBlocks</span>     <span class="o">=</span> <span class="mi">40</span><span class="p">;</span>
<span class="n">heapBufMPParams</span><span class="p">.</span><span class="n">blockSize</span>     <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
<span class="n">heapBufMPParams</span><span class="p">.</span><span class="n">gate</span>          <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>     <span class="cm">/* use system gate */</span>
<span class="n">heapHandle</span> <span class="o">=</span> <span class="n">HeapBufMP_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heapBufMPParams</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">heapHandle</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">System_abort</span><span class="p">(</span><span class="s">&quot;HeapBufMP_create failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Register this heap with MessageQ */</span>
<span class="n">MessageQ_registerHeap</span><span class="p">(</span><span class="n">HeapBufMP_Handle_upCast</span><span class="p">(</span><span class="n">heapHandle</span><span class="p">),</span> <span class="n">HEAPID</span><span class="p">);</span>
</pre></div>
</div>
<p>The parameters for the various Heap*MP implementations vary. For example, when you create a HeapBufMP instance,
you can configure the following parameters after initializing the HeapBufMP_Params structure:</p>
<ul class="simple">
<li><p><strong>regionId.</strong> The index corresponding to the shared region from which shared memory will be allocated.</p></li>
<li><p><strong>name.</strong> A name of the heap instance for NameServer (optional).</p></li>
<li><p><strong>align.</strong> Requested alignment for each block.</p></li>
<li><p><strong>numBlocks.</strong> Number of fixed size blocks.</p></li>
<li><p><strong>blockSize.</strong> Size of the blocks in this instance.</p></li>
<li><p><strong>gate.</strong> A multiprocessor gate for context protection.</p></li>
<li><p><strong>exact.</strong> Only allocate a block if the requested size is an exact match. Default is false.</p></li>
</ul>
<p>Of these parameters, the ones that are common to all three Heap*MP implementations are gate, name and regionId.</p>
</div>
<div class="section" id="opening-a-heap-mp-instance">
<h4>4.4.6.5.3. Opening a Heap*MP Instance<a class="headerlink" href="#opening-a-heap-mp-instance" title="Permalink to this headline">¶</a></h4>
<p>Once a Heap*MP instance is created on a processor, the heap can be opened on another processor to obtain a local handle to the same shared instance.
In order for a remote processor to obtain a handle to a Heap*MP that has been created, the remote processor needs to open it using Heap*MP_open().</p>
<p>The Heap*MP modules use a NameServer instance to allow a remote processor to address the local Heap*MP instance using a user-configurable string value as an identifier.
The Heap*MP name is the sole parameter needed to identify an instance.</p>
<p>The heap must be created before it can be opened. An open call matches the call’s version number with the creator’s version number in order to ensure compatibility.
For example:</p>
<p>HeapBufMP_Handle heapHandle;
…</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Open heap created by other processor. Loop until open. */</span>
<span class="k">do</span> <span class="p">{</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">HeapBufMP_open</span><span class="p">(</span><span class="s">&quot;myHeap&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">heapHandle</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">while</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

<span class="cm">/* Register this heap with MessageQ */</span>
<span class="n">MessageQ_registerHeap</span><span class="p">(</span><span class="n">HeapBufMP_Handle_upCast</span><span class="p">(</span><span class="n">heapHandle</span><span class="p">),</span> <span class="n">HEAPID</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="closing-a-heap-mp-instance">
<h4>4.4.6.5.4. Closing a Heap*MP Instance<a class="headerlink" href="#closing-a-heap-mp-instance" title="Permalink to this headline">¶</a></h4>
<p>Heap*MP_close() frees an opened Heap*MP instance stored in local memory. Heap*MP_close() may only be used to finalize instances that were opened with Heap*MP_open() by this thread. For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">HeapBufMP_close</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heapHandle</span><span class="p">);</span>
</pre></div>
</div>
<p>Never call Heap*MP_close() if some other thread has already called Heap*MP_delete().</p>
</div>
<div class="section" id="deleting-a-heap-mp-instance">
<h4>4.4.6.5.5. Deleting a Heap*MP Instance<a class="headerlink" href="#deleting-a-heap-mp-instance" title="Permalink to this headline">¶</a></h4>
<p>The Heap*MP creator thread can use Heap*MP_delete() to free a Heap*MP object stored in local memory and to flag the shared memory to indicate that the heap is no longer initialized.
Heap*MP_delete() may not be used to finalize a heap using a handle acquired using Heap*MP_open()–Heap*MP_close() should be used by such threads instead.</p>
</div>
<div class="section" id="allocating-memory-from-the-heap">
<h4>4.4.6.5.6. Allocating Memory from the Heap<a class="headerlink" href="#allocating-memory-from-the-heap" title="Permalink to this headline">¶</a></h4>
<p>The HeapBufMP_alloc() function obtains the first buffer off the heap’s freeList.</p>
<p>The HeapMultiBufMP_alloc() function searches through the buckets to find the smallest size that honors the requested size.
It obtains the first block on that bucket.</p>
<p>If the “exact” field in the Heap*BufMP_Params structure was true when the heap was created, the alloc only returns the block if the blockSize for a bucket is the exact size requested.
If no exact size is found, an allocation error is returned.</p>
<p>The HeapMemMP_alloc() function allocates a block of memory of the requested size from the heap.</p>
<p>For all of these allocation functions, the cache coherency of the message is managed by the SharedRegion module that manages the shared memory region used for the heap.</p>
</div>
<div class="section" id="freeing-memory-to-the-heap">
<h4>4.4.6.5.7. Freeing Memory to the Heap<a class="headerlink" href="#freeing-memory-to-the-heap" title="Permalink to this headline">¶</a></h4>
<p>The HeapBufMP_free() function returns an allocated buffer to its heap.</p>
<p>The HeapMultiBufMP_free() function searches through the buckets to determine on which bucket the block should be returned.
This is determined by the same algorithm as the HeapMultiBufMP_alloc() function, namely the smallest blockSize that the block can fit into.</p>
<p>If the “exact” field in the Heap*BufMP_Params structure was true when the heap was created, and the size of the block to free does not match any bucket’s blockSize, an assert is raised.</p>
<p>The HeapMemMP_free() function returns the allocated block of memory to its heap.</p>
<p>For all of these deallocation functions, cache coherency is managed by the corresponding Heap*MP module.</p>
</div>
<div class="section" id="querying-heap-statistics">
<h4>4.4.6.5.8. Querying Heap Statistics<a class="headerlink" href="#querying-heap-statistics" title="Permalink to this headline">¶</a></h4>
<p>Both heap modules support use of the xdc.runtime.Memory module’s Memory_getStats() and Memory_query() functions on the heap.</p>
<p>In addition, the Heap*MP modules provide the Heap*MP_getStats(), Heap*MP_getExtendedStats(), and Heap*MP_isBlocking() functions to enable you to gather information about a heap.</p>
<p>By default, allocation tracking is often disabled in shared-heap modules for performance reasons.
You can set the HeapBufMP.trackAllocs and HeapMultiBufMP.trackMaxAllocs configuration properties to true in order to turn on allocation tracking for their respective modules.
Refer to the CDOC documentation for further information.</p>
<p>Sample Runtime Program Flow
The following diagram shows the program flow for a two-processor (or two-thread) application.
This application creates a Heap*MP instance dynamically.</p>
<img alt="rtos/../images/heapmp_bigfig.png" src="rtos/../images/heapmp_bigfig.png" />
</div>
</div>
<div class="section" id="gatemp-module">
<h3>4.4.6.6. GateMP Module<a class="headerlink" href="#gatemp-module" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" colspan="2"><p>API Reference Links</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html"><img alt="gpmCfg_Img1" src="../_images/Book_cfg.png" /></a></p></td>
<td><p><a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_gate_m_p_8h.html"><img alt="gmpRun_Img1" src="../_images/Book_run.png" /></a></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>A GateMP instance can be used to enforce both local and remote context protection.
That is, entering a GateMP can prevent preemption by another thread/process running on the
same processor and simultaneously prevent a remote processor from entering the same gate.
GateMP’s are typically used to protect reads/writes to a shared resource, such as shared memory.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Initial IPC 3.x releases only supported GateMP on BIOS. It was introduced on QNX in IPC 3.10, and on Linux/Android in 3.21.</p>
</div>
<div class="section" id="creating-a-gatemp-instance">
<h4>4.4.6.6.1. Creating a GateMP Instance<a class="headerlink" href="#creating-a-gatemp-instance" title="Permalink to this headline">¶</a></h4>
<p>As with other IPC modules, GateMP instances can only be created dynamically.</p>
<p>Before creating the GateMP instance, you initialize a GateMP_Params structure and set fields in the structure to the desired values.
You then use the GateMP_create() function to dynamically create a GateMP instance.</p>
<p>When you create a gate, shared memory is initialized, but the GateMP object is created in local memory. Only the gate information resides in shared memory.</p>
<p>The following code creates a GateMP object:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">GateMP_Params</span> <span class="n">gparams</span><span class="p">;</span>
<span class="n">GateMP_Handle</span> <span class="n">gateHandle</span><span class="p">;</span>

<span class="n">GateMP_Params_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gparams</span><span class="p">);</span>
<span class="n">gparams</span><span class="p">.</span><span class="n">localProtect</span> <span class="o">=</span> <span class="n">GateMP_LocalProtect_THREAD</span><span class="p">;</span>
<span class="n">gparams</span><span class="p">.</span><span class="n">remoteProtect</span> <span class="o">=</span> <span class="n">GateMP_RemoteProtect_SYSTEM</span><span class="p">;</span>
<span class="n">gparams</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;myGate&quot;</span><span class="p">;</span>
<span class="n">gparams</span><span class="p">.</span><span class="n">regionId</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">gateHandle</span> <span class="o">=</span> <span class="n">GateMP_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gparams</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</pre></div>
</div>
<p>A gate can be configured to implement remote processor protection in various ways.
This is done via the params.remoteProtect configuration property.
The options for params.remoteProtect are as follows:</p>
<ul class="simple">
<li><p>GateMP_RemoteProtect_NONE. Creates only the local gate specified by the localProtect property.</p></li>
<li><p>GateMP_RemoteProtect_SYSTEM. Uses the default device-specific gate protection mechanism for your device.
Internally, GateMP automatically uses device-specific implementations of multi-processor mutexes implemented via a variety of hardware mechanisms.
Devices typically support a single type of system gate, so this is usually the correct configuration setting for params.remoteProtect.</p></li>
<li><p>GateMP_RemoteProtect_CUSTOM1 and GateMP_RemoteProtect_CUSTOM2 (BIOS-only). Some devices support multiple types of system gates.
If you know that GateMP has multiple implementations of gates for your device, you can use one of these options.</p></li>
</ul>
<p>Several gate implementations used internally for remote protection are provided in the ti.sdo.ipc.gates package.</p>
<p>A gate can be configured to implement local protection at various levels.
This is done via the params.localProtect configuration property (BIOS-only).
The options for params.localProtect are as follows:</p>
<ul class="simple">
<li><p>GateMP_LocalProtect_NONE. Uses the XDCtools GateNull implementation, which does not offer any local context protection.
For example, you might use this option for a single-threaded local application that still needs remote protection.</p></li>
<li><p>GateMP_LocalProtect_INTERRUPT. Uses the SYS/BIOS GateHwi implementation, which disables hardware interrupts.</p></li>
<li><p>GateMP_LocalProtect_TASKLET. Uses the SYS/BIOS GateSwi implementation, which disables software interrupts.</p></li>
<li><p>GateMP_LocalProtect_THREAD. Uses the SYS/BIOS GateMutexPri implementation, which is based on Semaphores.
This option may use a different gate than the following option on some operating systems. When using SYS/BIOS, they are equivalent.</p></li>
<li><p>GateMP_LocalProtect_PROCESS. Uses the SYS/BIOS GateMutexPri implementation, which is based on Semaphores.</p></li>
</ul>
<p>This property is currently ignored (as of IPC 3.23) on non-BIOS OSes.
A thread-level mutex is used for local protection independent of this property setting.</p>
<p>Other fields you are required to set in the GateMP_Params structure are:</p>
<ul class="simple">
<li><p>name. The name of the GateMP instance.</p></li>
<li><p>regionId. The ID of the SharedRegion to use for shared memory used by this GateMP instance (BIOS-only).</p></li>
</ul>
<p><a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_gate_m_p_8h.html"><img alt="gmpRun_Img2" src="../_images/Book_run.png" /></a> The latest version of the GateMP module run-time API documentation is available
<a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_gate_m_p_8h.html">online</a></p>
</div>
<div class="section" id="opening-a-gatemp-instance">
<h4>4.4.6.6.2. Opening a GateMP Instance<a class="headerlink" href="#opening-a-gatemp-instance" title="Permalink to this headline">¶</a></h4>
<p>Once an instance is created on a processor, the gate can be opened on another processor to obtain a local handle to the same instance.</p>
<p>The GateMP module uses a NameServer instance to allow a remote processor to address the local GateMP instance using
a user-configurable string value as an identifier rather than a potentially dynamic address value.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">status</span> <span class="o">=</span> <span class="n">GateMP_open</span><span class="p">(</span><span class="s">&quot;myGate&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gateHandle</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">System_printf</span><span class="p">(</span><span class="s">&quot;GateMP_open failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="closing-a-gatemp-instance">
<h4>4.4.6.6.3. Closing a GateMP Instance<a class="headerlink" href="#closing-a-gatemp-instance" title="Permalink to this headline">¶</a></h4>
<p>GateMP_close() frees a GateMP object stored in local memory.</p>
<p>GateMP_close() should never be called on an instance whose creator has been deleted.</p>
</div>
<div class="section" id="deleting-a-gatemp-instance">
<h4>4.4.6.6.4. Deleting a GateMP Instance<a class="headerlink" href="#deleting-a-gatemp-instance" title="Permalink to this headline">¶</a></h4>
<p>GateMP_delete() frees a GateMP object stored in local memory and flags the shared memory to indicate that the gate is no longer initialized.</p>
<p>A thread may not use GateMP_delete() if it acquired the handle to the gate using GateMP_open(). Such threads should call GateMP_close() instead.</p>
</div>
<div class="section" id="entering-a-gatemp-instance">
<h4>4.4.6.6.5. Entering a GateMP Instance<a class="headerlink" href="#entering-a-gatemp-instance" title="Permalink to this headline">¶</a></h4>
<p>Either the GateMP creator or opener may call GateMP_enter() to enter a gate.
While it is necessary for the opener to wait for a gate to be created to enter a created gate,
it isn’t necessary for a creator to wait for a gate to be opened before entering it.</p>
<p>GateMP_enter() enters the caller’s local gate. The local gate (if supplied) blocks if entered on the local processor.
If entered by the remote processor, GateMP_enter() spins until the remote processor has left the gate.</p>
<p>No matter what the params.localProtection configuration property is set to, after GateMP_enter() returns,
the caller has exclusive access to the data protected by this gate.</p>
<p>A thread may reenter a gate without blocking or failing.</p>
<p>GateMP_enter() returns a “key” that is used by GateMP_leave() to leave this gate;
this value is used to restore thread preemption to the state that existed just prior to entering this gate.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">IArg</span> <span class="n">key</span><span class="p">;</span>

<span class="cm">/* Enter the gate */</span>
<span class="n">key</span> <span class="o">=</span> <span class="n">GateMP_enter</span><span class="p">(</span><span class="n">gateHandle</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="leaving-a-gatemp-instance">
<h4>4.4.6.6.6. Leaving a GateMP Instance<a class="headerlink" href="#leaving-a-gatemp-instance" title="Permalink to this headline">¶</a></h4>
<p>GateMP_leave() may only called by a thread that has previously entered this gate via GateMP_enter().</p>
<p>After this method returns, the caller must not access the data structure
protected by this gate (unless the caller has entered the gate more than once and other calls to leave remain to balance the number of previous calls to enter).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">IArg</span> <span class="n">key</span><span class="p">;</span>

<span class="cm">/* Leave the gate */</span>
<span class="n">GateMP_leave</span><span class="p">(</span><span class="n">gateHandle</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="querying-a-gatemp-instance">
<h4>4.4.6.6.7. Querying a GateMP Instance<a class="headerlink" href="#querying-a-gatemp-instance" title="Permalink to this headline">¶</a></h4>
<p>GateMP_query() returns TRUE if a gate has a given quality, and FALSE otherwise, including cases when the gate does not recognize the constant describing the quality. The qualities you can query are:</p>
<ul class="simple">
<li><p>GateMP_Q_BLOCKING. If GateMP_Q__BLOCKING is FALSE, the gate never blocks.</p></li>
<li><p>GateMP_Q_PREEMPTING. If GateMP_Q_PREEMPTING is FALSE, the gate does not allow other threads to preempt the thread that has already entered the gate.</p></li>
</ul>
</div>
<div class="section" id="nameserver-interaction">
<h4>4.4.6.6.8. NameServer Interaction<a class="headerlink" href="#nameserver-interaction" title="Permalink to this headline">¶</a></h4>
<p>The GateMP module uses a ti.sdo.utils.NameServer instance to store instance information when an instance is created and the name parameter is non-NULL.
The length of this name is limited to 16 characters (by default) including the null terminator (‘0’).
This length can be increased by configuring the GateMP.maxNameLen module configuration property.
If a name is supplied, it must be unique for all GateMP instances.</p>
<p>Other modules can use GateMP instances to protect access to their shared memory resources.
For example, the NameServer name tables are protected by setting the “gate” property of the ti.sdo.utils.NameServer module.</p>
<p>These examples set the “gate” property for various modules:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">heapBufMPParams</span><span class="p">.</span><span class="n">gate</span>  <span class="o">=</span> <span class="n">GateMP_getDefaultRemote</span><span class="p">();</span>
<span class="n">listMPParams</span><span class="p">.</span><span class="n">gate</span>     <span class="o">=</span> <span class="n">gateHandle</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id22">
<h4>4.4.6.6.9. Sample Runtime Program Flow (Dynamic)<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h4>
<p>The following diagram shows the program flow for a two-processor (or two-thread) application.
This application creates a Gate dynamically.</p>
<img alt="../_images/IpcUG_ipc_2_6_1.png" src="../_images/IpcUG_ipc_2_6_1.png" />
</div>
</div>
<div class="section" id="gatemp-support-for-uio-and-misc-driver">
<h3>4.4.6.7. GateMP Support for UIO and Misc Driver<a class="headerlink" href="#gatemp-support-for-uio-and-misc-driver" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id23">
<h4>4.4.6.7.1. Introduction<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h4>
<p>Starting in IPC 3.42, the GateMP module added support for accessing
device memory without using /dev/mem. Instead of accessing /dev/mem, a
uio driver for Shared Region 0 access and a misc driver to expose a
hwspinlock user interface can be used. These drivers are added in the
Android SDK and GLSDK kernels. This feature was added because in some
environments, /dev/mem may not be accessible to the LAD.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no change to how LAD is launched in this case, and if the uio
and misc driver are not available in the kernel, it will fall back to
using /dev/mem.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This applies only to Linux/Android IPC.</p>
</div>
</div>
<div class="section" id="config">
<h4>4.4.6.7.2. Config<a class="headerlink" href="#config" title="Permalink to this headline">¶</a></h4>
<p>Enable the uio and misc drivers in the kernel by enabling the following
config options:</p>
<p>CONFIG_HWSPINLOCK_USER=y
CONFIG_UIO=y
CONFIG_UIO_PDRV_GENIRQ=y
Update your dts file to define the hwspinlocks being used by the misc
driver. Must start from hwspinlock “0” and go up sequentially:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">gatemp</span> <span class="p">{</span>
        <span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;hwspinlock-user&quot;</span><span class="p">;</span>
        <span class="n">hwlocks</span> <span class="o">=</span> <span class="o">&lt;&amp;</span><span class="n">hwspinlock</span> <span class="mi">0</span><span class="o">&gt;</span><span class="p">,</span>
                  <span class="o">&lt;&amp;</span><span class="n">hwspinlock</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span>
                  <span class="o">&lt;&amp;</span><span class="n">hwspinlock</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span>
                  <span class="o">&lt;&amp;</span><span class="n">hwspinlock</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">,</span>
                  <span class="o">&lt;&amp;</span><span class="n">hwspinlock</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">,</span>
                  <span class="o">&lt;&amp;</span><span class="n">hwspinlock</span> <span class="mi">5</span><span class="o">&gt;</span><span class="p">,</span>
                  <span class="o">&lt;&amp;</span><span class="n">hwspinlock</span> <span class="mi">6</span><span class="o">&gt;</span><span class="p">,</span>
                  <span class="o">&lt;&amp;</span><span class="n">hwspinlock</span> <span class="mi">7</span><span class="o">&gt;</span><span class="p">,</span>
                  <span class="o">&lt;&amp;</span><span class="n">hwspinlock</span> <span class="mi">8</span><span class="o">&gt;</span><span class="p">,</span>
                  <span class="o">&lt;&amp;</span><span class="n">hwspinlock</span> <span class="mi">9</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The hwspinlock configuration in the dts file MUST match the BIOS-side
IPC HWSpinlock configuration. Configuration the BIOS-side IPC module by
adding the following to your cfg file (where &lt;N&gt; is equal to the number
of spinlocks in the dts listing):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>var HWSpinlock = xdc.useModule(‘ti.sdo.ipc.gates.GateHWSpinlock’);
HWSpinlock.numLocks = &lt;N&gt;;
</pre></div>
</div>
<p>Update your dts file to add the UIO-based node for Shared Region 0
(modify address and size so that it matches the Shared Region 0
definition in the remote core image):</p>
<p>Kernel 3.14-based releases:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">sr0</span> <span class="p">{</span>
        <span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;generic-uio&quot;</span><span class="p">;</span>
        <span class="n">reg</span> <span class="o">=</span> <span class="o">&lt;</span><span class="mh">0xbfd00000</span> <span class="mh">0x100000</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Kernel 4.4-based releases:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">sr0</span> <span class="p">{</span>
        <span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;generic-uio&quot;</span><span class="p">;</span>
        <span class="n">reg</span> <span class="o">=</span> <span class="o">&lt;</span><span class="mh">0x0</span> <span class="mh">0xbfb00000</span> <span class="mh">0x0</span> <span class="mh">0x100000</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Make sure that the “compatible” property in the sr0 dts node matches the
UIO’s of_id string defined in the kernel command line.</p>
</div>
<p>Append the following to the kernel’s CONFIG_CMDLINE:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">uio_pdrv_genirq</span><span class="p">.</span><span class="n">of_id</span><span class="o">=</span><span class="n">generic</span><span class="o">-</span><span class="n">uio</span>
</pre></div>
</div>
<p>For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">CONFIG_CMDLINE</span><span class="o">=</span><span class="s">&quot;root=/dev/mmcblk0p2 rw console=ttyS0,119200 androidboot.console=ttyS0 init=/init rootfstype=ext4 rootwait drm.rnodes=1 snd.slots_reserved=1,1 androidboot.selinux=permissive androidboot.hardware=jacinto6evmboard uio_pdrv_genirq.of_id=generic-uio&quot;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Changes for the command line are already present in the Android 6AM.1.0
release. For GLSDK, the command line comes from the bootargs set in the
uenv.txt file in the boot partition.</p>
</div>
<p>Also, specific owner/group must be set for the following files:</p>
<ul class="simple">
<li><p>/dev/uio0</p></li>
<li><p>/dev/hwspinlock</p></li>
<li><p><strong>Android:</strong> /data/lad, /data/lad/LAD</p></li>
<li><p><strong>Linux:</strong> /tmp/LAD</p></li>
</ul>
</div>
</div>
<div class="section" id="notify-module">
<h3>4.4.6.8. Notify Module<a class="headerlink" href="#notify-module" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" colspan="2"><p>API Reference Links</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html"><img alt="notCfg_Img1" src="../_images/Book_cfg.png" /></a></p></td>
<td><p><a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_notify_8h.html"><img alt="notRun_Img1" src="../_images/Book_run.png" /></a></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>he ti.sdo.ipc.Notify module manages the multiplexing/demultiplexing of software interrupts over hardware interrupts.
In order to use any Notify APIs, you must first call Ipc_start(). This sets up all the necessary Notify drivers, shared memory, and interprocessor interrupts. However, note that if you’ve configured Ipc.setupNotify = false, you will need to explicitly call Notify_start() outside the scope of Ipc_start().</p>
<p>To be able to receive notifications, a processor registers one or more callback functions to an eventId by calling Notify_registerEvent(). The callback function must have the following signature:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Void</span> <span class="nf">cbFxn</span><span class="p">(</span><span class="n">UInt16</span> <span class="n">procId</span><span class="p">,</span> <span class="n">UInt16</span> <span class="n">lineId</span><span class="p">,</span> <span class="n">UInt32</span> <span class="n">eventId</span><span class="p">,</span> <span class="n">UArg</span> <span class="n">arg</span><span class="p">,</span> <span class="n">UInt32</span> <span class="n">payload</span><span class="p">);</span>
</pre></div>
</div>
<p>Notify_registerEvent(), like most other Notify APIs, uses a MultiProc ID and line ID to target a specific interrupt line to/from a specific processor on a device.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Int</span> <span class="n">status</span><span class="p">;</span>
<span class="n">armProcId</span> <span class="o">=</span> <span class="n">MultiProc_getId</span><span class="p">(</span><span class="s">&quot;ARM&quot;</span><span class="p">);</span>

<span class="n">Ipc_start</span><span class="p">();</span>

<span class="cm">/* Register cbFxn with Notify. It will be called when ARM</span>
<span class="cm"> * sends event number EVENTID to line #0 on this processor.</span>
<span class="cm"> * The argument 0x1010 is passed to the callback function. */</span>
<span class="n">status</span> <span class="o">=</span> <span class="n">Notify_registerEvent</span><span class="p">(</span><span class="n">armProcId</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">EVENTID</span><span class="p">,</span>
                 <span class="p">(</span><span class="n">Notify_FnNotifyCbck</span><span class="p">)</span><span class="n">cbFxn</span><span class="p">,</span> <span class="mh">0x1010</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">System_abort</span><span class="p">(</span><span class="s">&quot;Notify_registerEvent failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The line ID number is typically 0 (zero), but is provided for use on systems that have multiple interrupt lines between processors.</p>
<p>When using Notify_registerEvent(), multiple callbacks may be registered with a single event. If you plan to register only one callback function for an event on this processor, you can call Notify_registerEventSingle() instead of Notify_registerEvent(). Better performance is provided with Notify_registerEventSingle(), and a Notify_E_ALREADYEXISTS status is returned if you try to register a second callback for the same event.</p>
<p>Once an event has been registered, a remote processor may “send” an event by calling Notify_sendEvent(). If the specified event and interrupt line are both enabled, all callback functions registered to the event will be called sequentially.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="n">seq</span> <span class="o">&lt;</span> <span class="n">NUMLOOPS</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Semaphore_pend</span><span class="p">(</span><span class="n">semHandle</span><span class="p">,</span> <span class="n">BIOS_WAIT_FOREVER</span><span class="p">);</span>
  <span class="cm">/* Semaphore_post is called by callback function*/</span>
  <span class="n">status</span> <span class="o">=</span> <span class="n">Notify_sendEvent</span><span class="p">(</span><span class="n">armProcId</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">EVENTID</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example, the seq variable is sent as the “payload” along with the event. The payload is limited to a fixed size of 32 bits.</p>
<p>Since the fifth argument in the previous example call to Notify_sendEvent() is TRUE, if any previous event to the same event ID was sent, the Notify driver waits for an acknowledgement that the previous event was received.</p>
<p>A specific event may be disabled or enabled using Notify_disableEvent() and Notify_enableEvent(). All notifications on an entire interrupt line may be disabled or restored using Notify_disable() and Notify_restore() calls. Notify_disable() does not alter the state of individual events. Instead, it just disables the ability of the Notify module to receive events on the specified interrupt line.</p>
<p>“Loopback” mode, which is enabled by default, allows notifications to be registered and sent locally. This is accomplished by supplying the processor’s own MultiProc ID to Notify APIs. Line ID 0 (zero) is always used for local notifications. It is important to be aware of some subtle (but important) differences between remote and local notifications:</p>
<blockquote>
<div><ul class="simple">
<li><p>Loopback callback functions execute in the context of the same thread that called Notify_sendEvent(). This is in contrast to callback functions called due to another processor’s sent notification–such “remote” callback functions execute in an ISR context.</p></li>
<li><p>Loopback callback functions execute with interrupts disabled.</p></li>
<li><p>Disabling the local interrupt line causes all notifications that are sent to the local processor to be lost. By contrast, a notification sent to an enabled event on a remote processor that has called Notify_disableEvent() results in a pending notification until the disabled processor has called Notify_restore().</p></li>
<li><p>Local notifications do not support events of different priorities. By contrast, Notify driver implementations may correlate event IDs with varying priorities.</p></li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Notify Module is only supported in SYS/BIOS environments. It is not provided on HLOS’s.</p>
</div>
</div>
<div class="section" id="shared-region-module">
<h3>4.4.6.9. Shared Region Module<a class="headerlink" href="#shared-region-module" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" colspan="2"><p>API Reference Links</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html"><img alt="srmCfg_Img1" src="../_images/Book_cfg.png" /></a></p></td>
<td><p><a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_multi_proc_8h.html"><img alt="srmRun_Img1" src="../_images/Book_run.png" /></a></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The SharedRegion module is designed to be used in a multi-processor environment where there are memory regions that are shared and accessed across different processors.
In an environment with shared memory regions, a common problem is that these shared regions are memory mapped to different address spaces on different processors. This is shown in the following figure. The shared memory region “DDR2” is mapped into Proc0’s local memory space at base address 0x80000000 and Proc1’s local memory space at base address 0x90000000. Therefore, the pointers in “DDR2” need to be translated in order for them to be portable between Proc0 and Proc1. The local memory regions for Proc0 and Proc1 are not shared thus they do not need to be added to the SharedRegion module.</p>
<img alt="../_images/IpcUG_ipc_2_8_1.png" src="../_images/IpcUG_ipc_2_8_1.png" />
<p>On systems where address translation is not required, translation is a noop, so performance is not affected.</p>
<p>The SharedRegion module itself does not use any shared memory, because all of its state is stored locally. The APIs use the system gate for thread protection.</p>
<p>This module creates a shared memory region lookup table. The lookup table contains the processor’s view of every shared region in the system. In cases where a processor cannot view a certain shared memory region, that shared memory region should be left invalid for that processor. Each processor has its own lookup table.</p>
<p>Each processor’s view of a particular shared memory region can be determined by the same region ID across all lookup tables. At runtime, this table, along with the shared region pointer, is used to do a quick address translation.</p>
<p>The lookup table contains the following information about each shared region:</p>
<blockquote>
<div><ul class="simple">
<li><p>base. The base address of the region. This may be different on different processors, depending on their addressing schemes.</p></li>
<li><p>len. The length of the region. This should be should be the same across all processors.</p></li>
<li><p>ownerProcId. MultiProc ID of the processor that manages this region. If an owner is specified, the owner creates a HeapMemMP instance at runtime. The other cores open the same HeapMemMP instance.</p></li>
<li><p>isValid. Boolean to specify whether the region is valid (accessible) or not on this processor.</p></li>
<li><p>cacheEnable. Boolean to specify whether a cache is enabled for the region on the local processor.</p></li>
<li><p>cacheLineSize. The cache line size for the region. It is crucial that the value specified here be the same on all processors.</p></li>
<li><p>createHeap. Boolean to specify if a heap is created for the region.</p></li>
<li><p>name. The name associated with the region.</p></li>
</ul>
</div></blockquote>
<p>The maximum number of entries in the lookup table is statically configurable using the SharedRegion.numEntries property. Entries can be added during static configuration or at runtime. When you add or remove an entry in one processor’s table, you must update all of the remaining processors’ tables to keep them consistent. The larger the maximum number of entries, the longer it will take to traverse the lookup table when searching for the index. Therefore, keep the lookup table small for better performance and footprint.</p>
<p>Because each processor stores information about the caching of a shared memory region in the SharedRegion lookup table, other modules can (and do) make use of this caching information to maintain coherency and alignment when using items stored in shared memory.</p>
<p>In order to use the SharedRegion module, the following must be true:</p>
<blockquote>
<div><ul class="simple">
<li><p>The SharedRegion.numEntries property must be the same on all processors.</p></li>
<li><p>The size of a SharedRegion pointer is 32-bits wide.</p></li>
<li><p>The SharedRegion lookup table must contain at least 1 entry for address translation to occur.</p></li>
<li><p>Shared memory regions must not overlap each other from a single processor’s viewpoint.</p></li>
<li><p>Regions are not allowed to overlap from a single processor’s view.</p></li>
</ul>
</div></blockquote>
<p>The SharedRegion with an index of 0 (zero) is used by IPC_start() to create resource management tables for internal use by other IPC modules. Thus SharedRegion “0” must be accessible by all processors. Your applications can also make use of SharedRegion “0”, but must be aware of memory limitations.</p>
<div class="section" id="adding-table-entries-statically">
<h4>4.4.6.9.1. Adding Table Entries Statically<a class="headerlink" href="#adding-table-entries-statically" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>To create a shared region lookup table in the XDCtools configuration, first determine the shared memory regions you plan to use.</p>
</div></blockquote>
<p>Next, specify the maximum number of entries in the lookup table with the SharedRegion.numEntries property. You can specify a value for the SharedRegion.cacheLineSize configuration property, which is the default cache line size if no size is specified for a region. You can also specify the value of the SharedRegion.translate property, which should only be set to false if all shared memory regions have the same base address on all processors. Setting the translate property to false improves performance because no address translation is performed.</p>
<p>For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>var SharedRegion = xdc.useModule(&#39;ti.sdo.ipc.SharedRegion&#39;);
SharedRegion.cacheLineSize = 32;
SharedRegion.numEntries = 4;
SharedRegion.translate = true;
</pre></div>
</div>
<p>Then, use the SharedRegion.setEntryMeta() method in the configuration file to specify the parameters of the entry.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">SHAREDMEM</span>      <span class="o">=</span> <span class="mh">0x0C000000</span><span class="p">;</span>
<span class="n">var</span> <span class="n">SHAREDMEMSIZE</span>  <span class="o">=</span> <span class="mh">0x00200000</span><span class="p">;</span>

<span class="n">SharedRegion</span><span class="p">.</span><span class="n">setEntryMeta</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">{</span> <span class="nl">base</span><span class="p">:</span> <span class="n">SHAREDMEM</span><span class="p">,</span>
      <span class="nl">len</span><span class="p">:</span> <span class="n">SHAREDMEMSIZE</span><span class="p">,</span>
      <span class="nl">ownerProcId</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="nl">isValid</span><span class="p">:</span> <span class="nb">true</span><span class="p">,</span>
      <span class="nl">cacheEnable</span><span class="p">:</span> <span class="nb">true</span><span class="p">,</span>
      <span class="nl">cacheLineSize</span><span class="p">:</span> <span class="mi">128</span><span class="p">,</span>
      <span class="nl">createHeap</span><span class="p">:</span> <span class="nb">true</span><span class="p">,</span>
      <span class="nl">name</span><span class="p">:</span> <span class="s">&quot;internal_shared_mem&quot;</span>
<span class="p">});</span>
</pre></div>
</div>
<p>If, during static configuration, you don’t know the base address for every processor, you should set the “isValid” field for an entry for which you don’t yet know the base address to “false”. Storing this information will allow it to be completed at runtime.</p>
<p>The following figure shows the configuration of a SharedRegion table for the system in the following figure. This system has seven processors and two shared memory regions. Region 0 (“ext”) is accessible by all processors. Region 1 (“local”) is accessible only by processors 1 to 6.</p>
<img alt="../_images/IpcUG_ipc_2_8_2.png" src="../_images/IpcUG_ipc_2_8_2.png" />
<p>If the “createHeap” field is set to true, a HeapMemMP instance is created within the SharedRegion.</p>
<p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html"><img alt="srmCfg_Img2" src="../_images/Book_cfg.png" /></a> The latest version of the SharedRegion module configuration documentation is available
<a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/index.html#ti/sdo/ipc/SharedRegion.html">online</a>.</p>
</div>
<div class="section" id="modifying-table-entries-dynamically">
<h4>4.4.6.9.2. Modifying Table Entries Dynamically<a class="headerlink" href="#modifying-table-entries-dynamically" title="Permalink to this headline">¶</a></h4>
<p>In the application’s C code, a shared memory region can be modified in the SharedRegion table by calling SharedRegion_setEntry().</p>
<p>Typically, applications configure SharedRegion table entries statically as described in the previous section, and only modify the table entries dynamically in applications where it is possible for shared memory region availability to change dynamically.</p>
<p>The call to SharedRegion_setEntry() must specify all the fields in the SharedRegion_Entry structure. The index specified must be the same across all processors for the same shared memory region. The index also must be smaller than the maxNumEntries property, otherwise an assert will be triggered.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">SharedRegion_Entry</span> <span class="p">{</span>
  <span class="n">Ptr</span> <span class="n">base</span><span class="p">;</span>
  <span class="n">SizeT</span> <span class="n">len</span><span class="p">;</span>
  <span class="n">UInt16</span> <span class="n">ownerProcId</span><span class="p">;</span>
  <span class="n">Bool</span> <span class="n">isValid</span><span class="p">;</span>
  <span class="n">Bool</span> <span class="n">cacheEnable</span><span class="p">;</span>
  <span class="n">SizeT</span> <span class="n">cacheLineSize</span><span class="p">;</span>
  <span class="n">Bool</span> <span class="n">createHeap</span><span class="p">;</span>
  <span class="n">String</span> <span class="n">name</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SharedRegion_Entry</span><span class="p">;</span>
</pre></div>
</div>
<p>You can use SharedRegion_getEntry() to fill the fields in a SharedRegion_Entry structure. Then, you can modify fields in the structure and call SharedRegion_setEntry() to write the modified fields back to the SharedRegion table.</p>
<p>If you want to reuse an index location in the SharedRegion table, you can call SharedRegion_clear() on all processors to erase the existing entry at that index location.</p>
<p><a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_multi_proc_8h.html"><img alt="srmRun_Img2" src="../_images/Book_run.png" /></a> The latest version of the SharedRegion module run-time API documentation is available
<a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_shared_region_8h.html">online</a>.</p>
</div>
<div class="section" id="using-memory-in-a-shared-region">
<h4>4.4.6.9.3. Using Memory in a Shared Region<a class="headerlink" href="#using-memory-in-a-shared-region" title="Permalink to this headline">¶</a></h4>
<p>Note that the SharedRegion with an index of 0 (zero) is used by IPC_start() to create resource management tables for internal use by the GateMP, NameServer, and Notify modules. Thus SharedRegion “0” must be accessible by all processors.</p>
<p>This example allocates memory from a SharedRegion:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">buf</span> <span class="o">=</span> <span class="n">Memory_alloc</span><span class="p">(</span><span class="n">SharedRegion_getHeap</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Tester</span><span class="p">)</span> <span class="o">*</span> <span class="n">COUNT</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="getting-information-about-a-shared-region">
<h4>4.4.6.9.4. Getting Information About a Shared Region<a class="headerlink" href="#getting-information-about-a-shared-region" title="Permalink to this headline">¶</a></h4>
<p>The shared region pointer (SRPtr) is a 32-bit portable pointer composed of an ID and offset. The most significant bits of a SRPtr are used for the ID. The ID corresponds to the index of the entry in the lookup table. The offset is the offset from the base of the shared memory region. The maximum number of table entries in the lookup table determines the number of bits to be used for the ID. An increase in the id means the range of the offset would decrease. The ID is limited to 16-bits.</p>
<p>Here is sample code for getting the SRPtr and then getting the real address pointer back.</p>
<p>SharedRegion_SRPtr srptr;
UInt16 id;</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Get the id of the address if id is not already known.</span>
<span class="n">id</span> <span class="o">=</span> <span class="n">SharedRegion_getId</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

<span class="c1">// Get the shared region pointer for the address</span>
<span class="n">srptr</span> <span class="o">=</span> <span class="n">SharedRegion_getSRPtr</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>

<span class="c1">// Get the address back from the shared region pointer</span>
<span class="n">addr</span> <span class="o">=</span> <span class="n">SharedRegion_getPtr</span><span class="p">(</span><span class="n">srptr</span><span class="p">);</span>
</pre></div>
</div>
<p>In addition, you can use the SharedRegion_getIdByName() function to pass the name of a SharedRegion and receive the ID number of the region.</p>
<p>You can use SharedRegion_getHeap() to get a handle to the heap associated with a region using the heap ID.</p>
<p>You can retrieve a specific shared region’s cache configuration from the SharedRegion table by using SharedRegion_isCacheEnabled() and SharedRegion_getCacheLineSize().</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The SharedRegion Module is only supported in SYS/BIOS environments. It is not provided on HLOS’s. For HLOS environments, we suggest using native shared memory APIs when available, for example ION on Android. Other alternatives include CMEM (for Linux) and the QNX-specific SharedMemoryAlloctor, provided in IPC’s qnx/ directory.</p>
</div>
</div>
</div>
</div>
<div class="section" id="ti-sdo-utils-package">
<h2>4.4.7. TI SDO Utils Package<a class="headerlink" href="#ti-sdo-utils-package" title="Permalink to this headline">¶</a></h2>
<p>This page introduces the modules in the ti.sdo.utils package.</p>
<p>The ti.sdo.utils package contains modules that are used as utilities by other modules in the IPC product.</p>
<ul class="simple">
<li><p>List. This module provides a doubly-linked list manager for use by other modules. See List Module.</p></li>
<li><p>MultiProc. This module stores processor IDs in a centralized location for multi-processor applications. See MultiProc Module.</p></li>
<li><p>NameServer. This module manages name/value pairs for use by other modules. See NameServer Module.</p></li>
</ul>
<div class="section" id="list-module">
<h3>4.4.7.1. List Module<a class="headerlink" href="#list-module" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" colspan="2"><p>API Reference Links</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html"><img alt="lisCfg_Img1" src="../_images/Book_cfg.png" /></a></p></td>
<td><p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/syslink/latest/docs/html/_list_8h.html"><img alt="lisRun_Img1" src="../_images/Book_run.png" /></a></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The ti.sdo.utils.List module provides support for creating lists of objects.
A List is implemented as a doubly-linked list, so that elements can be inserted or removed
from anywhere in the list. Lists do not have a maximum size.</p>
<div class="section" id="basic-fifo-operation-of-a-list">
<h4>4.4.7.1.1. Basic FIFO Operation of a List<a class="headerlink" href="#basic-fifo-operation-of-a-list" title="Permalink to this headline">¶</a></h4>
<p>To add a structure to a List, its first field needs to be of type List_Elem.
The following example shows a structure that can be added to a List.
A List has a “head”, which is the front of the list.
List_put() adds elements to the back of the list, and List_get() removes and returns
the element at the head of the list. Together, these functions support a FIFO queue.</p>
<p><strong>Run-time example:</strong> The following example demonstrates the basic List operations–List_put() and List_get().</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* This structure can be added to a List because the first</span>
<span class="cm"> * field is a List_Elem. Declared globally. */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Rec</span> <span class="p">{</span>
    <span class="n">List_Elem</span> <span class="n">elem</span><span class="p">;</span>
    <span class="n">Int</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Rec</span><span class="p">;</span>

<span class="p">...</span>

<span class="n">List_Handle</span> <span class="n">myList</span><span class="p">;</span>              <span class="cm">/* in main() */</span>
<span class="n">Rec</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">;</span>
<span class="n">Rec</span><span class="o">*</span> <span class="n">rp</span><span class="p">;</span>

<span class="n">r1</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="n">r2</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>

<span class="cm">/* No parameters are needed to create a List. */</span>
<span class="n">myList</span> <span class="o">=</span> <span class="n">List_create</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="cm">/* Add r1 and r2 to the back of myList. */</span>
<span class="n">List_put</span><span class="p">(</span><span class="n">myList</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">r1</span><span class="p">.</span><span class="n">elem</span><span class="p">));</span>
<span class="n">List_put</span><span class="p">(</span><span class="n">myList</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">r2</span><span class="p">.</span><span class="n">elem</span><span class="p">));</span>

<span class="cm">/* get the records and print their data */</span>
<span class="k">while</span> <span class="p">((</span><span class="n">rp</span> <span class="o">=</span> <span class="n">List_get</span><span class="p">(</span><span class="n">myList</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">System_printf</span><span class="p">(</span><span class="s">&quot;rec: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The example prints the following:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="nl">rec</span><span class="p">:</span> <span class="mi">100</span>
<span class="nl">rec</span><span class="p">:</span> <span class="mi">200</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="iterating-over-a-list">
<h4>4.4.7.1.2. Iterating Over a List<a class="headerlink" href="#iterating-over-a-list" title="Permalink to this headline">¶</a></h4>
<p>The List module also provides several APIs for looping over a List.</p>
<p>List_next() with NULL returns the element at the front of the List (without removing it).
List_next() with an elem returns the next elem. NULL is returned when the end of the List is reached.</p>
<p>Similarly, List_prev() with NULL returns the tail. List_prev() with an elem returns the previous elem.
NULL is returned when the beginning of the List is reached.</p>
<p><strong>Run-time example:</strong> The following example demonstrates one way to iterate over a List
once from beginning to end. In this example, “myList” is a List_Handle.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">List_Elem</span>   <span class="o">*</span><span class="n">elem</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">Rec</span><span class="o">*</span> <span class="n">rp</span><span class="p">;</span>

<span class="p">...</span>

<span class="cm">/* To start the search at the beginning of the List */</span>
<span class="n">rp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="cm">/* Begin protection against modification of the List */</span>
<span class="n">key</span> <span class="o">=</span> <span class="n">Gate_enterSystem</span><span class="p">();</span>

<span class="k">while</span> <span class="p">((</span><span class="n">elem</span> <span class="o">=</span> <span class="n">List_next</span><span class="p">(</span><span class="n">myList</span><span class="p">,</span> <span class="n">elem</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">System_printf</span><span class="p">(</span><span class="s">&quot;rec: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/* End protection against modification of the List */</span>
<span class="n">Gate_leaveSystem</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="inserting-and-removing-list-elements">
<h4>4.4.7.1.3. Inserting and Removing List Elements<a class="headerlink" href="#inserting-and-removing-list-elements" title="Permalink to this headline">¶</a></h4>
<p>Elements can also be inserted or removed from anywhere in the middle of a List using List_insert() and List_remove().
List_insert() inserts an element in front of the specified element.
Use List_putHead() to place an element at the front of the List and List_put() to
place an element at the end of the List.</p>
<p>List_remove() removes the specified element from whatever List it is in.</p>
<p>Note that List does not provide any APIs for inserting or removing elements at a given index in the List.</p>
<p><strong>Run-time example:</strong> The following example demonstrates List_insert() and List_remove():</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Insert r2 in front of r1 in the List. */</span>
<span class="n">List_insert</span><span class="p">(</span><span class="n">myList</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">r1</span><span class="p">.</span><span class="n">elem</span><span class="p">),</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">r2</span><span class="p">.</span><span class="n">elem</span><span class="p">));</span>

<span class="cm">/* Remove r1 from the List. */</span>
<span class="n">List_remove</span><span class="p">(</span><span class="n">myList</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">r1</span><span class="p">.</span><span class="n">elem</span><span class="p">));</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p><strong>Run-time example:</strong> The following example treats the List as a LIFO stack using List_putHead() and List_get():</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">List_Elem</span>  <span class="n">elem</span><span class="p">[</span><span class="n">NUMELEM</span><span class="p">];</span>
<span class="n">List_Elem</span> <span class="o">*</span><span class="n">tmpElem</span><span class="p">;</span>

<span class="c1">// push onto the top (i.e. head)</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUMELEM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">List_putHead</span><span class="p">(</span><span class="n">listHandle</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
<span class="p">}</span>

<span class="c1">// remove the buffers in FIFO order.</span>
<span class="k">while</span><span class="p">((</span><span class="n">tmpElem</span> <span class="o">=</span> <span class="n">List_get</span><span class="p">(</span><span class="n">listHandle</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// process tmpElem</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="atomic-list-operations">
<h4>4.4.7.1.4. Atomic List Operations<a class="headerlink" href="#atomic-list-operations" title="Permalink to this headline">¶</a></h4>
<p>Lists are commonly shared across multiple threads in the system, which might lead to concurrent
modifications of the List by different threads, which would corrupt the List.
List provides several “atomic” APIs that disable interrupts before operating on the List.
These APIs are List_get() List_put(), List_putHead(), and List_empty().</p>
<p>An atomic API completes in core functionality without being interrupted.
Therefore, atomic APIs are thread-safe. An example is List_put().
Multiple threads can call this API at the same time.
The threads do not have to manage the synchronization.</p>
<p>Other APIs–List_prev(), List_next(), List_insert(), and List_remove()–should be protected by the application.</p>
</div>
</div>
<div class="section" id="multiproc-module">
<h3>4.4.7.2. MultiProc Module<a class="headerlink" href="#multiproc-module" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" colspan="2"><p>API Reference Links</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html"><img alt="mpmCfg_Img1" src="../_images/Book_cfg.png" /></a></p></td>
<td><p><a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_multi_proc_8h.html"><img alt="mpmRun_Img1" src="../_images/Book_run.png" /></a></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<div class="section" id="id24">
<h4>4.4.7.2.1. Introduction<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h4>
<p>Many IPC modules require the ability to uniquely specify and identify processors in a
multi-processor environment. The MultiProc module centralizes processor ID management into one module.
Most multi-processor IPC applications require that you configure this module using the MultiProc.setConfig()
function in the <a href="#id25"><span class="problematic" id="id26">*</span></a>.cfg script. The setConfig() function tells the MultiProc module:</p>
<ul class="simple">
<li><p>The specific processor for which this application is being built.</p></li>
<li><p>The processors in this cluster. A “cluster” is a set of processors within</p></li>
</ul>
<p>a system that share some memory and for which notification between those processors is needed.</p>
<p>Most systems contain a single cluster. For systems with multiple clusters, you also need to configure the numProcessors and baseIdOfCluster properties.</p>
<p>Each processor reference by the MultiProc module can be uniquely identified by either its name string or an integer ranging from 0 to MultiProc.maxProcessors - 1.</p>
<p>The following XDCtools configuration statements set up a MultiProc array.
At runtime, the “DSP” processor running this configuration gets assigned an ID value of 2.
The other processors in the system are “VIDEO” with a processor ID of 0 and “DSS” with a
processor ID of 1.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>/* DSP will get assigned processor id 2. */
var MultiProc = xdc.useModule(&#39;ti.sdo.utils.MultiProc&#39;);
MultiProc.setConfig(&quot;DSP&quot;, [&quot;VIDEO&quot;, &quot;DSS&quot;, &quot;DSP&quot;]);
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>The ID is a software-only setting. It does not correlate to hardware core IDs or any other type of hardware identification. For devices with more than one core, each core must have its own unique processor ID. The ID is also independent of any OS setting.
The processor ID is not always known at configuration time. It might need to be determined at initialization time via a GPIO pin, flash setting, or some other method. You can call the MultiProc_setLocalId() API (with the restriction that it must be called before module startup) to set the processor ID. However, other modules that use MultiProc need to know that the static ID will be changed during initialization. Setting the local name to NULL in the MultiProc.setConfig statement in the configuration indicates that the MultiProc_setLocalId() API will be used at runtime. Other modules that use MultiProc should act accordingly by deferring processing until the actual ID is known.</p>
<p>For example, the following fragment of configuration code requires that the MultiProc_setLocalId() API be run during startup to fill in the NULL processor name.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>/* Specify startup function */
var Startup = xdc.useModule(&#39;xdc.runtime.Startup&#39;);
Startup.firstFxns.$add(&#39;&amp;setMyId&#39;);

/* Specify MultiProc config; current processor unknown */
var MultiProc = xdc.useModule(&#39;ti.sdo.utils.MultiProc&#39;);
MultiProc.setConfig(null, [&quot;CORE0&quot;, &quot;CORE1&quot;, &quot;CORE2&quot;]);
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Then, the application code could contain the following setMyID() function to be run at startup:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Void</span> <span class="nf">setMyId</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">UInt16</span> <span class="n">procId</span><span class="p">;</span>
    <span class="n">Int</span>    <span class="n">status</span><span class="p">;</span>

    <span class="c1">//</span>
    <span class="c1">// Board specific determination of processor id.</span>
    <span class="c1">// Example: GPIO_READ reads register of GPIO pin 5</span>
    <span class="c1">//</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">GPIO_READ</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">procId</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
       <span class="n">procId</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">MultiProc_setLocalId</span><span class="p">(</span><span class="n">procId</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Your application can query the MultiProc table using various runtime APIs.
At runtime, the MultiProc_getId() call returns the MultiProc ID for any processor name. At config-time, the MultiProc.getIdMeta() call returns the same value. For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">core1ProcId</span> <span class="o">=</span> <span class="n">MultiProc_getId</span><span class="p">(</span><span class="s">&quot;CORE1&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>MultiProc_self() returns the processor ID of the processor running the API. For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">System_printf</span><span class="p">(</span><span class="s">&quot;My MultiProc id = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MultiProc_self</span><span class="p">());</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>MultiProc_getBaseIdOfCluster() returns the MultiProc ID of the base processor in the cluster to which this processor belongs.
The MultiProc_getName() API returns that processor name if given the MultiProc ID. For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">core0Name</span> <span class="o">=</span> <span class="n">MultiProc_getName</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>MultiProc_getNumProcessors() evaluates to the total number of processors.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">System_printf</span><span class="p">(</span><span class="s">&quot;Number of processors in the system = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
              <span class="n">MultiProc_getNumProcessors</span><span class="p">()</span> <span class="p">);</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>MultiProc_getBaseIdOfCluster() returns the MultiProc ID of the base processor in the cluster to which this processor belongs.
The MultiProc_getName() API returns that processor name if given the MultiProc ID. For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">core0Name</span> <span class="o">=</span> <span class="n">MultiProc_getName</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>MultiProc_getNumProcessors() evaluates to the total number of processors.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">System_printf</span><span class="p">(</span><span class="s">&quot;Number of processors in the system = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
              <span class="n">MultiProc_getNumProcessors</span><span class="p">()</span> <span class="p">);</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>MultiProc_getNumProcsInCluster() returns the number of processors in the cluster to which this processor belongs.</p>
</div>
<div class="section" id="configuring-clusters-with-the-multiproc-module">
<h4>4.4.7.2.2. Configuring Clusters With the MultiProc Module<a class="headerlink" href="#configuring-clusters-with-the-multiproc-module" title="Permalink to this headline">¶</a></h4>
<p>A “cluster” is a set of processors within a system that share some memory and for which notification between those processors is needed. If your system has multiple clusters, you need to configure the MultiProc module’s numProcessors and baseIdOfCluster properties in addition to calling the MultiProc.setConfig() function.</p>
<p>Notifications are not supported between different clusters.</p>
<p>For example, in a system with two ‘C6678 devices that each use eight homogeneous cores, you could configure the first ‘C6678 device as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>var MultiProc = xdc.useModule(&#39;ti.sdo.utils.MultiProc&#39;);
MultiProc.baseIdOfCluster = 0;
MultiProc.numProcessors = 16;
MultiProc.setConfig(null, [&quot;CORE0&quot;, &quot;CORE1&quot;, &quot;CORE2&quot;,
         &quot;CORE3&quot;, &quot;CORE4&quot;, &quot;CORE5&quot;, &quot;CORE6&quot;, &quot;CORE7&quot;]);
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>You could configure the second ‘C6678 device as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>var MultiProc = xdc.useModule(&#39;ti.sdo.utils.MultiProc&#39;);
MultiProc.baseIdOfCluster = 8;
MultiProc.numProcessors = 16;
MultiProc.setConfig(null, [&quot;CORE0&quot;, &quot;CORE1&quot;, &quot;CORE2&quot;,
         &quot;CORE3&quot;, &quot;CORE4&quot;, &quot;CORE5&quot;, &quot;CORE6&quot;, &quot;CORE7&quot;]);
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Notice that the MultiProc.numProcessors property specifies the total number of processors in the system, while the length of the array passed to setConfig() specifies the number of processors in the cluster. (If you are not using multiple clusters, the numProcessors property is configured automatically.)
The MultiProc.baseIdOfCluster property is set to the MultiProc ID number you want to use for the first processor in the array for this cluster. For example, if there are 8 processors in a cluster, the baseIdOfCluster property should be 0 for the first cluster and 8 for the second cluster.</p>
<p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html"><img alt="mpmCfg_Img2" src="../_images/Book_cfg.png" /></a> The latest version of the MultiProc module configuration documentation
is available in <a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/index.html#ti/sdo/utils/MultiProc.html">MultiProc page</a></p>
</div>
<div class="section" id="creating-connections-with-multiproc">
<h4>4.4.7.2.3. Creating Connections with MultiProc<a class="headerlink" href="#creating-connections-with-multiproc" title="Permalink to this headline">¶</a></h4>
<p>The Ipc_start() and Ipc_attach() APIs can only be used to attach and synchronizes with processors in the same cluster.</p>
<p>To create a connection between cores in different clusters, you must manually create a connection using the MessageQ and ti.sdo.ipc.NameServerMessageQ modules. The NameServerMessageQ module supports NameServer requests between different clusters by using MessageQ, which in turns uses the MessageQ transport to send a NameServer request.</p>
<p>You can control the timeout period for the NameServerMessageQ module by configuring its timeoutInMicroSecs parameter, which defaults to 1 second. If a response is not received within the timeout period, the NameServer request returns a failure status. The NameServerRemoteNotify module also has a timeoutInMicroSecs parameter that you can configure; it defaults to wait forever.</p>
<p>Creating a connection between cores in different clusters allows you to call MessageQ_open() even for a core on a different cluster. Note that these calls must occur after the MessageQ heap has been registered, because they allocate memory from the heap.</p>
<p>Once the connection has been created, MessageQ can be used between different processors on different clusters just as it is used between different processors in the same cluster.</p>
<p><a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_multi_proc_8h.html"><img alt="mpmRun_Img2" src="../_images/Book_run.png" /></a> The latest version of the MultiProc module run-time API documentation is
available in <a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_multi_proc_8h.html">MultiProc run-time API</a></p>
</div>
<div class="section" id="example">
<h4>4.4.7.2.4. Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h4>
<p>The following example function creates a NameServerMessageQ and TransportXXX to communicate remotely with a processor in a different cluster. The “remoteProcId” would be specified to be the MultiProc ID of the processor in the system. “TransportXXX” must be a copy-based transport that does not require any shared memory. You would need to create such a transport, because IPC does not provide one.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Void</span> <span class="nf">myRemoteCreateFunction</span><span class="p">(</span><span class="n">Uint16</span> <span class="n">remoteProcId</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">NameServerMessageQ_Params</span>  <span class="n">nsParams</span><span class="p">;</span>
    <span class="n">NameServerMessageQ_Handle</span>  <span class="n">nsHandle</span><span class="p">;</span>
    <span class="n">TransportXXX_Handle</span>        <span class="n">tranHandle</span><span class="p">;</span>
    <span class="n">TransportXXX_Params</span>        <span class="n">tranParams</span><span class="p">;</span>
    <span class="n">Error_Block</span> <span class="n">eb</span><span class="p">;</span>

    <span class="n">Error_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eb</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     *  Note: You must register a MessageQ heap prior to</span>
<span class="cm">     *  calling NameServerMessageQ_create().</span>
<span class="cm">     */</span>

    <span class="cm">/* init nsParams */</span>
    <span class="n">NameServerMessageQ_Params_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nsParams</span><span class="p">);</span>

    <span class="cm">/* create driver to remote processor */</span>
    <span class="n">nsHandle</span> <span class="o">=</span> <span class="n">NameServerMessageQ_create</span><span class="p">(</span>
        <span class="n">remoteProcId</span><span class="p">,</span> <span class="cm">/* MultiProc ID of proc on 2nd cluster */</span>
        <span class="o">&amp;</span><span class="n">nsParams</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">eb</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">nsHandle</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">SYS_abort</span><span class="p">(</span><span class="s">&quot;NameServerMessageQ_create() failed&quot;</span><span class="p">);</span>
    <span class="p">}</span>

      <span class="cm">/* initialize the transport parameters */</span>
    <span class="n">TransportXXX_Params_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tranParams</span><span class="p">);</span>

    <span class="n">tranHandle</span> <span class="o">=</span> <span class="n">TransportXXX_create</span><span class="p">(</span>
       <span class="n">remoteProcId</span><span class="p">,</span> <span class="cm">/* MultiProc ID of proc on 2nd cluster */</span>
       <span class="o">&amp;</span><span class="n">tranParams</span><span class="p">,</span>
       <span class="o">&amp;</span><span class="n">eb</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tranHandle</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">SYS_abort</span><span class="p">(</span><span class="s">&quot;TransportXXX_create() failed&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="nameserver-module">
<h3>4.4.7.3. NameServer Module<a class="headerlink" href="#nameserver-module" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" colspan="2"><p>API Reference Links</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/index.html#ti/sdo/utils/NameServer.html"><img alt="nsmCfg_Img1" src="../_images/Book_cfg.png" /></a></p></td>
<td><p><a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_name_server_8h.html"><img alt="nsmRun_Img1" src="../_images/Book_run.png" /></a></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The NameServer module manages local name/value pairs. This enables an application and other modules to store and retrieve values based on a name.
The NameServer module maintains thread-safety for its APIs. However, NameServer APIs cannot be called from an interrupt (that is, Hwi context). They can be called from Swis (BIOS-only) and Tasks.</p>
<p>This module supports different lengths of values. The NameServer_add() and NameServer_get() functions support variable-length values. The NameServer_addUInt32() function is optimized for UInt32 variables and constants.</p>
<p>The NameServer module currently does not perform any endian or word size conversion. Also there is no asynchronous support at this time.</p>
<p>You can create NameServer instances dynamically. On BIOS, you can also create NameServer instances statically.</p>
<div class="section" id="creating-nameserver-instances-statically-bios-only">
<h4>4.4.7.3.1. Creating NameServer Instances Statically (BIOS-only)<a class="headerlink" href="#creating-nameserver-instances-statically-bios-only" title="Permalink to this headline">¶</a></h4>
<p>To create a NameServer instance statically, you can add statements similar to the following to your XDCtools configuration script:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>var NameServer = xdc.useModule(&#39;ti.sdo.utils.NameServer&#39;);

var nameServerParams = new NameServer.Params;
nameServerParams.maxRuntimeEntries = 10;
nameServerParams.maxNameLen = 32;
var nameServer0 = NameServer.create(&quot;nameServer0&quot;, nameServerParams);
</pre></div>
</div>
<p>If you want to specify the heap to be used by the NameServer module and a NameServer instance, use configuration statements similar to the following:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>var NameServer = xdc.useModule(&#39;ti.sdo.utils.NameServer&#39;);
var HeapMem = xdc.useModule(&#39;ti.sysbios.heaps.HeapMem&#39;);

var heapParams = new HeapMem.Params;
heapParams.size = 1024;
var heapMem = HeapMem.create(heapParams);

var nameServerParams = new NameServer.Params;
nameServerParams.tableHeap = heapMem;
var nameServer = NameServer.create(&quot;staticNameServer&quot;, nameServerParams);
</pre></div>
</div>
<p>To create a NameServer instance dynamically, initialize a NameServer_Params structure with
NameServer_Params_init() and customize the values as needed.
The parameters include the following:</p>
<ul class="simple">
<li><p><strong>checkExisting.</strong> If true, NameServer check to see if a name already exists in the name/value table before adding it.</p></li>
<li><p><strong>maxNameLen.</strong> Specify the maximum length, in characters, of the name field in the table.</p></li>
<li><p><strong>maxRuntimeEntries.</strong> Specify the maximum number of name/value pairs this table can hold. If you set this parameter to NameServer_ALLOWGROWTH, then NameServer allows dynamic growth of the table.</p></li>
<li><p><strong>maxValueLen.</strong> Specify the maximum length, in MAUs, of the value field in the table.</p></li>
<li><p><strong>tableHeap.</strong> The heap to allocate the name/value table from when allocating dynamically. If this parameter is NULL, the heap used for object allocation is also used here.</p></li>
</ul>
<p>After setting parameters, use NameServer_create() to create an instance.
Each NameServer instance manages its own name/value table.</p>
<p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html"><img alt="nsmCfg_Img2" src="../_images/Book_cfg.png" /></a> The latest version of the NameServer module
configuration documentation is available <a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/indexChrome.html">online</a>.</p>
</div>
<div class="section" id="creating-and-removing-nameserver-instances-dynamically">
<h4>4.4.7.3.2. Creating and Removing NameServer Instances Dynamically<a class="headerlink" href="#creating-and-removing-nameserver-instances-dynamically" title="Permalink to this headline">¶</a></h4>
<p>The following C example creates a NameServer instance dynamically.
The instance allows a maximum of 10 runtime entries (instead of using ALLOWGROWTH).
This example also specifies where to allocate the memory needed for the tables (instead of using the default).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NameServer_Handle</span> <span class="n">NSHandle</span><span class="p">;</span>
<span class="n">NameServer_Params</span> <span class="n">params</span><span class="p">;</span>

<span class="n">NameServer_Params_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="p">);</span>
<span class="n">params</span><span class="p">.</span><span class="n">tableHeap</span> <span class="o">=</span> <span class="n">HeapStd_Handle_upCast</span><span class="p">(</span><span class="n">myHeap</span><span class="p">);</span>
<span class="n">params</span><span class="p">.</span><span class="n">maxRuntimeEntries</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">NSHandle</span> <span class="o">=</span> <span class="n">NameServer_create</span><span class="p">(</span><span class="s">&quot;myTable&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">NSHandle</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// manage error</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This example C code adds and removes entries at run-time:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span> <span class="n">key</span><span class="p">;</span>

<span class="n">key</span> <span class="o">=</span> <span class="n">NameServer_addUInt32</span><span class="p">(</span><span class="n">NSHandle</span><span class="p">,</span> <span class="s">&quot;volume&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// manage error</span>
<span class="p">}</span>

<span class="n">NameServer_removeEntry</span><span class="p">(</span><span class="n">NSHandle</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
<span class="c1">// or</span>
<span class="n">NameServer_remove</span><span class="p">(</span><span class="n">NSHandle</span><span class="p">,</span> <span class="s">&quot;volume&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p><a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_name_server_8h.html"><img alt="nsmRun_Img2" src="../_images/Book_run.png" /></a> The latest version of the NameServer module run-time API
documentation is available <a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_name_server_8h.html">online</a>.</p>
</div>
<div class="section" id="searching-nameserver-instances">
<h4>4.4.7.3.3. Searching NameServer Instances<a class="headerlink" href="#searching-nameserver-instances" title="Permalink to this headline">¶</a></h4>
<p>The following example searches the NameServer instance pointed to by “handle” on
the specified processor for a name-value pair with the name stored in nameToFind.
It returns the value of the pair to valueBuf.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Search NameServer */</span>
<span class="n">status</span> <span class="o">=</span> <span class="n">NameServer_get</span><span class="p">(</span><span class="n">NSHandle</span><span class="p">,</span> <span class="n">nameToFind</span><span class="p">,</span> <span class="n">valueBuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">UInt32</span><span class="p">),</span> <span class="n">procId</span><span class="p">);</span>
</pre></div>
</div>
<p>Using different parameters for different table instances allows you to meet
requirements like the following:</p>
<ul class="simple">
<li><p><strong>Size differences.</strong> The maxValueLen parameter specifies the maximum length, in MAUs, of the value field in the table. One table could allow long values (for example, &gt; 32 bits), while another table could be used to store integers. This customization enables better memory usage.</p></li>
<li><p><strong>Performance.</strong> Multiple NameServer tables can improve the search time when retrieving a name/value pair.</p></li>
<li><p><strong>Relax name uniqueness.</strong> Names in a specific table must be unique, but the same name can be used in different tables.</p></li>
</ul>
<p>When you call NameServer_delete(), the memory for the name/values pairs is freed.
You do not need to call NameServer_remove() on the entries before deleting a NameServer instance.</p>
</div>
<div class="section" id="other-nameserver-apis">
<h4>4.4.7.3.4. Other NameServer APIs<a class="headerlink" href="#other-nameserver-apis" title="Permalink to this headline">¶</a></h4>
<p>In addition to the functions mentioned above, the NameServer module provides the following APIs:</p>
<ul class="simple">
<li><p><strong>NameServer_get()</strong> Retrieves the value portion of a local name/value pair from the specified processor.</p></li>
<li><p><strong>NameServer_getLocal()</strong> Retrieves the value portion of a local name/value pair.</p></li>
<li><p><strong>NameServer_remove()</strong> Removes a name/value pair from the table given a name.</p></li>
<li><p><strong>NameServer_removeEntry()</strong> Removes an entry from the table given a pointer to an entry.</p></li>
</ul>
<p>NameServer maintains the name/values table in local memory, not in shared memory.
However the NameServer module can be used in a multiprocessor system.
The module communicates with other processors via NameServer Remote drivers,
which are implementations of the INameServerRemote interface.
The communication to the other processors is dependent on the Remote drivers implementation.
When a remote driver is created, it registers with NameServer via the NameServer_registerRemoteDriver() API.</p>
<p>The NameServer module uses the MultiProc module to identify different processors.
Which remote processors to query and the order in which they are queried is
determined by the procId array passed to the NameServer_get() function.</p>
</div>
</div>
</div>
<div class="section" id="use-cases-for-ipc">
<h2>4.4.8. Use Cases for IPC<a class="headerlink" href="#use-cases-for-ipc" title="Permalink to this headline">¶</a></h2>
<p>You can use IPC modules in a variety of combinations. From the simplest
setup to the setup with the most functionality, the use case options are
as follows. A number of variations of these cases are also possible:</p>
<ul class="simple">
<li><p><strong>Minimal use of IPC. (BIOS-to-BIOS only)</strong> This scenario performs
inter-processor notification. The amount of data passed with a
notification is minimal–typically on the order of 32 bits. This
scenario is best used for simple synchronization between processors
without the overhead and complexity of message-passing
infrastructure.</p></li>
<li><p><strong>Add data passing. (BIOS-to-BIOS only)</strong> This scenario adds the
ability to pass linked list elements between processors to the
previous minimal scenario. The linked list implementation may
optionally use shared memory and/or gates to manage synchronization.</p></li>
<li><p><strong>Add dynamic allocation. (BIOS-to-BIOS only)</strong> This scenario adds
the ability to dynamically allocate linked list elements from a heap.</p></li>
<li><p><strong>Powerful but easy-to-use messaging. (HLOS and BIOS)</strong> This scenario
uses the MessageQ module for messaging. The application configures
other modules. However, the APIs for other modules are then used
internally by MessageQ, rather than directly by the application.</p></li>
</ul>
<p>In the following sections, figures show modules used by each scenario.</p>
<ul class="simple">
<li><p><span class="raw-html"><font color="blue">Blue boxes,</font></span> identify modules for which your application will call C API functions other than those used to dynamically create objects.</p></li>
<li><p><span class="raw-html"><font color="red">Red boxes,</font></span> identify modules that require only configuration by your application. Static configuration is performed in an XDCtools configuration script (.cfg). Dynamic configuration is performed in C code.</p></li>
<li><p><span class="raw-html"><font color="grey">Grey boxes,</font></span> identify modules that are used internally but do not need to be configured or have their APIs called.</p></li>
</ul>
<div class="section" id="minimal-use-scenario-bios-to-bios-only">
<h3>4.4.8.1. Minimal Use Scenario (BIOS-to-BIOS only)<a class="headerlink" href="#minimal-use-scenario-bios-to-bios-only" title="Permalink to this headline">¶</a></h3>
<p>This scenario performs inter-processor notification using a Notify
driver, which is used by the Notify module. This scenario is best used
for simple synchronization in which you want to send a message to
another processor to tell it to perform some action and optionally have
it notify the first processor when it is finished.</p>
<img alt="../_images/IpcUG_over_1_2_1.png" src="../_images/IpcUG_over_1_2_1.png" />
<p>In this scenario, you make API calls to the Notify module. For example,
the Notify_sendEvent() function sends an event to the specified
processor. You can dynamically register callback functions with the
Notify module to handle such events.</p>
<p>You must statically configure MultiProc module properties, which are
used by the Notify module.</p>
<p>The amount of data passed with a notification is minimal. You can send
an event number, which is typically used by the callback function to
determine what action it needs to perform. Optionally, a small
“payload”? of data can also be sent.</p>
<p>See <a class="reference external" href="index_Foundational_Components.html#notify-module">Notify Module</a> and
<a class="reference external" href="index_Foundational_Components.html#multiproc-module">MultiProc Module</a>.</p>
</div>
<div class="section" id="data-passing-scenario-bios-to-bios-only">
<h3>4.4.8.2. Data Passing Scenario (BIOS-to-BIOS only)<a class="headerlink" href="#data-passing-scenario-bios-to-bios-only" title="Permalink to this headline">¶</a></h3>
<p>In addition to the IPC modules used in the previous scenario, you can
use the ListMP module to share a linked list between processors.</p>
<img alt="../_images/IpcUG_over_1_2_2.png" src="../_images/IpcUG_over_1_2_2.png" />
<p>In this scenario, you make API calls to the Notify and ListMP modules.</p>
<p>The ListMP module is a doubly-linked-list designed to be shared by
multiple processors. ListMP differs from a conventional “local”? linked
list in the following ways:</p>
<ul class="simple">
<li><p>Address translation is performed internally upon pointers contained
within the data structure.</p></li>
<li><p>Cache coherency is maintained when the cacheable shared memory is
used.</p></li>
<li><p>A multi-processor gate (GateMP) is used to protect read/write
accesses to the list by two or more processors.</p></li>
</ul>
<p>ListMP uses SharedRegion’s lookup table to manage access to shared
memory, so configuration of the SharedRegion module is required.</p>
<p>Internally, ListMP can optionally use the NameServer module to manage
name/value pairs. The ListMP module also uses a GateMP object, which
your application must configure. The GateMP is used internally to
synchronize access to the list elements.</p>
<p>See <a class="reference external" href="index_Foundational_Components.html#listmp-module">ListMP Module</a>,
<a class="reference external" href="index_Foundational_Components.html#gatemp-module">GateMP Module</a>,
<a class="reference external" href="index_Foundational_Components.html#shared-region-module">SharedRegion
Module</a>, and
<a class="reference external" href="index_Foundational_Components.html#nameserver-module">NameServer Module</a>.</p>
</div>
<div class="section" id="dynamic-allocation-scenario-bios-to-bios-only">
<h3>4.4.8.3. Dynamic Allocation Scenario (BIOS-to-BIOS only)<a class="headerlink" href="#dynamic-allocation-scenario-bios-to-bios-only" title="Permalink to this headline">¶</a></h3>
<p>To the previous scenario, you can add dynamic allocation of ListMP
elements using one of the Heap*MP modules.</p>
<img alt="../_images/IpcUG_over_1_2_3.png" src="../_images/IpcUG_over_1_2_3.png" />
<p>In this scenario, you make API calls to the Notify and ListMP modules
and a Heap*MP module.</p>
<p>In addition to the modules that you configured for the previous
scenario, the Heap*MP modules use a GateMP that you must configure. You
may use the same GateMP instance used by ListMP.</p>
<p>See <a class="reference external" href="index_Foundational_Components.html#heapmp-module">Heap*MP Modules</a> and
<a class="reference external" href="index_Foundational_Components.html#gatemp-module">GateMP Module</a>.</p>
</div>
<div class="section" id="powerful-but-easy-to-use-messaging-with-messageq-hlos-and-bios">
<h3>4.4.8.4. Powerful But Easy-to-Use Messaging with MessageQ (HLOS and BIOS)<a class="headerlink" href="#powerful-but-easy-to-use-messaging-with-messageq-hlos-and-bios" title="Permalink to this headline">¶</a></h3>
<p>Finally, to use the most sophisticated inter-processor communication
scenario supported by IPC, you can add the MessageQ module. Note that
the following diagram shows one particular transport (TransportShm) and
may not apply to all devices and/or environments.</p>
<img alt="../_images/IpcUG_over_1_2_4.png" src="../_images/IpcUG_over_1_2_4.png" />
<p>In this scenario, you make API calls to the MessageQ module for
inter-processor communication.</p>
<p>API calls made to the Notify, ListMP, and Heap*MP modules in the
previous scenarios are not needed. Instead, your application only needs
to configure the MultiProc and (if the underlying MessageQ transport
requires it) the SharedRegion modules.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Some MessageQ transports do not use SharedRegion, but instead copy the
message payloads. This may be done because of hardware limitations (e.g.
no shared memory is available) or software design (e.g. transports built
on Linux kernel-friendly rpmsg drivers).</p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Ipc_start()</span></code> API call configures all the necessary underlying
modules (e.g. Notify, HeapMemMP, ListMP, TransportShm, NameServer, and
GateMP). The actual details of what modules <code class="docutils literal notranslate"><span class="pre">Ipc_start()</span></code> initializes
varies from environment to environment.</p>
<p>It is possible to use MessageQ in a single-processor SYS/BIOS
application. In such a case, only API calls to MessageQ and
configuration of any xdc.runtime.IHeap implementation are needed.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="ipc-examples">
<h2>4.4.9. IPC Examples<a class="headerlink" href="#ipc-examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="overview">
<h3>4.4.9.1. Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h3>
<p>The IPC product contains an examples/archive directory with device-specific examples.
Once identifying your device, the examples can be unzipped anywhere on your build host.
Typically once unzipped, the user edits the example’s individual <strong>products.mak</strong> file and simply invokes <strong>make</strong>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A common place to unzip the examples is into the <strong>IPC_INSTALL_DIR/examples/</strong> directory.
Each example’s <strong>products.mak</strong> file is smart enough to look up two directories (in this case, into <strong>IPC_INSTALL_DIR</strong>)
for a master <strong>products.mak</strong> file, and if found it uses those variables.
This technique enables users to set the dependency variables in one place, namely <strong>IPC_INSTALL_DIR/products.mak</strong>.</p>
</div>
<p>Each example contains a <strong>readme.txt</strong> with example-specific details.</p>
</div>
<div class="section" id="generating-examples">
<h3>4.4.9.2. Generating Examples<a class="headerlink" href="#generating-examples" title="Permalink to this headline">¶</a></h3>
<p>The IPC product will come with the generated examples directory.
The IPC product is what is typically delivered with SDKs such as Processor SDK.
However, some SDKs point directly to the IPC git tree for the IPC source.
In this case, the IPC Examples can be generated separately.</p>
</div>
<div class="section" id="tools">
<h3>4.4.9.3. Tools<a class="headerlink" href="#tools" title="Permalink to this headline">¶</a></h3>
<dl class="simple">
<dt>The following tools need to be installed:</dt><dd><ul class="simple">
<li><p><a href="#id29"><span class="problematic" id="id30">`</span></a>XDC tools &lt;<a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/rtsc/">http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/rtsc/</a>&gt;`__(check the IPC release notes for compatible version)</p></li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="source-code">
<h3>4.4.9.4. Source Code<a class="headerlink" href="#source-code" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">mkdir</span> <span class="n">ipc</span>
<span class="n">cd</span> <span class="n">ipc</span>
<span class="n">git</span> <span class="n">clone</span> <span class="nl">git</span><span class="p">:</span><span class="c1">//git.ti.com/ipc/ipc-metadata.git</span>
<span class="n">git</span> <span class="n">clone</span> <span class="nl">git</span><span class="p">:</span><span class="c1">//git.ti.com/ipc/ipc-examples.git</span>
</pre></div>
</div>
<p>Then checkout the IPC release tag that is associated with the IPC version being used. Do this for both repos. For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">checkout</span> <span class="mf">3.42.01.03</span>
</pre></div>
</div>
</div>
<div class="section" id="id31">
<h3>4.4.9.5. Build<a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="n">ipc</span><span class="o">-</span><span class="n">examples</span><span class="o">/</span><span class="n">src</span>
<span class="n">make</span> <span class="p">.</span><span class="n">examples</span> <span class="n">XDC_INSTALL_DIR</span><span class="o">=&lt;</span><span class="n">path_to_xdc_tools</span><span class="o">&gt;</span> <span class="n">IPCTOOLS</span><span class="o">=&lt;</span><span class="n">path_to_ipc</span><span class="o">-</span><span class="n">metadata</span><span class="o">&gt;/</span><span class="n">src</span><span class="o">/</span><span class="n">etc</span>
</pre></div>
</div>
<p>For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="p">.</span><span class="n">examples</span> <span class="n">XDC_INSTALL_DIR</span><span class="o">=/</span><span class="n">opt</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">xdctools_3_32_00_06_core</span> <span class="n">IPCTOOLS</span><span class="o">=/</span><span class="n">home</span><span class="o">/</span><span class="n">user</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc</span><span class="o">-</span><span class="n">metadata</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">etc</span>
</pre></div>
</div>
<p>The “examples” director will be generated in the path “ipc-examples/src/”:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ipc</span><span class="o">-</span><span class="n">examples</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">examples</span>
</pre></div>
</div>
</div>
<div class="section" id="ipc-examples-details">
<h3>4.4.9.6. IPC examples: Details<a class="headerlink" href="#ipc-examples-details" title="Permalink to this headline">¶</a></h3>
<p>This section explains some of the common details about IPC examples.
The sub-directories under the examples are organised into the code for each of the cores in the SOC.
For example
<a href="#id32"><span class="problematic" id="id33">|</span></a>-Host
<a href="#id34"><span class="problematic" id="id35">|</span></a>-DSP1
<a href="#id36"><span class="problematic" id="id37">|</span></a>-DSP2
<a href="#id38"><span class="problematic" id="id39">|</span></a>-IPU1
<a href="#id40"><span class="problematic" id="id41">|</span></a>-IPU2</p>
<p>Typically we have a host core which is the main core in the SOC and other slave cores.
The directory name of the slave cores have a base name (like DSP, IPU etc) which indicates the type of core and a core number.
Depending on the example, the Host can run TI BIOS or Linux or QNX and the slave cores in general run TI BIOS only.
So the specific build related files need to be interpreted accordingly.</p>
<div class="section" id="bios-application-configuration-files">
<h4>4.4.9.6.1. BIOS Application configuration files<a class="headerlink" href="#bios-application-configuration-files" title="Permalink to this headline">¶</a></h4>
<p>The cores running BIOS in general has a config file which brings in all the modules needed to complete the application running on the specific core.
This section explains the details of the entries in the config file.
Note: The details here are just representative of a typical configuration. In general the configuration is customized based on the particular example.</p>
<div class="section" id="bios-configuration">
<h5>4.4.9.6.1.1. Bios configuration<a class="headerlink" href="#bios-configuration" title="Permalink to this headline">¶</a></h5>
<p>The following configuration are related to configuring BIOS</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>var BIOS        = xdc.useModule(&#39;ti.sysbios.BIOS&#39;);
/*  This adds ipc Startup to be done part of BIOS  startup before main*/
BIOS.addUserStartupFunction(&#39;&amp;IpcMgr_ipcStartup&#39;);

/* The following configures Debug libtype with Debug build */
if (Program.build.profile == &quot;debug&quot;) {
     BIOS.libType = BIOS.LibType_Debug;
} else {
    BIOS.libType = BIOS.LibType_Custom;
}

var Sem = xdc.useModule(&#39;ti.sysbios.knl.Semaphore&#39;);
var instSem0_Params = new Sem.Params();
instSem0_Params.mode = Sem.Mode_BINARY;
Program.global.runOmpSem = Sem.create(0, instSem0_Params);
Program.global.runOmpSem_complete = Sem.create(0, instSem0_Params);

var Task = xdc.useModule(&#39;ti.sysbios.knl.Task&#39;);
Task.common$.namedInstance = true;

/* default memory heap */
var Memory = xdc.useModule(&#39;xdc.runtime.Memory&#39;);
var HeapMem = xdc.useModule(&#39;ti.sysbios.heaps.HeapMem&#39;);
var heapMemParams = new HeapMem.Params();
heapMemParams.size = 0x8000;
Memory.defaultHeapInstance = HeapMem.create(heapMemParams);

/* create a heap for MessageQ messages */
var HeapBuf = xdc.useModule(&#39;ti.sysbios.heaps.HeapBuf&#39;);
var params = new HeapBuf.Params;
params.align = 8;
params.blockSize = 512;
params.numBlocks = 20;
</pre></div>
</div>
</div>
<div class="section" id="xdc-runtime">
<h5>4.4.9.6.1.2. XDC runtime<a class="headerlink" href="#xdc-runtime" title="Permalink to this headline">¶</a></h5>
<p>The following configuration are in general used by an IPC application in BIOS</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>/* application uses the following modules and packages */
xdc.useModule(&#39;xdc.runtime.Assert&#39;);
xdc.useModule(&#39;xdc.runtime.Diags&#39;);
xdc.useModule(&#39;xdc.runtime.Error&#39;);
xdc.useModule(&#39;xdc.runtime.Log&#39;);
xdc.useModule(&#39;xdc.runtime.Registry&#39;);

xdc.useModule(&#39;ti.sysbios.knl.Semaphore&#39;);
xdc.useModule(&#39;ti.sysbios.knl.Task&#39;);
</pre></div>
</div>
</div>
<div class="section" id="ipc-configuration">
<h5>4.4.9.6.1.3. IPC configuration<a class="headerlink" href="#ipc-configuration" title="Permalink to this headline">¶</a></h5>
<p>The following IPC modules are used in a typical IPC application.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>xdc.useModule(&#39;ti.sdo.ipc.Ipc&#39;);
xdc.useModule(&#39;ti.ipc.ipcmgr.IpcMgr&#39;);
var MultiProc = xdc.useModule(&#39;ti.sdo.utils.MultiProc&#39;);
/* The following configures the PROC List */
MultiProc.setConfig(&quot;CORE0&quot;, [&quot;HOST&quot;, &quot;CORE0&quot;]);

var msgHeap = HeapBuf.create(params);

var MessageQ  = xdc.useModule(&#39;ti.sdo.ipc.MessageQ&#39;);
/* Register msgHeap with messageQ */
MessageQ.registerHeapMeta(msgHeap, 0);
</pre></div>
</div>
<p>The following lines configure placement of Resource table in memory.
Note that some platforms or applications the placement of memory can be in a different section in the memory map.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>/* Enable Memory Translation module that operates on the Resource Table */
var Resource = xdc.useModule(&#39;ti.ipc.remoteproc.Resource&#39;);
Resource.loadSegment = Program.platform.dataMemory;
</pre></div>
</div>
</div>
<div class="section" id="transport-configuration">
<h5>4.4.9.6.1.4. Transport configuration<a class="headerlink" href="#transport-configuration" title="Permalink to this headline">¶</a></h5>
<p>Typically the transport to be used by IPC is specified here. The following snippet configures RPMsg based transport.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>/* Setup MessageQ transport */
var VirtioSetup = xdc.useModule(&#39;ti.ipc.transports.TransportRpmsgSetup&#39;);
MessageQ.SetupTransportProxy = VirtioSetup;
</pre></div>
</div>
</div>
<div class="section" id="nameserver-configuration">
<h5>4.4.9.6.1.5. NameServer configuration<a class="headerlink" href="#nameserver-configuration" title="Permalink to this headline">¶</a></h5>
<p>The Name server to be used is specified here.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Setup NameServer remote proxy */</span>
<span class="n">var</span> <span class="n">NameServer</span> <span class="o">=</span> <span class="n">xdc</span><span class="p">.</span><span class="n">useModule</span><span class="p">(</span><span class="s">&quot;ti.sdo.utils.NameServer&quot;</span><span class="p">);</span>
<span class="n">var</span> <span class="n">NsRemote</span> <span class="o">=</span> <span class="n">xdc</span><span class="p">.</span><span class="n">useModule</span><span class="p">(</span><span class="s">&quot;ti.ipc.namesrv.NameServerRemoteRpmsg&quot;</span><span class="p">);</span>
<span class="n">NameServer</span><span class="p">.</span><span class="n">SetupProxy</span> <span class="o">=</span> <span class="n">NsRemote</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="instrumentation-configuration">
<h5>4.4.9.6.1.6. Instrumentation Configuration<a class="headerlink" href="#instrumentation-configuration" title="Permalink to this headline">¶</a></h5>
<p>The following configuration are required for system logging and diagnostics.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  /* system logger */
var LoggerSys = xdc.useModule(&#39;xdc.runtime.LoggerSys&#39;);
var LoggerSysParams = new LoggerSys.Params();
var Defaults = xdc.useModule(&#39;xdc.runtime.Defaults&#39;);
Defaults.common$.logger = LoggerSys.create(LoggerSysParams);

/* enable runtime Diags_setMask() for non-XDC spec&#39;d modules */
var Diags = xdc.useModule(&#39;xdc.runtime.Diags&#39;);
Diags.setMaskEnabled = true;

/* override diags mask for selected modules */
xdc.useModule(&#39;xdc.runtime.Main&#39;);
Diags.setMaskMeta(&quot;xdc.runtime.Main&quot;,
    Diags.ENTRY | Diags.EXIT | Diags.INFO, Diags.RUNTIME_ON);

var Registry = xdc.useModule(&#39;xdc.runtime.Registry&#39;);
Registry.common$.diags_ENTRY = Diags.RUNTIME_OFF;
Registry.common$.diags_EXIT  = Diags.RUNTIME_OFF;
Registry.common$.diags_INFO  = Diags.RUNTIME_OFF;
Registry.common$.diags_USER1 = Diags.RUNTIME_OFF;
Registry.common$.diags_LIFECYCLE = Diags.RUNTIME_OFF;
Registry.common$.diags_STATUS = Diags.RUNTIME_OFF;

var Main = xdc.useModule(&#39;xdc.runtime.Main&#39;);
Main.common$.diags_ASSERT = Diags.ALWAYS_ON;
Main.common$.diags_INTERNAL = Diags.ALWAYS_ON;
</pre></div>
</div>
</div>
<div class="section" id="other-optional-configurations">
<h5>4.4.9.6.1.7. Other optional configurations<a class="headerlink" href="#other-optional-configurations" title="Permalink to this headline">¶</a></h5>
<p>In addition to the above configurations there are other platform specific configurations may be used to enable certain features.</p>
<p>For example the following sections shows the sections used to enable device exception handler. ( But the deh module may not be available on all devices)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>var Idle = xdc.useModule(&#39;ti.sysbios.knl.Idle&#39;);
var Deh = xdc.useModule(&#39;ti.deh.Deh&#39;);

/* Must be placed before pwr mgmt */
Idle.addFunc(&#39;&amp;ti_deh_Deh_idleBegin&#39;);
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="ipc-tests">
<h2>4.4.10. IPC Tests<a class="headerlink" href="#ipc-tests" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id42">
<h3>4.4.10.1. Overview<a class="headerlink" href="#id42" title="Permalink to this headline">¶</a></h3>
<p>The IPC product contains unit tests under the following directories.</p>
<ul class="simple">
<li><p>linux/src/tests</p></li>
<li><p>qnx/src/tests</p></li>
<li><p>packages/ti/ipc/tests</p></li>
</ul>
<p>These are meant to be used as unit tests and documentation of the tests
are currently sparse.</p>
<div class="section" id="linux-unit-tests">
<h4>4.4.10.1.1. Linux Unit tests<a class="headerlink" href="#linux-unit-tests" title="Permalink to this headline">¶</a></h4>
<p>These tests under linux/src/tests have a Linux host application binary
and the binaries for the respective slave cores used in the test are
located under packages/ti/ipc/tests.</p>
<p><strong>NOTE</strong>: Loading of the slave cores in general is achieved by using
remoteproc or MPM control procedures, which are specific to the platform
and are out of scope for this page.</p>
<div class="section" id="single-thread-messageq-tests">
<h5>4.4.10.1.1.1. Single thread MessageQ tests<a class="headerlink" href="#single-thread-messageq-tests" title="Permalink to this headline">¶</a></h5>
<p>MessageQApp: Sends single messages to slave cores and gets messages sent
back from slave cores.</p>
<p>Msgq100: Specific unit test to test MessageQ_get when messages are
available from more than one remote core.</p>
<p>MessageQBench: Send and get back single messages and measures round trip
delay.</p>
<p>These unit test binaries can be built with the following commands ( See
<a class="reference external" href="index_Foundational_Components.html#linux-install-guide">IPC Linux Install Guide</a> for more
details on setting up variables)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="o">-</span><span class="n">f</span> <span class="n">ipc</span><span class="o">-</span><span class="n">linux</span><span class="p">.</span><span class="n">mak</span> <span class="n">config</span>
<span class="n">make</span>
<span class="n">make</span> <span class="n">install</span>
</pre></div>
</div>
<p>NOTE: The Host linux binaries are located at the DESTDIR/bin.</p>
<div class="line-block">
<div class="line"><br /></div>
<div class="line">All these tests use the messageq_single.* binaries loaded on the
slave cores.</div>
</div>
<p>For example:</p>
<p>For the ipu1 core on AM57x/DRA7xx use:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="o">/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">tests</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">ti_platforms_evmDRA7XX_ipu1</span><span class="o">/</span><span class="n">messageq_single</span><span class="p">.</span><span class="n">xem4</span>
</pre></div>
</div>
<p>For all the DSP cores on K2HK use:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="o">/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">tests</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">ti_platforms_evmTCI6638K2K_core0</span><span class="o">/</span><span class="n">messageq_single</span><span class="p">.</span><span class="n">xe66</span>
</pre></div>
</div>
<div class="section" id="running-single-message-tests">
<h6>4.4.10.1.1.1.1. Running single Message tests<a class="headerlink" href="#running-single-message-tests" title="Permalink to this headline">¶</a></h6>
<p>The following procedures assume that all the relevant slave cores are
already loaded and running.</p>
<p>MessageQApp</p>
<p>Syntax:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MessageQApp</span> <span class="o">&lt;</span><span class="n">number</span> <span class="n">of</span> <span class="n">Messages</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">Core</span> <span class="n">num</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>(e.g)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MessageQApp</span> <span class="mi">100</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Msgq</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Msgq100</span> <span class="p">[</span><span class="o">-</span><span class="n">l</span><span class="o">|</span><span class="n">h</span><span class="p">]</span> <span class="n">procId1</span> <span class="n">procId2</span> <span class="p">....</span>
</pre></div>
</div>
<p>(e.g)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Prints</span> <span class="n">list</span> <span class="n">of</span> <span class="n">available</span> <span class="n">remote</span> <span class="n">processors</span>
<span class="n">Msgq100</span> <span class="o">-</span><span class="n">l</span>
<span class="n">Run</span> <span class="n">test</span> <span class="n">with</span> <span class="n">remote</span> <span class="n">processor</span> <span class="n">with</span> <span class="n">id</span> <span class="mi">1</span>
<span class="n">Msgq100</span> <span class="mi">1</span>
<span class="n">Run</span> <span class="n">test</span> <span class="n">with</span> <span class="n">remote</span> <span class="n">processors</span> <span class="n">with</span> <span class="n">id</span> <span class="mi">1</span> <span class="n">and</span> <span class="mi">2</span>
<span class="n">Msgq100</span> <span class="mi">1</span> <span class="mi">2</span>
</pre></div>
</div>
<p>MessageQBench</p>
<p>Syntax:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MessageQBench</span> <span class="o">&lt;</span><span class="n">number</span> <span class="n">of</span> <span class="n">Messages</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">Core</span> <span class="n">num</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>(e.g)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MessageQBench</span> <span class="mi">100</span> <span class="mi">1</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="ping-rpmsg">
<h5>4.4.10.1.1.2. ping_rpmsg<a class="headerlink" href="#ping-rpmsg" title="Permalink to this headline">¶</a></h5>
<p>./linux/src/tests/usr/bin/ping_rpmsg: Sends ping messages and receives
back messages.</p>
<p>This test uses <strong>ping_rpmsg</strong>.* binaries loaded on the slave cores.</p>
<p>For example for the ipu1 core on AM57x/DRA7xx use:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="o">/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">tests</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">ti_platforms_evmDRA7XX_ipu1</span><span class="o">/</span><span class="n">ping_rpmsg</span><span class="p">.</span><span class="n">xem4</span>
</pre></div>
</div>
<div class="section" id="run-ping-rpmsg">
<h6>4.4.10.1.1.2.1. Run ping_rpmsg<a class="headerlink" href="#run-ping-rpmsg" title="Permalink to this headline">¶</a></h6>
<p>On the linux console run the following command</p>
<p>syntax:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ping_rpmsg</span> <span class="p">[</span><span class="n">num_iterations</span><span class="p">]</span>
</pre></div>
</div>
<p>(e.g)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ping_rpmsg</span>
<span class="n">ping_rpmsg</span> <span class="mi">100</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="nameserverapp">
<h5>4.4.10.1.1.3. NameServerApp<a class="headerlink" href="#nameserverapp" title="Permalink to this headline">¶</a></h5>
<p>./linux/src/tests/.libs/NameServerApp: NameServer test</p>
<p>This test uses NameServerApp.* binaries loaded on the slave cores.</p>
<p>For example for the ipu1 core on AM57x/DRA7xx use:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="o">/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">tests</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">ti_platforms_evmDRA7XX_ipu1</span><span class="o">/</span><span class="n">NameServerApp</span><span class="p">.</span><span class="n">xem4</span>
</pre></div>
</div>
<div class="section" id="run-nameserverapp">
<h6>4.4.10.1.1.3.1. Run NameServerApp<a class="headerlink" href="#run-nameserverapp" title="Permalink to this headline">¶</a></h6>
<p>With the slave processors loaded execute the following command.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NameServerApp</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="messageqmulti">
<h5>4.4.10.1.1.4. MessageQMulti<a class="headerlink" href="#messageqmulti" title="Permalink to this headline">¶</a></h5>
<p>./linux/src/tests/.libs/MessageQMulti: Sends and receives with multiple
threads</p>
<p>This test uses messageq_multi.* images loaded on the slave cores.</p>
<p>For example for the ipu1 core on AM57x/DRA7xx use:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="o">/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">tests</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">ti_platforms_evmDRA7XX_ipu1</span><span class="o">/</span><span class="n">messageq_multi</span><span class="p">.</span><span class="n">xem4</span>
</pre></div>
</div>
<div class="section" id="running-messageqmulti">
<h6>4.4.10.1.1.4.1. Running MessageQMulti<a class="headerlink" href="#running-messageqmulti" title="Permalink to this headline">¶</a></h6>
<p>With the slave cores loaded and running. Use the following command to
run the Linux application.</p>
<p>(e.g)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MessageQMulti</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="messageqmultimulti">
<h5>4.4.10.1.1.5. MessageQMultiMulti<a class="headerlink" href="#messageqmultimulti" title="Permalink to this headline">¶</a></h5>
<p>./linux/src/tests/.libs/MessageQMultiMulti: Sends and receives multiple
messages with multiple threads to multiple cores.</p>
<p>NOTE: This test needs all the slave cores in the SOC to be loaded and
running.</p>
<p>This uses <strong>messageq_multimulti.*</strong> images loaded on the slave cores.</p>
<p>For example for the ipu1 core on AM57x/DRA7xx use:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="o">/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">tests</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">ti_platforms_evmDRA7XX_ipu1</span><span class="o">/</span><span class="n">messageq_multimulti</span><span class="p">.</span><span class="n">xem4</span>
</pre></div>
</div>
<div class="section" id="running-messageqmultimulti">
<h6>4.4.10.1.1.5.1. Running MessageQMultiMulti<a class="headerlink" href="#running-messageqmultimulti" title="Permalink to this headline">¶</a></h6>
<p>With all the slave cores loaded and running. Use the following command
to run the Linux application.</p>
<p>(e.g)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MessageQMultiMulti</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="fault">
<h5>4.4.10.1.1.6. fault<a class="headerlink" href="#fault" title="Permalink to this headline">¶</a></h5>
<p>./linux/src/tests/.libs/fault: Test fault handling</p>
<p>NOTE: This test needs all the slave cores in the SOC to be loaded and
running.</p>
<p>This uses fault.* images loaded on the slave cores.</p>
<p>For example for the ipu1 core on AM57x/DRA7xx use:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="o">/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">tests</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">ti_platforms_evmDRA7XX_ipu1</span><span class="o">/</span><span class="n">fault</span><span class="p">.</span><span class="n">xem4</span>
</pre></div>
</div>
<div class="section" id="running-fault">
<h6>4.4.10.1.1.6.1. Running fault<a class="headerlink" href="#running-fault" title="Permalink to this headline">¶</a></h6>
<p>With all the slave cores loaded and running. Use the following command
to run the Linux application.</p>
<p>(e.g)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">fault</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
</div>
<div class="section" id="qnx-unit-tests">
<h4>4.4.10.1.2. Qnx Unit tests<a class="headerlink" href="#qnx-unit-tests" title="Permalink to this headline">¶</a></h4>
<p>These tests under qnx/src/tests have a Qnx host application binary and
the binaries for the respective slave cores used in the test are located
under packages/ti/ipc/tests.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Loading of the slave cores in general is achieved by using the
ipc binary.</p>
</div>
<div class="section" id="id43">
<h5>4.4.10.1.2.1. Single thread MessageQ tests<a class="headerlink" href="#id43" title="Permalink to this headline">¶</a></h5>
<p>MessageQApp: Sends single messages to slave cores and gets messages sent
back from slave cores.</p>
<p>MessageQBench: Send and get back single messages and measures round trip
delay.</p>
<p>These unit test binaries can be built with the following commands ( See
<a class="reference external" href="index_Foundational_Components.html#qnx-install-guide">IPC QNX Install Guide</a> for more
details on setting up variables)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="o">-</span><span class="n">f</span> <span class="n">ipc</span><span class="o">-</span><span class="n">qnx</span><span class="p">.</span><span class="n">mak</span> <span class="n">all</span>
<span class="n">make</span> <span class="o">-</span><span class="n">f</span> <span class="n">ipc</span><span class="o">-</span><span class="n">qnx</span><span class="p">.</span><span class="n">mak</span> <span class="n">install</span>
</pre></div>
</div>
<dl class="simple">
<dt>All these tests use the messageq_single.* binaries loaded on the</dt><dd><p>slave cores.</p>
</dd>
</dl>
<p>For example:</p>
<p>For the ipu1 core on DRA7xx use:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="o">/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">tests</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">ti_platforms_evmDRA7XX_ipu1</span><span class="o">/</span><span class="n">messageq_single</span><span class="p">.</span><span class="n">xem4</span>
</pre></div>
</div>
<p>Follow the instructions in the Install Guide for how to load images to
the remote cores.</p>
<div class="section" id="id44">
<h6>4.4.10.1.2.1.1. Running single Message tests<a class="headerlink" href="#id44" title="Permalink to this headline">¶</a></h6>
<p>The following procedures assume that all the relevant slave cores are
already loaded and running.</p>
<p>MessageQApp</p>
<p>Syntax:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MessageQApp</span> <span class="o">&lt;</span><span class="n">number</span> <span class="n">of</span> <span class="n">Messages</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">Core</span> <span class="n">num</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>(e.g)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MessageQApp</span> <span class="mi">100</span> <span class="mi">1</span>
</pre></div>
</div>
<p>MessageQBench</p>
<p>Syntax:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MessageQBench</span> <span class="o">&lt;</span><span class="n">number</span> <span class="n">of</span> <span class="n">Messages</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">Core</span> <span class="n">num</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>(e.g)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MessageQBench</span> <span class="mi">100</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id45">
<h5>4.4.10.1.2.2. NameServerApp<a class="headerlink" href="#id45" title="Permalink to this headline">¶</a></h5>
<p>./qnx/src/tests/NameServerApp: NameServer test</p>
<p>This test uses NameServerApp.* binaries loaded on the slave cores.</p>
<p>For example for the ipu1 core on DRA7xx use:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="o">/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">tests</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">ti_platforms_evmDRA7XX_ipu1</span><span class="o">/</span><span class="n">NameServerApp</span><span class="p">.</span><span class="n">xem4</span>
</pre></div>
</div>
<div class="section" id="id46">
<h6>4.4.10.1.2.2.1. Run NameServerApp<a class="headerlink" href="#id46" title="Permalink to this headline">¶</a></h6>
<p>With the slave processors loaded execute the following command.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NameServerApp</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="id47">
<h5>4.4.10.1.2.3. MessageQMulti<a class="headerlink" href="#id47" title="Permalink to this headline">¶</a></h5>
<p>./qnx/src/tests/MessageQMulti: Sends and receives with multiple threads</p>
<p>This test uses messageq_multi.* images loaded on the slave cores.</p>
<p>For example for the ipu1 core on DRA7xx use:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="o">/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">tests</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">ti_platforms_evmDRA7XX_ipu1</span><span class="o">/</span><span class="n">messageq_multi</span><span class="p">.</span><span class="n">xem4</span>
</pre></div>
</div>
<div class="section" id="id48">
<h6>4.4.10.1.2.3.1. Running MessageQMulti<a class="headerlink" href="#id48" title="Permalink to this headline">¶</a></h6>
<p>With the slave cores loaded and running. Use the following command to
run the Qnx application.</p>
<p>Syntax:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="nl">Usage</span><span class="p">:</span> <span class="n">MessageQMulti</span> <span class="o">&lt;</span><span class="n">number</span> <span class="n">of</span> <span class="n">threads</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">number</span> <span class="n">of</span> <span class="n">loops</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">number</span> <span class="n">of</span> <span class="n">processes</span><span class="o">&gt;</span>
<span class="nl">Defaults</span><span class="p">:</span> <span class="n">number</span> <span class="n">of</span> <span class="nl">threads</span><span class="p">:</span> <span class="mi">10</span>
          <span class="n">number</span> <span class="n">of</span> <span class="nl">loops</span><span class="p">:</span> <span class="mi">1000</span>
          <span class="n">number</span> <span class="n">of</span> <span class="nl">processes</span><span class="p">:</span> <span class="mi">1</span>
<span class="nl">Note</span><span class="p">:</span> <span class="n">If</span> <span class="n">number</span> <span class="n">of</span> <span class="n">processes</span> <span class="n">is</span> <span class="n">set</span><span class="p">,</span> <span class="n">number</span> <span class="n">of</span> <span class="n">threads</span> <span class="n">is</span> <span class="n">forced</span> <span class="n">to</span> <span class="mi">1</span>
</pre></div>
</div>
<p>(e.g)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MessageQMulti</span> <span class="mi">10</span> <span class="mi">10</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id49">
<h5>4.4.10.1.2.4. Fault<a class="headerlink" href="#id49" title="Permalink to this headline">¶</a></h5>
<p>./qnx/src/tests/Fault: Test fault handling</p>
<p>This uses fault.* images loaded on the slave cores.</p>
<p>For example for the ipu1 core on DRA7xx use:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="o">/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">tests</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">ti_platforms_evmDRA7XX_ipu1</span><span class="o">/</span><span class="n">fault</span><span class="p">.</span><span class="n">xem4</span>
</pre></div>
</div>
<div class="section" id="id50">
<h6>4.4.10.1.2.4.1. Running fault<a class="headerlink" href="#id50" title="Permalink to this headline">¶</a></h6>
<p>With all the slave cores loaded and running. Use the following command
to run the Qnx application.</p>
<p>Syntax:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Fault</span> <span class="o">&lt;-</span><span class="n">f</span> <span class="o">&lt;</span><span class="n">fault_num</span><span class="o">&gt;&gt;</span> <span class="o">&lt;</span><span class="n">number</span> <span class="n">of</span> <span class="n">loops</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">core</span> <span class="n">num</span><span class="o">&gt;</span>
<span class="n">Where</span> <span class="o">&lt;</span><span class="n">fault</span> <span class="n">num</span><span class="o">&gt;</span> <span class="nl">is</span><span class="p">:</span>
    <span class="mi">0</span><span class="o">:</span> <span class="n">No</span> <span class="n">fault</span>
    <span class="mi">1</span><span class="o">:</span> <span class="n">MMU</span> <span class="n">read</span> <span class="n">fault</span>
    <span class="mi">2</span><span class="o">:</span> <span class="n">MMU</span> <span class="n">write</span> <span class="n">fault</span>
    <span class="mi">3</span><span class="o">:</span> <span class="n">MMU</span> <span class="n">program</span> <span class="n">fault</span>
    <span class="mi">4</span><span class="o">:</span> <span class="n">Exception</span>
    <span class="mi">5</span><span class="o">:</span> <span class="n">Watchdog</span>
</pre></div>
</div>
<p>(e.g)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Fault</span> <span class="o">-</span><span class="n">f1</span> <span class="mi">10</span> <span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="gatempapp">
<h5>4.4.10.1.2.5. GateMPApp<a class="headerlink" href="#gatempapp" title="Permalink to this headline">¶</a></h5>
<p>./qnx/src/tests/GateMPApp: Test the GateMP Module</p>
<p>This uses the gatempapp.xe66 image loaded on the DSP1 slave core.</p>
<p>For example for the dsp1 core on DRA7xx use:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="o">/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">tests</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">ti_platforms_evmDRA7XX_dsp1</span><span class="o">/</span><span class="n">gatempapp</span><span class="p">.</span><span class="n">xe66</span>
</pre></div>
</div>
<div class="section" id="running-gatempapp">
<h6>4.4.10.1.2.5.1. Running GateMPApp<a class="headerlink" href="#running-gatempapp" title="Permalink to this headline">¶</a></h6>
<p>With the DSP1 slave core loaded and running. Use the following command
to run the Qnx application.</p>
<p>Syntax:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">GateMPApp</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="mmrpc-test">
<h5>4.4.10.1.2.6. mmrpc_test<a class="headerlink" href="#mmrpc-test" title="Permalink to this headline">¶</a></h5>
<p>./qnx/src/tests/mmrpc_test: Test the MmRpc API</p>
<p>This uses the test_omx_&lt;core&gt;_vayu.* images loaded on the slave cores.</p>
<p>For example for the dsp1 core on DRA7xx use:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="o">/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">tests</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">ti_platforms_evmDRA7XX_dsp1</span><span class="o">/</span><span class="n">test_omx_ipu1_vayu</span><span class="p">.</span><span class="n">xem4</span>
</pre></div>
</div>
</div>
<div class="section" id="running-mmrpc-test">
<h5>4.4.10.1.2.7. Running mmrpc_test<a class="headerlink" href="#running-mmrpc-test" title="Permalink to this headline">¶</a></h5>
<p>With the slave cores loaded and running. Use the following command to
run the Qnx application.</p>
<p>Syntax:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">mmrpc_test</span> <span class="o">&lt;</span><span class="n">Core</span> <span class="n">num</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>(e.g.)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">mmrpc_test</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="ipc-daemon">
<h2>4.4.11. IPC Daemon<a class="headerlink" href="#ipc-daemon" title="Permalink to this headline">¶</a></h2>
<div class="section" id="ipc-daemon-aka-lad">
<h3>4.4.11.1. IPC Daemon (aka LAD)<a class="headerlink" href="#ipc-daemon-aka-lad" title="Permalink to this headline">¶</a></h3>
<p>This topic is an overview of the daemon used by IPC on Linux. The IPC
daemon maintains any processor-wide state that’s not specific to any
process or thread on the HLOS. For example, it contains the
<a class="reference external" href="index_Foundational_Components.html#multiproc-module">MultiProc</a>
configuration (small database of what cores are in the system and their
unique IDs), the HLOS’s
<a class="reference external" href="index_Foundational_Components.html#nameserver-module">NameServer</a> database,
among other misc.</p>
<p>The IPC daemon was forked from the <a class="reference external" href="http://processors.wiki.ti.com/index.php/Link_Arbiter_Daemon">Link Arbiter
Daemon</a>, used in DSP Link systems -
and while the daemon still contains ‘lad’ in it’s name, LAD isn’t really
an applicable acronym for anything. (But creative suggestions are
welcome!)</p>
<div class="section" id="approach">
<h4>4.4.11.1.1. Approach<a class="headerlink" href="#approach" title="Permalink to this headline">¶</a></h4>
<p>The IPC Daemon is a separate process from other IPC-using applications.</p>
<p>The IPC Daemon must be started <strong>after</strong> the slaves have been loaded,
but before any application using IPC is run. Applications connect to the
IPC Daemon during the call to Ipc_start() and disconnect during the call
to Ipc_stop().</p>
<p>At startup, the daemon creates a FIFO (named pipe) for listening for
connection requests from other user-mode clients. When a connection
request comes in, the daemon opens a dedicated FIFO for sending
responses to the client.</p>
<p>At run-time, LAD processes command in FIFO order, and these commands run
to completion before the next command is accepted.</p>
</div>
<div class="section" id="limitations">
<h4>4.4.11.1.2. Limitations<a class="headerlink" href="#limitations" title="Permalink to this headline">¶</a></h4>
<div class="section" id="startup-before-any-clients">
<h5>4.4.11.1.2.1. Startup Before Any Clients<a class="headerlink" href="#startup-before-any-clients" title="Permalink to this headline">¶</a></h5>
<p>The IPC daemon needs to be explicitly started before any client
applications call Ipc_start().</p>
</div>
<div class="section" id="maximum-number-of-simultaneous-connections">
<h5>4.4.11.1.2.2. Maximum Number of Simultaneous Connections<a class="headerlink" href="#maximum-number-of-simultaneous-connections" title="Permalink to this headline">¶</a></h5>
<p>The maximum number of simultaneous client connections to the IPC daemon
is currently 32 (the value of LAD_MAXNUMCLIENTS). Meaning, at most 32
client applications can call Ipc_start() at any given time.</p>
</div>
<div class="section" id="hard-coded-multiproc-configuration">
<h5>4.4.11.1.2.3. Hard-coded MultiProc configuration<a class="headerlink" href="#hard-coded-multiproc-configuration" title="Permalink to this headline">¶</a></h5>
<p>For a given device, the MultiProc configuration is predefined in a C
struct within the daemon. If you want to subset the MultiProc list, you
have to modify this struct and rebuild the daemon. And be sure to be
consistent with that MultiProc configuration in each of the slave images
as well.</p>
</div>
</div>
</div>
</div>
<div class="section" id="ipc-transports">
<h2>4.4.12. IPC Transports<a class="headerlink" href="#ipc-transports" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id51">
<h3>4.4.12.1. Introduction<a class="headerlink" href="#id51" title="Permalink to this headline">¶</a></h3>
<p>IPC transports are the underlying configurable data paths over shared
memory and hardware resources, which implement the IPC MessageQ APIs.
MessageQ provides a common IPC interface between processors within a
system containing a single or multiple KeyStone devices. Communication
between the processors is enabled through the use of IPC transports. The
transports supplied with the IPC component are shared memory based,
capable of intra-device communication. Additional transports, utilizing
the QMSS and SRIO LLDs, are supplied via Yocto/bitbake for ARMv7 Linux
IPC and PROCSDK PDK for SYS/BIOS DSP IPC, enabling intra-SoC and
inter-SoC communication, respectively.</p>
<p>The below table gives an overview of the transport offerings, their
location, and the communication path they enable.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 17%" />
<col style="width: 18%" />
<col style="width: 19%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Transport</strong></p></td>
<td><p><strong>MessageQ
Interface
Type</strong></p></td>
<td><p><strong>Location</strong></p></td>
<td><p><strong>Communication
Route</strong></p></td>
<td><p><strong>Enabled
Communication
Path</strong></p></td>
<td><p><strong>Special
Considerations</strong></p></td>
</tr>
<tr class="row-even"><td><p>Transport
Shm…</p></td>
<td><p>MessageQ
(priority
based)</p></td>
<td><p>IPC
component
-
SYS/BIOS
subdirect
ories</p></td>
<td><p>Shared
memory</p></td>
<td><p>SYS/BIOS
DSP to
DSP</p></td>
<td><p>There are
multiple
implementations
of Transport Shm
delivered within
the IPC component
Please see the
IPC documentation
provided with the
component for
more information
on these shared
memory transport
implementions</p></td>
</tr>
<tr class="row-odd"><td><p>Transport
Rpmsg</p></td>
<td><p>MessageQ
(priority
based)</p></td>
<td><ul class="simple">
<li><p>IPC
component -
ARMv7 Linux
subdirect
ories</p></li>
<li><p>IPC
component -
SYS/BIOS
subdirect
ories</p></li>
<li><p>Yocto/
bitbake
ti-ipc
recipe</p></li>
</ul>
</td>
<td><p>Shared
memory</p></td>
<td><ul class="simple">
<li><p>ARMv7
Linux to/from
SYS/BIOS DSP</p></li>
</ul>
</td>
<td><p>MessageQ messages
sent over
Transport Rpmsg
traveling
from/to ARMv7
user space
go through
the Linux kernel
before reaching
the DSP.
This provides
<em>clean</em>
partitioning
between user
memory and DSP
memory. However,
Transport Rpmsg
is considered
a <em>slow path</em>
since the user
space MessageQ
messages must be
copied from/to
DSP memory by
kernel and DSP.</p></td>
</tr>
<tr class="row-even"><td><p>SYS/BIOS
DSP
Transport
Srio</p></td>
<td><p>Network</p></td>
<td><p>PROCSDK
RTOS PDK</p></td>
<td><p>SRIO LLD</p></td>
<td><ul class="simple">
<li><p>SYS/BIOS
DSP to/from
SYS/BIOS DSP
(intra and
inter-device)</p></li>
<li><p>SYS/BIOS
DSP to/from
ARMv7 Linux
(intra- and
inter- device)</p></li>
</ul>
</td>
<td><p>TransportSrio
can send MessageQ
messages to ARMv7
and DSP
processors on
remote devices
in a multiple
device system.
IPC MultiProc
must be
configured to be
aware of all
processors
existing on all
devices and all
devices must be
connected over a
SRIO
interconnect.</p>
<p>The main
purpose of
TransportSrio
is for
multi-device
communication
over MessageQ.
The transmission
latency is
greater for
this transport
due to the
latter capability
Therefore it is
recommended a
shared memory or
other LLD-based
transport
is used for
intra-device
communication
due to their
lower latency
costs.</p>
</td>
</tr>
<tr class="row-odd"><td><p>ARMv7
Linux
Transport
Srio</p></td>
<td><p>Network</p></td>
<td><p>Yocto/bit
bake
ti-transp
ort-srio
recipe</p></td>
<td><p>SRIO LLD</p></td>
<td><ul class="simple">
<li><p>ARMv7
Linux to/from
ARMv7 Linux
(intra- and
inter-device)</p></li>
<li><p>SYS/BIOS
DSP to/from
ARMv7 Linux
(intra- and
inter-device)</p></li>
</ul>
</td>
<td><p>TransportSrio
can send
MessageQ messages
to ARMv7 and DSP
processors on
remote devices
in a multiple
device system.
IPC MultiProc
must be
configured to be
aware of all
processors
existing on all
devices and all
devices must be
connected
over a SRIO
interconnect.</p>
<p>The main
purpose of
TransportSrio
is for
multi-device
communication
over MessageQ.
The transmission
latency is
greater for
this transport
due to the latter
capability.
Therefore, it is
recommended
a shared memory
or other
LLD-based
transport
is used for
intra-device
communication
due to their
lower latency
costs.</p>
</td>
</tr>
<tr class="row-even"><td><p>SYS/BIOS
DSP
Transport
Qmss</p></td>
<td><p>Network</p></td>
<td></td>
<td><p>QMSS LLD</p></td>
<td><ul class="simple">
<li><p>SYS/BIOS
DSP to/from
SYS/BIOS DSP</p></li>
<li><p>SYS/BIOS
DSP to/from
ARMv7 Linux</p></li>
</ul>
</td>
<td></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td></td>
<td></td>
<td><ul class="simple">
<li><p>ARMv7 Linux
process
to process.</p></li>
<li><p>ARMv7
Linux to/from
SYS/BIOS DSP</p></li>
</ul>
</td>
<td></td>
</tr>
</tbody>
</table>
<p>The IPC component (ARMv7 and SYS/BIOS) is available in PROCSDK RTOS and
Linux installations. It will be installed in &lt;PROCSDK RTOS or Linux
install root&gt;/ipc_#_##_##_##&lt;version&gt;. Additionally, the IPC component’s
ARMv7 source is packaged in a Yocto/bitbake recipe. A user can develop
ARMv7 Linux user-space applications with IPC on Keystone I and KeyStone
II devices by building the ti-ipc package in Yocto.</p>
</div>
<div class="section" id="modes-of-operation">
<h3>4.4.12.2. Modes of Operation<a class="headerlink" href="#modes-of-operation" title="Permalink to this headline">¶</a></h3>
<div class="section" id="sys-bios-dsp-transportsrio">
<h4>4.4.12.2.1. SYS/BIOS DSP TransportSrio<a class="headerlink" href="#sys-bios-dsp-transportsrio" title="Permalink to this headline">¶</a></h4>
<p>The following SRIO socket types are supported:</p>
<p><strong>TransportSrio_srioSockType_TYPE_9</strong>: In this mode, the SRIO IPC
transport will use Type 9 sockets to communicate with other SRIO IPC
transport endpoints.</p>
<p><strong>TransportSrio_srioSockType_TYPE_11</strong>: In this mode, the SRIO IPC
transport will use Type 11 sockets to communicate with other SRIO IPC
transport endpoints.</p>
</div>
<div class="section" id="arm-linux-transportsrio">
<h4>4.4.12.2.2. ARM Linux TransportSrio<a class="headerlink" href="#arm-linux-transportsrio" title="Permalink to this headline">¶</a></h4>
<p>The following SRIO socket types are supported:</p>
<p><strong>sock_TYPE_9</strong>: In this mode, the ARM Linux SRIO IPC transport will use
Type 9 sockets to communicate with other SRIO IPC transport endpoints.</p>
<p><strong>sock_TYPE_11</strong>: In this mode, the ARM Linux SRIO IPC transport will
use Type 11 sockets to communicate with other SRIO IPC transport
endpoints.</p>
</div>
<div class="section" id="sys-bios-dsp-transportqmss">
<h4>4.4.12.2.3. SYS/BIOS DSP TransportQmss<a class="headerlink" href="#sys-bios-dsp-transportqmss" title="Permalink to this headline">¶</a></h4>
<p>The following QMSS receive queue types are supported:</p>
<p><strong>TransportQmss_queueRcvType_ACCUMULATOR</strong>: In this mode, the QMSS
accumulator logic is used as the reception mechanism for the QMSS
Transport.</p>
<p><strong>TransportQmss_queueRcvType_QPEND</strong>: In this mode, a QMSS QPEND (direct
interrupt) queue is used as the reception mechanism for the QMSS
Transport.</p>
</div>
<div class="section" id="arm-linux-transportqmss">
<h4>4.4.12.2.4. ARM Linux TransportQmss<a class="headerlink" href="#arm-linux-transportqmss" title="Permalink to this headline">¶</a></h4>
<p>A QMSS QPEND queue will always be used as the reception mechanism for
the ARM Linux QMSS Transport.</p>
</div>
</div>
<div class="section" id="id52">
<h3>4.4.12.3. Transport Configuration<a class="headerlink" href="#id52" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id53">
<h4>4.4.12.3.1. SYS/BIOS DSP TransportSrio<a class="headerlink" href="#id53" title="Permalink to this headline">¶</a></h4>
<div class="section" id="srio-serdes-and-lane-configuration">
<h5>4.4.12.3.1.1. SRIO SERDES and Lane Configuration<a class="headerlink" href="#srio-serdes-and-lane-configuration" title="Permalink to this headline">¶</a></h5>
<p>Configuration of the SRIO SERDES and lanes are required before calling
any driver APIs. Examples of the initialization sequences for supported
EVMs are provided in the TransportSrio example folder. The examples call
the SrioDevice_init() API prior to configuring the transport.
SrioDevice_init() reference:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ti</span><span class="o">/</span><span class="n">transport</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">c66</span><span class="o">/</span><span class="n">srio</span><span class="o">/</span><span class="n">example</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">device_srio</span><span class="p">.</span><span class="n">c</span>
</pre></div>
</div>
<p>Developers can modify the configurations made in the stock device_srio.c
to change SRIO endpoint IDs, routing information, lane rates, loopback
modes, etc.</p>
</div>
<div class="section" id="apis">
<h5>4.4.12.3.1.2. APIs<a class="headerlink" href="#apis" title="Permalink to this headline">¶</a></h5>
<p>API reference for application:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;ti/transport/ipc/c66/srio/TransportSrio.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id54">
<h4>4.4.12.3.2. ARM Linux TransportSrio<a class="headerlink" href="#id54" title="Permalink to this headline">¶</a></h4>
<div class="section" id="id55">
<h5>4.4.12.3.2.1. SRIO SERDES and Lane Configuration<a class="headerlink" href="#id55" title="Permalink to this headline">¶</a></h5>
<p>Configuration of the SRIO SERDES and lanes are required before calling
any driver APIs. Examples of the initialization sequences for supported
EVMs are provided in the TransportSrio test folder. The examples call
the SrioDevice_init() API prior to configuring the transport.
SrioDevice_init() reference from keystone-linux/ipc-transport git
repository:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">linux</span><span class="o">/</span><span class="n">srio</span><span class="o">/</span><span class="n">test</span><span class="o">/</span><span class="p">[</span><span class="n">consumer</span> <span class="n">or</span> <span class="n">producer</span><span class="p">]</span><span class="n">_device_srio</span><span class="p">.</span><span class="n">c</span>
</pre></div>
</div>
<p>Developers can modify the configurations made in the stock device_srio.c
to change SRIO endpoint IDs, routing information, lane rates, loopback
modes, etc.</p>
</div>
<div class="section" id="mpm-transport-srio-configuration">
<h5>4.4.12.3.2.2. MPM Transport SRIO Configuration<a class="headerlink" href="#mpm-transport-srio-configuration" title="Permalink to this headline">¶</a></h5>
<p>TransportSrio leverages MPM Transport in order to manage configuration
of the QMSS, CPPI, and SRIO LLDs. As a result, the transport’s
descriptor and descriptor buffer management is pushed to MPM Transport
in the ARM Linux version of TransportSrio. The MPM Transport JSON
configuration file can be modified to change QMSS descriptor and buffer
related parameters.</p>
<p>The MPM Transport JSON configuration file is located in the Linux file
system at /etc/mpm/mpm_config.json</p>
</div>
<div class="section" id="id56">
<h5>4.4.12.3.2.3. APIs<a class="headerlink" href="#id56" title="Permalink to this headline">¶</a></h5>
<p>API reference for application from keystone-linux/ipc-transport git
repository:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/srio/TransportSrio.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id57">
<h4>4.4.12.3.3. SYS/BIOS DSP TransportQmss<a class="headerlink" href="#id57" title="Permalink to this headline">¶</a></h4>
<div class="section" id="id58">
<h5>4.4.12.3.3.1. APIs<a class="headerlink" href="#id58" title="Permalink to this headline">¶</a></h5>
<p>API reference for application:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;ti/transport/ipc/c66/qmss/TransportQmss.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id59">
<h4>4.4.12.3.4. ARM Linux TransportQmss<a class="headerlink" href="#id59" title="Permalink to this headline">¶</a></h4>
<div class="section" id="mpm-transport-qmss-configuration">
<h5>4.4.12.3.4.1. MPM Transport QMSS Configuration<a class="headerlink" href="#mpm-transport-qmss-configuration" title="Permalink to this headline">¶</a></h5>
<p>TransportQmss leverages MPM Transport in order to manage configuration
of the QMSS and CPPI LLDs. As a result, the transport’s descriptor and
descriptor buffer management is pushed to MPM Transport in the ARM Linux
version of TransportQmss. The MPM Transport JSON configuration file can
be modified to change QMSS descriptor and buffer related parameters.</p>
<p>The MPM Transport JSON configuration file is located in the Linux file
system at /etc/mpm/mpm_config.json</p>
</div>
<div class="section" id="id60">
<h5>4.4.12.3.4.2. APIs<a class="headerlink" href="#id60" title="Permalink to this headline">¶</a></h5>
<p>API reference for application from keystone-linux/ipc-transport git
repository:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/qmss/TransportQmss.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="source-delivery-and-recompilation">
<h3>4.4.12.4. Source Delivery and Recompilation<a class="headerlink" href="#source-delivery-and-recompilation" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id61">
<h4>4.4.12.4.1. SYS/BIOS DSP TransportSrio<a class="headerlink" href="#id61" title="Permalink to this headline">¶</a></h4>
<p>The SYS/BIOS DSP TransportSrio source code and examples are delivered
within the PROCSDK RTOS PDK component. DSP TransportSrio can be rebuilt
using the environment setup scripts provided with the PDK package. DSP
TransportSrio example applications are created as part of the
pdkProjectCreate scripts. They can be imported and built the same as PDK
LLD example and test CCS projects.</p>
<div class="section" id="recompiling-on-windows">
<h5>4.4.12.4.1.1. Recompiling on Windows<a class="headerlink" href="#recompiling-on-windows" title="Permalink to this headline">¶</a></h5>
<ol class="arabic simple">
<li><p>Open a Windows command terminal and navigate to
&lt;pdk_install_dir&gt;/packages.</p></li>
<li><p>Run pdksetupenv.bat
&gt;pdksetupenv.bat</p></li>
<li><p>Navigate to &lt;pdk_install_path&gt;/packages/ti/transport/ipc/c66/srio/</p></li>
<li><p>Build the IPC SRIO Transport library
&gt;gmake</p></li>
</ol>
<p>Issue the following commands if the SRIO transport ever needs to be
rebuilt:</p>
<p>&gt;gmake clean
&gt;gmake</p>
</div>
<div class="section" id="recompiling-on-linux">
<h5>4.4.12.4.1.2. Recompiling on Linux<a class="headerlink" href="#recompiling-on-linux" title="Permalink to this headline">¶</a></h5>
<ol class="arabic simple">
<li><p>Open a Linux bash terminal and navigate to
&lt;pdk_install_dir&gt;/packages.</p></li>
<li><p>Run pdksetupenv.sh
$ source pdksetupenv.sh</p></li>
<li><p>Navigate to &lt;pdk_install_path&gt;/packages/ti/transport/ipc/c66/srio/</p></li>
<li><p>Build the IPC SRIO Transport library
$ make</p></li>
</ol>
<p>Issue the following commands if the SRIO transport ever needs to be
rebuilt:</p>
<p>$ make clean
$ make</p>
</div>
</div>
<div class="section" id="arm-linux-transportsrio-source-delivery-and-recompilation">
<h4>4.4.12.4.2. ARM Linux TransportSrio Source Delivery and Recompilation<a class="headerlink" href="#arm-linux-transportsrio-source-delivery-and-recompilation" title="Permalink to this headline">¶</a></h4>
<p>The ARM Linux TransportSrio source code can be downloaded and built two
ways. The transport source code is delivered and built as part of
Yocto/bitbake. The source code can also be downloaded and built directly
from the GIT repository.</p>
<div class="section" id="recompiling-through-yocto-bitbake">
<h5>4.4.12.4.2.1. Recompiling Through Yocto/bitbake<a class="headerlink" href="#recompiling-through-yocto-bitbake" title="Permalink to this headline">¶</a></h5>
<ol class="arabic">
<li><p>Follow the instructions in the Exploring section of the user guide to
configure the <a class="reference external" href="http://software-dl.ti.com/processor-sdk-linux/esd/docs/latest/linux/Overview_Building_the_SDK.html">Yocto build
environment</a>.
The tisdk-server-rootfs-image does not need to be built. Instead look
at the section for <a class="reference external" href="http://software-dl.ti.com/processor-sdk-linux/esd/docs/latest/linux/Overview_Building_the_SDK.html#recipes">building other
components</a></p></li>
<li><p>Build the TransportSrio libraries, ipc-transport-srio recipe, and
user-space tests, ipc-transport-srio-test recipe:
$ MACHINE=k2hk-evm TOOLCHAIN_BRAND=linaro ARAGO_BRAND=mcsdk bitbake
ipc-transport-srio
$ MACHINE=k2hk-evm TOOLCHAIN_BRAND=linaro ARAGO_BRAND=mcsdk bitbake
ipc-transport-srio-test</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The initial build may take quite some time since the kernel is built as a dependency</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Building with just the ipc-transport-srio-test recipe will also build the
ipc-transport-srio recipe since the test recipe depends on the library recipe.</p>
</div>
</li>
<li><p>The built TransportSrio static library will be located in
&lt;base_path&gt;/oe-layersetup/build/arago-tmp-external-linaro-toolchain/work/cortexa15hf-vfp-neon-3.8-oe-linux-gnueabi/ipc-transport-srio/&lt;tag-ver_recipe-ver&gt;/packages-split/ipc-transport-srio-staticdev/usr/lib/libTransportSrio.a
The built TransportSrio shared library will be located in
&lt;base_path&gt;/oe-layersetup/build/arago-tmp-external-linaro-toolchain/work/cortexa15hf-vfp-neon-3.8-oe-linux-gnueabi/ipc-transport-srio/&lt;tag-ver_recipe-ver&gt;/packages-split/ipc-transport-srio/usr/lib/libTransportSrio.so.1.0.0</p></li>
<li><p>The ipc-transport-srio-test recipe will build test static and shared
library executables for all supported devices. The executables will
be located in
base_path&gt;/oe-layersetup/build/arago-tmp-external-linaro-toolchain/work/cortexa15hf-vfp-neon-3.8-oe-linux-gnueabi/ipc-transport-srio-test/&lt;tag-ver_recipe-ver&gt;/packages-split/ipc-transport-srio-test/usr/bin/</p></li>
</ol>
</div>
<div class="section" id="recompiling-through-git-repository">
<h5>4.4.12.4.2.2. Recompiling Through GIT Repository<a class="headerlink" href="#recompiling-through-git-repository" title="Permalink to this headline">¶</a></h5>
<p>Recompiling through the ARM Linux TransportSrio GIT repository requires
that the latest PROCSDK Linux installation. The PROCSDK Linux PDK
component and the Linux devkit must be installed. The Linux devkit
installation script can be found in &lt;PROCSDK Linux install
root&gt;/procsdk_linux_3_XX_YY_ZZ/linux-devkit/</p>
<ol class="arabic">
<li><p>Clone the keystone-linux/ipc-transport repository from git.ti.com
$ git clone git://git.ti.com/keystone-linux/ipc-transport.git</p></li>
<li><p>Navigate to the PROCSDK Linux installation of pdk_3_XX_YY_ZZ/packages
and source armv7setupenv.sh.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The armv7setupenv.sh script must be modified to
point to the linaro toolchain and installed devkit path</p>
<p>$ source armv7setupenv.sh</p>
</div>
</li>
<li><p>Navigate back to the SRIO transport directory in the ipc-transport
GIT repository
$ cd &lt;repo_root_path&gt;/ipc-transport/linus/srio</p></li>
<li><p>Build the TransportSrio library and user-space test executables:
$ make lib
$ make tests</p></li>
<li><p>The TransportSrio static and shared libraries will be copied directly
into the Linux devkit’s /usr/lib folder as long as the devkit install
path was setup correctly prior to running the armv7setupenv.sh script</p></li>
<li><p>The test executables will be generated in the
&lt;base_repo_path&gt;/ipc-transport/bin/&lt;k2 device&gt;/test/ folder. Only the
device specified in the armv7setupenv.sh will be built.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Setting the USEDYNAMIC_LIB environment variable to
“yes” will generate the shared library test executables</p>
<p>$ export USEDYNAMIC_LIB=yes</p>
</div>
</div>
</div>
<div class="section" id="sys-bios-dsp-transportqmss-source-delivery-and-recompilation">
<h4>4.4.12.4.3. SYS/BIOS DSP TransportQmss Source Delivery and Recompilation<a class="headerlink" href="#sys-bios-dsp-transportqmss-source-delivery-and-recompilation" title="Permalink to this headline">¶</a></h4>
<p>The SYS/BIOS DSP TransportQmss source code and examples are delivered
within the PROCSDK RTOS PDK component. DSP TransportQmss can be rebuilt
using the environment setup scripts provided with the PDK package. DSP
TransportQmss example applications are created as part of the
pdkProjectCreate scripts. They can be imported and built the same as PDK
LLD example and test CCS projects.</p>
<div class="section" id="id62">
<h5>4.4.12.4.3.1. Recompiling on Windows<a class="headerlink" href="#id62" title="Permalink to this headline">¶</a></h5>
<ol class="arabic simple">
<li><p>Open a Windows command terminal and navigate to
&lt;pdk_install_dir&gt;/packages.</p></li>
<li><p>Run pdksetupenv.bat
&gt;pdksetupenv.bat</p></li>
<li><p>Navigate to &lt;pdk_install_path&gt;/packages/ti/transport/ipc/c66/qmss/</p></li>
<li><p>Build the IPC QMSS Transport library
&gt;gmake</p></li>
</ol>
<p>Issue the following commands if the QMSS transport ever needs to be
rebuilt:</p>
<p>&gt;gmake clean
&gt;gmake</p>
</div>
<div class="section" id="id63">
<h5>4.4.12.4.3.2. Recompiling on Linux<a class="headerlink" href="#id63" title="Permalink to this headline">¶</a></h5>
<ol class="arabic simple">
<li><p>Open a Linux bash terminal and navigate to
&lt;pdk_install_dir&gt;/packages.</p></li>
<li><p>Run pdksetupenv.sh
$ source pdksetupenv.sh</p></li>
<li><p>Navigate to &lt;pdk_install_path&gt;/packages/ti/transport/ipc/c66/qmss/</p></li>
<li><p>Build the IPC QMSS Transport library
$ make</p></li>
</ol>
<p>Issue the following commands if the QMSS transport ever needs to be
rebuilt:</p>
<p>$ make clean
$ make</p>
</div>
</div>
<div class="section" id="arm-linux-transportqmss-source-delivery-and-recompilation">
<h4>4.4.12.4.4. ARM Linux TransportQmss Source Delivery and Recompilation<a class="headerlink" href="#arm-linux-transportqmss-source-delivery-and-recompilation" title="Permalink to this headline">¶</a></h4>
<p>The ARM Linux TransportQmss source code can be downloaded and built two
ways. The transport source code is delivered and built as part of
Yocto/bitbake. The source code can also be downloaded and built directly
from the GIT repository.</p>
<div class="section" id="id64">
<h5>4.4.12.4.4.1. Recompiling Through Yocto/bitbake<a class="headerlink" href="#id64" title="Permalink to this headline">¶</a></h5>
<ol class="arabic">
<li><p>Follow the instructions in the Exploring section of the user guide to
configure the <a class="reference external" href="http://processors.wiki.ti.com/index.php/MCSDK_UG_Chapter_Exploring#Yocto">Yocto build
environment</a>.
The tisdk-server-rootfs-image does not need to be built. Instead look
at the section for <a class="reference external" href="http://processors.wiki.ti.com/index.php/MCSDK_UG_Chapter_Exploring#Building_other_components_in_Yocto">building other
components</a></p></li>
<li><p>Build the TransportQmss libraries, ipc-transport-qmss recipe, and
user-space tests, ipc-transport-qmss-test recipe:
$ MACHINE=k2hk-evm TOOLCHAIN_BRAND=linaro ARAGO_BRAND=mcsdk bitbake
ipc-transport-qmss
$ MACHINE=k2hk-evm TOOLCHAIN_BRAND=linaro ARAGO_BRAND=mcsdk bitbake
ipc-transport-qmss-test</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The initial build may take quite some time since
the kernel is built as a dependency</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Building with just the ipc-transport-qmss-test
recipe will also build the ipc-transport-qmss recipe since the test
recipe depends on the library recipe.</p>
</div>
</li>
<li><p>The built TransportQmss static library will be located in
&lt;base_path&gt;/oe-layersetup/build/arago-tmp-external-linaro-toolchain/work/cortexa15hf-vfp-neon-3.8-oe-linux-gnueabi/ipc-transport-qmss/&lt;tag-ver_recipe-ver&gt;/packages-split/ipc-transport-qmss-staticdev/usr/lib/libTransportQmss.a
The built TransportQmss shared library will be located in
&lt;base_path&gt;/oe-layersetup/build/arago-tmp-external-linaro-toolchain/work/cortexa15hf-vfp-neon-3.8-oe-linux-gnueabi/ipc-transport-qmss/&lt;tag-ver_recipe-ver&gt;/packages-split/ipc-transport-qmss/usr/lib/libTransportQmss.so.1.0.0</p></li>
<li><p>The ipc-transport-qmss-test recipe will build test static and shared
library executables for all supported devices. The executables will
be located in
base_path&gt;/oe-layersetup/build/arago-tmp-external-linaro-toolchain/work/cortexa15hf-vfp-neon-3.8-oe-linux-gnueabi/ipc-transport-qmss-test/&lt;tag-ver_recipe-ver&gt;/packages-split/ipc-transport-qmss-test/usr/bin/</p></li>
</ol>
</div>
<div class="section" id="id65">
<h5>4.4.12.4.4.2. Recompiling Through GIT Repository<a class="headerlink" href="#id65" title="Permalink to this headline">¶</a></h5>
<p>Recompiling through the ARMv7 Linux TransportQmss GIT repository
requires that the latest PROCSDK Linux installation. The PROCSDK Linux
PDK component and the Linux devkit must be installed. The Linux devkit
installation script can be found in &lt;PROCSDK Linux install
root&gt;/processor_sdk_linux_3_XX_YY_ZZ/linux-devkit/</p>
<ol class="arabic">
<li><p>Clone the keystone-linux/ipc-transport repository from git.ti.com
$ git clone git://git.ti.com/keystone-linux/ipc-transport.git</p></li>
<li><p>Navigate to the PROCSDK Linux installation of pdk_3_XX_YY_ZZ/packages
and source armv7setupenv.sh.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The armv7setupenv.sh script must be modified build
for the correct K2 device, and to point to the linaro toolchain and
installed devkit path</p>
<p>$ source armv7setupenv.sh</p>
</div>
</li>
<li><p>Navigate back to the QMSS transport directory in the ipc-transport
GIT repository
$ cd &lt;repo_root_path&gt;/ipc-transport/linus/qmss</p></li>
<li><p>Build the TransportQmss library and user-space test executables:
$ make lib
$ make tests</p></li>
<li><p>The TransportQmss static and shared libraries will be copied directly
into the Linux devkit’s /usr/lib folder as long as the devkit install
path was setup correctly prior to running the armv7setupenv.sh script</p></li>
<li><p>The test executables will be generated in the
&lt;base_repo_path&gt;/ipc-transport/bin/&lt;k2 device&gt;/test/ folder. Only the
device specified in the armv7setupenv.sh will be built.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Setting the USEDYNAMIC_LIB environment variable to
“yes” will generate the shared library test executables</p>
<blockquote>
<div><p>$ export USEDYNAMIC_LIB=yes</p>
</div></blockquote>
</div>
</div>
</div>
</div>
<div class="section" id="tests-examples">
<h3>4.4.12.5. Tests &amp; Examples<a class="headerlink" href="#tests-examples" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id66">
<h4>4.4.12.5.1. SYS/BIOS DSP TransportSrio<a class="headerlink" href="#id66" title="Permalink to this headline">¶</a></h4>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Expected Results</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>SYS/BIOS DSP
TransportSrio
Benchmark Example</p></td>
<td><div class="line-block">
<div class="line">Example
demonstrating
intra-SoC, DSP to
DSP, transport over
SRIO use while also
measuring latency
and throughput
performance. The
example consists of
multiple iterations
where each
iteration runs SRIO
with different lane
configurations.
Reference example
for developers</div>
</div>
</td>
<td><div class="line-block">
<div class="line">Successful
completion on two
DSP cores for all
example iterations.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>SYS/BIOS DSP
TransportSrio
Producer/Consumer
Example</p></td>
<td><div class="line-block">
<div class="line">Example
demonstrates
inter-SoC, DSP to
DSP, transport over
SRIO. The example
consists of
multiple iterations
where each
iteration runs SRIO
with different lane
configurations.</div>
</div>
</td>
<td><p>Successful completion
for all example
iterations on two DSP
cores per producer
and consumer devices.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id67">
<h4>4.4.12.5.2. ARM Linux TransportSrio<a class="headerlink" href="#id67" title="Permalink to this headline">¶</a></h4>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Expected Results</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ARM Linux
TransportSrio
Producer/Consumer
Example</p></td>
<td><div class="line-block">
<div class="line">Example
demonstrates
inter-SoC, ARM
Linux to ARM Linux,
transport over
SRIO. The example
consists of
multiple iterations
where each
iteration runs SRIO
with different lane
configurations.</div>
</div>
</td>
<td><p>Successful completion
for all example
iterations on two
Linux processes per
producer and consumer
devices.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id68">
<h4>4.4.12.5.3. SYS/BIOS DSP TransportQmss<a class="headerlink" href="#id68" title="Permalink to this headline">¶</a></h4>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Expected Results</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>SYS/BIOS DSP
TransportQmss
Benchmark Example</p></td>
<td><div class="line-block">
<div class="line">Example
demonstrating
intra-SoC, DSP to
DSP, transport over
QMSS use while also
measuring latency
and throughput
performance. The
example consists of
multiple iterations
where each
iteration runs QMSS
with different
reception
mechanisms
(accumulator or
QPEND queue).
Reference example
for developers</div>
</div>
</td>
<td><div class="line-block">
<div class="line">Successful
completion on two
DSP cores for all
example iterations.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>SYS/BIOS DSP
TransportQmss
DSP-Side of
Heterogeneous
Processor Test</p></td>
<td><div class="line-block">
<div class="line">Tests inter-SoC,
ARM Linux to DSP,
transport over
QMSS. Reference
test for developers</div>
</div>
</td>
<td><p>Successful completion
on two DSP cores and
two Linux processes.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id69">
<h4>4.4.12.5.4. ARM Linux TransportQmss<a class="headerlink" href="#id69" title="Permalink to this headline">¶</a></h4>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Expected Results</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ARM Linux
TransportQmss
Multi-Process Test</p></td>
<td><div class="line-block">
<div class="line">Tests Linux
inter-process
communication via
IPC transport over
QMSS. Reference
test for developers</div>
</div>
</td>
<td><div class="line-block">
<div class="line">Successful
completion on four
Linux processes.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>ARM Linux
TransportQmss
Linux-Side of
Heterogeneous
Processor Test</p></td>
<td><div class="line-block">
<div class="line">Tests inter-SoC,
ARM Linux to DSP,
transport over
QMSS. Reference
test for developers</div>
</div>
</td>
<td><p>Successful completion
on two DSP cores and
two Linux processes.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="additional-references">
<h3>4.4.12.6. Additional References<a class="headerlink" href="#additional-references" title="Permalink to this headline">¶</a></h3>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Document</strong></p></td>
<td><p><strong>Location</strong></p></td>
</tr>
<tr class="row-even"><td><p>TransportQmss API Reference
Manual</p></td>
<td><p>$(TI_PDK_INSTALL_DIR)packagesti
transportipcc66qmssdocsdoxy
genhtmlindex.html</p></td>
</tr>
<tr class="row-odd"><td><p>TransportQmss Release Notes</p></td>
<td><p>$(TI_PDK_INSTALL_DIR)packagesti
transportipcc66qmssdocsRele
aseNotes_TransportQmss.pdf</p></td>
</tr>
<tr class="row-even"><td><p>TransportSrio API Reference
Manual</p></td>
<td><p>$(TI_PDK_INSTALL_DIR)packagesti
transportipcc66sriodocsdoxy
genhtmlindex.html</p></td>
</tr>
<tr class="row-odd"><td><p>TransportSrio Release Notes</p></td>
<td><p>$(TI_PDK_INSTALL_DIR)packagesti
transportipcc66sriodocsRele
aseNotes_TransportSrio.pdf</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="ipc-benchmarking">
<h2>4.4.13. IPC Benchmarking<a class="headerlink" href="#ipc-benchmarking" title="Permalink to this headline">¶</a></h2>
<div class="section" id="messageqbench">
<h3>4.4.13.1. MessageQBench<a class="headerlink" href="#messageqbench" title="Permalink to this headline">¶</a></h3>
<p>The application utilizes the IPC 3.x stack to communicate from the main
processor to the slave core via the MessageQ interface. The application
measures the time taken to accomplish this. The MessageQBench binaries
are included in the Linux file system and they are located in:</p>
<div class="line-block">
<div class="line">Linux Application: /usr/bin/MessageQBench</div>
<div class="line">DSP binary:        /lib/firmware/ipc/ti_platforms_[platform]_core0/messageq_single.xe66</div>
<div class="line"><br /></div>
</div>
<p>The MessageQBench can be built following the instruction described in
the below Build section or using high level build in Linux Processor
SDK as described in <a class="reference external" href="http://software-dl.ti.com/processor-sdk-linux/esd/docs/latest/linux/Foundational_Components_IPC.html#ipc-quick-start-guide">IPC Quick Start Guide</a></p>
<div class="section" id="id70">
<h4>4.4.13.1.1. Build<a class="headerlink" href="#id70" title="Permalink to this headline">¶</a></h4>
<p>This section outlines the build process for the MessageQBench
application.</p>
<div class="section" id="linux">
<h5>4.4.13.1.1.1. Linux<a class="headerlink" href="#linux" title="Permalink to this headline">¶</a></h5>
<p>To build the application, follow the <a class="reference external" href="index_Foundational_Components.html#linux-install-guide">Linux IPC Install
Guide</a> to configure and build the
Linux-side applications for your device. You’ll also need to build the
corresponding BIOS side of IPC as indicated in the guide.</p>
</div>
<div class="section" id="qnx">
<h5>4.4.13.1.1.2. QNX<a class="headerlink" href="#qnx" title="Permalink to this headline">¶</a></h5>
<p>To build the application, follow the <a class="reference external" href="index_Foundational_Components.html#qnx-install-guide">QNX IPC Install
Guide</a> to configure and build the
QNX-side test applications for your device. You’ll also need to build
the corresponding BIOS side of IPC as indicated in the guide.</p>
</div>
<div class="section" id="android">
<h5>4.4.13.1.1.3. Android<a class="headerlink" href="#android" title="Permalink to this headline">¶</a></h5>
<p>The IPC development sources should be included in the Android Filesystem
(AFS) indicated by the manifest provided in your AFS distribution. The
sources are located in $(AFS_ROOT)/hardware/ti/ipc directory.</p>
<p>To build the IPC applications, follow the same procedure to build the
entire AFS. If you want to specifically build the IPC content, you can
issue the following command to build the needed IPC libraries and
application from the top your AFS installation (must configure and pick
the correct <strong>lunch</strong> target for your device).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>$buildhost make -j messageQApp \
                     messageQBench \
                     messageQMulti \
                     nameServerApp \
                     ping_rpmsg \
                     lad_dra7xx \
                     libmmrpc
</pre></div>
</div>
<p>To build the corresponding SysBios side of IPC follow the <a class="reference external" href="index_Foundational_Components.html#linux-install-guide">IPC Install
Guide</a>.</p>
</div>
</div>
<div class="section" id="id71">
<h4>4.4.13.1.2. Run<a class="headerlink" href="#id71" title="Permalink to this headline">¶</a></h4>
<p>This section illustrates the steps to run the MessageQBench application.</p>
<div class="section" id="linux-android">
<h5>4.4.13.1.2.1. Linux/Android<a class="headerlink" href="#linux-android" title="Permalink to this headline">¶</a></h5>
<p>The built IPC libraries and applications must be copied (installed) onto
the devices filesystem. The LAD Daemon must be running and application’s
corresponding slave-side binary must be loaded via the remoteproc kernel
module. The slave-side binary (messageq_single.x&lt;suffix&gt;), is located in
the $(IPC_ROOT)/packages/ti/ipc/tests/bin/&lt;device&gt; directory.</p>
<div class="line-block">
<div class="line"><br /></div>
<div class="line">Detailed information regarding this can be found in the <strong>Installing
Tests</strong> and <strong>IPC Daemons and Drivers</strong> section of the <a class="reference external" href="index_Foundational_Components.html#linux-install-guide">IPC Install
Guide</a>.</div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Android users - The Android binaries (lad_dra7xx and messageQBench) will
be located in the $(AFS_ROOT)/out/target/product/&lt;device&gt;/system/binary
directory. There are also dependent libraries (libtiipc.so,
libtiipcutils.so, and libtiipcutils_lad.so) in the
$(AFS_ROOT)/out/target/product/&lt;device&gt;/system/lib directory. These
files need to be copied to your device filesystem for execution.</p>
</div>
<div class="line-block">
<div class="line"><br /></div>
<div class="line">Once the LAD daemon is running and the slave core binary has been
loaded. You can execute the following to run the application:</div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target# /usr/bin/MessageQBench
</pre></div>
</div>
<p>The application will exchange 1000 messages with a payload of 8 by
default with an average round trip time per message. The following is
the usage parameters for the application.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="nl">Usage</span><span class="p">:</span> <span class="p">.</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">MessageQBench</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">numLoops</span><span class="o">&gt;</span><span class="p">]</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">payloadSize</span><span class="o">&gt;</span><span class="p">]</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">ProcId</span><span class="o">&gt;</span><span class="p">]</span>
       <span class="nl">Defaults</span><span class="p">:</span> <span class="nl">numLoops</span><span class="p">:</span> <span class="mi">1000</span><span class="p">;</span> <span class="nl">payloadSize</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="nl">ProcId</span><span class="p">:</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="section" id="id72">
<h5>4.4.13.1.2.2. QNX<a class="headerlink" href="#id72" title="Permalink to this headline">¶</a></h5>
<p>The built IPC libraries and test applications must be copied (installed)
onto the devices filesystem. The IPC resource manager must be running
and the application’s corresponding slave-side binary must be loaded
using the resource manager. The slave-side binary
(messageq_single.x&lt;suffix&gt;), is located in the
$(IPC_ROOT)/packages/ti/ipc/tests/bin/&lt;device&gt; directory.</p>
<div class="line-block">
<div class="line"><br /></div>
<div class="line">Detailed information regarding this can be found in the <strong>Installing
Tests in QNX</strong>, <strong>IPC resource manager</strong> and <strong>Running Test
Applications</strong> sections of the <a class="reference external" href="index_Foundational_Components.html#qnx-install-guide">IPC Install
Guide</a>.</div>
</div>
<p>Once the IPC resource manager is running and the slave core binary has
been loaded. You can execute the following to run the application:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target#  tests/MessageQBench 1000 8 &lt;slave core procId&gt;
</pre></div>
</div>
<p>The application will exchange 1000 messages with a payload of 8 with the
core identified by ‘procId’ and show an average round trip time per
message. The following shows the usage parameters for the application.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="nl">Syntax</span><span class="p">:</span>
  <span class="n">MessageQBench</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">numLoops</span><span class="o">&gt;</span><span class="p">]</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">payloadSize</span><span class="o">&gt;</span><span class="p">]</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">procId</span><span class="o">&gt;</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="ipc-performance">
<h3>4.4.13.2. IPC Performance<a class="headerlink" href="#ipc-performance" title="Permalink to this headline">¶</a></h3>
<p>The performance numbers in this section are gathered using Processor SDK
5.2 release.</p>
<div class="section" id="ipc-average-round-trip-time">
<h4>4.4.13.2.1. IPC Average Round Trip Time<a class="headerlink" href="#ipc-average-round-trip-time" title="Permalink to this headline">¶</a></h4>
<p>The average round trip time is measured using MessageQBench which calculates
the time for sending 1000 messages from the main processor to slave core and
divided by the number of messages sent (1000).</p>
<p>Average Round Trip Time (ARTT) for K2H/E/G and OMAP-L138 EVMs</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>PLSDK 5.2</p></th>
<th class="head"><p>K2H</p></th>
<th class="head"><p>K2E</p></th>
<th class="head"><p>K2G</p></th>
<th class="head"><p>OMAP-L138</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>CPU Speed</p></td>
<td><p>1.2GHz</p></td>
<td><p>1.4GHz</p></td>
<td><p>1GHz</p></td>
<td><p>456MHz</p></td>
</tr>
<tr class="row-odd"><td><p>ARTT (us)</p></td>
<td><p>115</p></td>
<td><p>68</p></td>
<td><p>81</p></td>
<td><p>904</p></td>
</tr>
<tr class="row-even"><td><p>ARTT &#64; 1GHz (us)</p></td>
<td><p>121</p></td>
<td><p>94</p></td>
<td><p>81</p></td>
<td><p>N/A</p></td>
</tr>
</tbody>
</table>
<p>Table: IPC Average Round Trip Time (ARTT)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The MessageQBench is a user space application which needs to call into
kernel space and involves linux context switch, process priority, and
multiple copies during the delivery of a message. Each message may show
different latency deviated from the average round trip time.</p>
</div>
</div>
<div class="section" id="throughput">
<h4>4.4.13.2.2. Throughput<a class="headerlink" href="#throughput" title="Permalink to this headline">¶</a></h4>
<p>Throughput benchmark uses a max transmit window of 130 outstanding messages
to get the maximum throughput. Beyond the max transit window of 130, there
won’t be enough resource to allocate additional messages before the
resource is returned by the outstanding messages. In this case, the
benchmark application will fail to run. Different payload sizes from 8 bytes
to max of 448 bytes are measured for each direction, and the numbers apply to
either direction. The throughput are measured with ARM/DSP running at 1 GHz.</p>
<p>Throughput for K2H/E/G and OMAP-L138 EVMs</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Payload (Bytes)</p></th>
<th class="head"><p>K2H (MB/s)</p></th>
<th class="head"><p>K2E (MB/s)</p></th>
<th class="head"><p>K2G (MB/s)</p></th>
<th class="head"><p>OMAP-L138 (MB/s)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>8</p></td>
<td><p>0.234</p></td>
<td><p>0.442</p></td>
<td><p>0.265</p></td>
<td><p>0.065</p></td>
</tr>
<tr class="row-odd"><td><p>16</p></td>
<td><p>0.362</p></td>
<td><p>0.681</p></td>
<td><p>0.333</p></td>
<td><p>0.099</p></td>
</tr>
<tr class="row-even"><td><p>32</p></td>
<td><p>0.599</p></td>
<td><p>1.078</p></td>
<td><p>0.548</p></td>
<td><p>0.163</p></td>
</tr>
<tr class="row-odd"><td><p>64</p></td>
<td><p>1.073</p></td>
<td><p>1.928</p></td>
<td><p>1.101</p></td>
<td><p>0.286</p></td>
</tr>
<tr class="row-even"><td><p>128</p></td>
<td><p>1.833</p></td>
<td><p>3.57</p></td>
<td><p>2.116</p></td>
<td><p>0.524</p></td>
</tr>
<tr class="row-odd"><td><p>256</p></td>
<td><p>3.288</p></td>
<td><p>6.693</p></td>
<td><p>5.855</p></td>
<td><p>0.988</p></td>
</tr>
<tr class="row-even"><td><p>448(Max)</p></td>
<td><p>5.038</p></td>
<td><p>11.056</p></td>
<td><p>18.967</p></td>
<td><p>1.676</p></td>
</tr>
</tbody>
</table>
<p>Table: IPC Throughput</p>
</div>
<div class="section" id="ipc-throughput-cpu-utilization">
<h4>4.4.13.2.3. IPC Throughput CPU Utilization<a class="headerlink" href="#ipc-throughput-cpu-utilization" title="Permalink to this headline">¶</a></h4>
<p>The CPU utilization is measured using max payload size of 448 bytes with
transmit window of 130 messages.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"><p>K2H (1.2GHz)</p></th>
<th class="head"><p>K2E (1.4GHz)</p></th>
<th class="head"><p>K2H (1GHz)</p></th>
<th class="head"><p>K2E (1GHz)</p></th>
<th class="head"><p>K2G</p></th>
<th class="head"><p>OMAP-L138</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>CPU Utilization</p></td>
<td><p>42%</p></td>
<td><p>47%</p></td>
<td><p>44%</p></td>
<td><p>49%</p></td>
<td><p>89.5%</p></td>
<td><p>100%</p></td>
</tr>
</tbody>
</table>
<p>Table: IPC Throughput CPU Utilization</p>
</div>
</div>
</div>
<div class="section" id="ipc-3-x">
<h2>4.4.14. IPC 3.x<a class="headerlink" href="#ipc-3-x" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id73">
<h3>4.4.14.1. Introduction<a class="headerlink" href="#id73" title="Permalink to this headline">¶</a></h3>
<p>This page contains details about the IPC 3.x product, TI’s solution for
interprocessor communication between cores on homogenous and
heterogeneous devices.</p>
<p>IPC 3.x is an evolution of the IPC product, so it helps to understand
the scope of previous generations.</p>
<ul class="simple">
<li><p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/index.html">The IPC
product</a>
defines <a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/index.html">several
interfaces</a>
to facilitate multiprocessor communication.</p></li>
<li><p>The IPC 1.x product includes implementations of those interfaces for
the SYS/BIOS RTOS. It supports communicating between cores running
SYS/BIOS, as well to HLOS processors running SysLink 2.x.</p></li>
<li><p>The SysLink 2.x provides services to control slave processors (e.g. load, start,
stop). It also provides an implementation of the IPC interfaces for
High Level OSs (HLOS) like Linux and QNX. SysLink 2.x supports
communicating with slave processors running SYS/BIOS and IPC 1.x.</p></li>
</ul>
<p>IPC 3.x merges the IPC 1.x and SysLink 2.x products, creating a single
product that defines multiprocessor communication APIs and provides
implementations for several OS’s, including SYS/BIOS and HLOS’s.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The SysLink name is being retired. The SysLink 2.x product will not
be supported on existing devices, and development has stopped and
support for new devices will not be added.</p>
</div>
</div>
<div class="section" id="changes">
<h3>4.4.14.2. Changes<a class="headerlink" href="#changes" title="Permalink to this headline">¶</a></h3>
<p>The key changes between IPC 1.x/SysLink 2.x and IPC 3.x is the HLOS
implementation. This table summarizes the IPC 1.x/SysLink 2.x supported APIs against
those provided in IPC 3.x.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Feature</p></th>
<th class="head"><p>IPC 1.x/SysLink 2.x</p></th>
<th class="head"><p>IPC 3.x</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Slave loading</p></td>
<td><p>ProcMgr</p></td>
<td><p>Slaves are loaded on
demand, currently
without a user API</p></td>
</tr>
<tr class="row-odd"><td><p>Low-level primitives</p></td>
<td><p>Notify, Heap*MP,
Gate*MP,
SharedRegion,
NameServer</p></td>
<td><p>Available for
BIOS-to-BIOS
communication, only
GateMP available on
HLOS</p></td>
</tr>
<tr class="row-even"><td><p>Messaging</p></td>
<td><p>MessageQ</p></td>
<td><p>MessageQ</p></td>
</tr>
<tr class="row-odd"><td><p>Higher level data
passing</p></td>
<td><p>RingIO, FrameQ</p></td>
<td><p>None, though IPC
provides primitives
to enable higher
level frameworks</p></td>
</tr>
</tbody>
</table>
<div class="section" id="bios">
<h4>4.4.14.2.1. BIOS<a class="headerlink" href="#bios" title="Permalink to this headline">¶</a></h4>
<p>For BIOS-to-BIOS communication, the same features available in IPC 1.x
are available in IPC 3.x.</p>
</div>
<div class="section" id="id74">
<h4>4.4.14.2.2. Linux<a class="headerlink" href="#id74" title="Permalink to this headline">¶</a></h4>
<p>On Linux, IPC 3.x is built upon services available (and evolving!) in
the mainline Linux kernel (3.4+). These core services include remoteproc
and rpmsg.</p>
<p>Above those Linux services, a few key services from the IPC API (e.g.
MessageQ) are provided in user mode.</p>
</div>
<div class="section" id="id75">
<h4>4.4.14.2.3. QNX<a class="headerlink" href="#id75" title="Permalink to this headline">¶</a></h4>
<p>On QNX, IPC 3.x provides feature parity to Linux. The QNX OS doesn’t
inherently provide primitives like Linux’s ‘remoteproc’ and ‘rpmsg’, so
IPC 3.x also includes a loader and rpmsg-compatible communication
infrastructure. This rpmsg-compatible MessageQ implementation enables
the same BIOS-side image to communicate with either Linux or QNX on the
HLOS.</p>
</div>
</div>
<div class="section" id="development">
<h3>4.4.14.3. Development<a class="headerlink" href="#development" title="Permalink to this headline">¶</a></h3>
<p>IPC 3.x development is being managed at <a class="reference external" href="https://git.ti.com/ipc">https://git.ti.com/ipc</a>.</p>
<p>There is an <a class="reference external" href="https://gforge.ti.com/mailman/listinfo/ipc-developers">open mailing
list</a> where
active discussion about the code base takes place. Patches are also
submitted there for review.</p>
</div>
<div class="section" id="ipc-training">
<h3>4.4.14.4. IPC Training<a class="headerlink" href="#ipc-training" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line">IPC training material is updated from time to time. Check back for new
updates.</div>
</div>
<div class="line-block">
<div class="line"><strong>IPC Training</strong> v2.21 - IPC 3.x Full Training Material <a class="reference download internal" download="" href="../_downloads/41c9417f0e8f15c7d1f19d3402a45f51/IPC_Training_2_21.pptx"><code class="xref download docutils literal notranslate"><span class="pre">(PowerPoint)</span></code></a> <a class="reference download internal" download="" href="../_downloads/2f5e1c358cd79b6479b828b59fc3902e/IPC_Training_2_21.ppsx"><code class="xref download docutils literal notranslate"><span class="pre">(PowerPointShow)</span></code></a> <a class="reference download internal" download="" href="../_downloads/85c6d027671b33dae6609a7cb7dc145e/IPC_Training_2_21.pdf"><code class="xref download docutils literal notranslate"><span class="pre">(PDF)</span></code></a></div>
</div>
<div class="line-block">
<div class="line">IPC Lab 1 - Hello <a class="reference download internal" download="" href="../_downloads/5cd26b725107d40f8dd9228bed5290d1/IPC_Lab_1_Hello.pptx"><code class="xref download docutils literal notranslate"><span class="pre">(PowerPoint)</span></code></a> <a class="reference download internal" download="" href="../_downloads/2a139f29424ec504fc8d5b5fe267cb70/IPC_Lab_1_Hello.ppsx"><code class="xref download docutils literal notranslate"><span class="pre">(PowerPointShow)</span></code></a> <a class="reference download internal" download="" href="../_downloads/f075fae093c224e08e1429c316d8003e/IPC_Lab_1_Hello.pdf"><code class="xref download docutils literal notranslate"><span class="pre">(PDF)</span></code></a></div>
</div>
<div class="line-block">
<div class="line">IPC Lab 2 - MessageQ <a class="reference download internal" download="" href="../_downloads/2ae08142fb70441c8edd8453e503bcef/IPC_Lab_2_MessageQ.pptx"><code class="xref download docutils literal notranslate"><span class="pre">(PowerPoint)</span></code></a> <a class="reference download internal" download="" href="../_downloads/969aae0b8777cc01940ec5474a6cbc68/IPC_Lab_2_MessageQ.ppsx"><code class="xref download docutils literal notranslate"><span class="pre">(PowerPointShow)</span></code></a> <a class="reference download internal" download="" href="../_downloads/2b30eaa2d065265306e31ff9b505e7d6/IPC_Lab_2_MessageQ.pdf"><code class="xref download docutils literal notranslate"><span class="pre">(PDF)</span></code></a></div>
</div>
<div class="line-block">
<div class="line">IPC Lab 3 - Scalability <a class="reference download internal" download="" href="../_downloads/92a1522832505ff58512757ad47cd7f9/IPC_Lab_3_Scalability.pptx"><code class="xref download docutils literal notranslate"><span class="pre">(PowerPoint)</span></code></a> <a class="reference download internal" download="" href="../_downloads/d351a667c11588b4abbd7fba515f7982/IPC_Lab_3_Scalability.ppsx"><code class="xref download docutils literal notranslate"><span class="pre">(PowerPointShow)</span></code></a> <a class="reference download internal" download="" href="../_downloads/0d23d5773afc192452b5ca4701c48571/IPC_Lab_3_Scalability.pdf"><code class="xref download docutils literal notranslate"><span class="pre">(PDF)</span></code></a></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="id76">
<h3>4.4.14.5. See Also<a class="headerlink" href="#id76" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="index_Foundational_Components.html#ipc-user-guide">IPC User’s Guide</a></p></li>
<li><p><a class="reference external" href="http://free-electrons.com/pub/video/2011/elce/elce-2011-ben-cohen-remote-processor-messaging-450p.webm">Embedded Linux Conference Europe Presentation on
rpmsg</a></p></li>
</ul>
</div>
<div class="section" id="resource-custom-table">
<h3>4.4.14.6. Resource Custom Table<a class="headerlink" href="#resource-custom-table" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id77">
<h4>4.4.14.6.1. Introduction<a class="headerlink" href="#id77" title="Permalink to this headline">¶</a></h4>
<p>The IPC 3.x product introduced support for loading slave images which
include a <a class="reference external" href="http://lwn.net/Articles/489009/">Linux-defined resource table</a>.
In IPC 3.00.01, <a class="reference external" href="http://git.ti.com/cgit/cgit.cgi/ipc/ipcdev.git/commit/?h=ipc-next&amp;id=44169db6cd6f02193acf7ee97c13f956f599431d">IPC added the ability</a>
for users to override the default resource table with their own. This
article describes the mechanics involved to do that.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Although the Linux community defined the resource table, the IPC port to
QNX also uses the same resource table.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is an expert technique. Most users do not need to modify the
default resource table.</p>
</div>
</div>
<div class="section" id="id78">
<h4>4.4.14.6.2. Config<a class="headerlink" href="#id78" title="Permalink to this headline">¶</a></h4>
<p>To indicate you want to provide your own resource table, you need to set
the <code class="docutils literal notranslate"><span class="pre">Resource.customTable</span></code> config parameter <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>/* Override the default resource table with my own */
var Resource = xdc.useModule(&#39;ti.ipc.remoteproc.Resource&#39;);
Resource.customTable = true;
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">Resource.customtable</span></code> is set to <code class="docutils literal notranslate"><span class="pre">true</span></code>, IPC will no longer
generate a default table, and the user will be able to supply their own
table using a specially-named C struct,
<code class="docutils literal notranslate"><span class="pre">ti_ipc_remoteproc_ResourceTable</span></code>.</p>
</div>
<div class="section" id="c-code">
<h4>4.4.14.6.3. C Code<a class="headerlink" href="#c-code" title="Permalink to this headline">¶</a></h4>
<p>The user-supplied resource table is a C structure named
<code class="docutils literal notranslate"><span class="pre">ti_ipc_remoteproc_ResourceTable</span></code> that needs to be linked into the
slave executable. The platform-specific default resource tables are
provided in IPC’s <strong>packages/ti/ip/remoteproc/rsc_table_*.h</strong>, and are
the recommended place to start from.</p>
<p>After finding the default resource table for your platform, you can copy
the entirety of it into your own C file, compile it, and link it into
your executable.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When configuring in a TYPE_TRACE element (a trace buffer) you must
explicitly declare the symbol as an extern (as below). The trace buffer
is generated during config, and unfortunately there is no header to
#include that declares the name of this symbol. Also note the size of
the trace buffer declared in the resource table must match the size
you’ve specified in your .cfg script.</p>
</div>
<p>For reference, here is an Vayu compatible resource table derived from
<strong>packages/ti/ipc/remoteproc/rsc_table_vayu_ipu.h</strong>( Disclaimer: This
is a reference design only, and it is subject to enhancements,
improvements and other changes without notifications).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;rsc_types.h&quot;</span><span class="cp"></span>

<span class="cm">/* IPU Memory Map */</span>
<span class="cp">#define L4_DRA7XX_BASE          0x4A000000</span>

<span class="cm">/* L4_CFG &amp; L4_WKUP */</span>
<span class="cp">#define L4_PERIPHERAL_L4CFG     (L4_DRA7XX_BASE)</span>
<span class="cp">#define IPU_PERIPHERAL_L4CFG    0x6A000000</span>

<span class="cp">#define L4_PERIPHERAL_L4PER1    0x48000000</span>
<span class="cp">#define IPU_PERIPHERAL_L4PER1   0x68000000</span>

<span class="cp">#define L4_PERIPHERAL_L4PER2    0x48400000</span>
<span class="cp">#define IPU_PERIPHERAL_L4PER2   0x68400000</span>

<span class="cp">#define L4_PERIPHERAL_L4PER3    0x48800000</span>
<span class="cp">#define IPU_PERIPHERAL_L4PER3   0x68800000</span>

<span class="cp">#define L4_PERIPHERAL_L4EMU     0x54000000</span>
<span class="cp">#define IPU_PERIPHERAL_L4EMU    0x74000000</span>

<span class="cp">#define L3_PERIPHERAL_PRUSS     0x4B200000</span>
<span class="cp">#define IPU_PERIPHERAL_PRUSS    0x6B200000</span>

<span class="cp">#define L3_PERIPHERAL_DMM       0x4E000000</span>
<span class="cp">#define IPU_PERIPHERAL_DMM      0x6E000000</span>

<span class="cp">#define L3_IVAHD_CONFIG         0x5A000000</span>
<span class="cp">#define IPU_IVAHD_CONFIG        0x7A000000</span>

<span class="cp">#define L3_IVAHD_SL2            0x5B000000</span>
<span class="cp">#define IPU_IVAHD_SL2           0x7B000000</span>

<span class="cp">#define L3_TILER_MODE_0_1       0x60000000</span>
<span class="cp">#define IPU_TILER_MODE_0_1      0xA0000000</span>

<span class="cp">#define L3_TILER_MODE_2         0x70000000</span>
<span class="cp">#define IPU_TILER_MODE_2        0xB0000000</span>

<span class="cp">#define L3_TILER_MODE_3         0x78000000</span>
<span class="cp">#define IPU_TILER_MODE_3        0xB8000000</span>

<span class="cp">#define L3_OCMC_RAM       0x40300000</span>
<span class="cp">#define IPU_OCMC_RAM      0x60300000</span>

<span class="cp">#define L3_EMIF_SDRAM     0xA0000000</span>
<span class="cp">#define IPU_EMIF_SDRAM        0x10000000</span>

<span class="cp">#define IPU_MEM_TEXT            0x0</span>
<span class="cp">#define IPU_MEM_DATA            0x80000000</span>

<span class="cp">#define IPU_MEM_IOBUFS          0x90000000</span>

<span class="cp">#define IPU_MEM_IPC_DATA        0x9F000000</span>
<span class="cp">#define IPU_MEM_IPC_VRING       0x60000000</span>
<span class="cp">#define IPU_MEM_RPMSG_VRING0    0x60000000</span>
<span class="cp">#define IPU_MEM_RPMSG_VRING1    0x60004000</span>
<span class="cp">#define IPU_MEM_VRING_BUFS0     0x60040000</span>
<span class="cp">#define IPU_MEM_VRING_BUFS1     0x60080000</span>

<span class="cp">#define IPU_MEM_IPC_VRING_SIZE  SZ_1M</span>
<span class="cp">#define IPU_MEM_IPC_DATA_SIZE   SZ_1M</span>

<span class="cp">#if defined(VAYU_IPU_1)</span>
<span class="cp">#define IPU_MEM_TEXT_SIZE       (SZ_1M)</span>
<span class="cp">#elif defined(VAYU_IPU_2)</span>
<span class="cp">#define IPU_MEM_TEXT_SIZE       (SZ_1M * 6)</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(VAYU_IPU_1)</span>
<span class="cp">#define IPU_MEM_DATA_SIZE       (SZ_1M * 5)</span>
<span class="cp">#elif defined(VAYU_IPU_2)</span>
<span class="cp">#define IPU_MEM_DATA_SIZE       (SZ_1M * 48)</span>
<span class="cp">#endif</span>

<span class="cp">#define IPU_MEM_IOBUFS_SIZE     (SZ_1M * 90)</span>

<span class="cm">/*</span>
<span class="cm"> * Assign fixed RAM addresses to facilitate a fixed MMU table.</span>
<span class="cm"> * PHYS_MEM_IPC_VRING &amp; PHYS_MEM_IPC_DATA MUST be together.</span>
<span class="cm"> */</span>
<span class="cm">/* See CMA BASE addresses in Linux side: arch/arm/mach-omap2/remoteproc.c */</span>
<span class="cp">#if defined(VAYU_IPU_1)</span>
<span class="cp">#define PHYS_MEM_IPC_VRING      0x9D000000</span>
<span class="cp">#elif defined (VAYU_IPU_2)</span>
<span class="cp">#define PHYS_MEM_IPC_VRING      0x95800000</span>
<span class="cp">#endif</span>

<span class="cp">#define PHYS_MEM_IOBUFS         0xBA300000</span>

<span class="cm">/*</span>
<span class="cm"> * Sizes of the virtqueues (expressed in number of buffers supported,</span>
<span class="cm"> * and must be power of 2)</span>
<span class="cm"> */</span>
<span class="cp">#define IPU_RPMSG_VQ0_SIZE      256</span>
<span class="cp">#define IPU_RPMSG_VQ1_SIZE      256</span>

<span class="cm">/* flip up bits whose indices represent features we support */</span>
<span class="cp">#define RPMSG_IPU_C0_FEATURES   1</span>

<span class="k">struct</span> <span class="n">my_resource_table</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">resource_table</span> <span class="n">base</span><span class="p">;</span>

    <span class="n">UInt32</span> <span class="n">offset</span><span class="p">[</span><span class="mi">21</span><span class="p">];</span>  <span class="cm">/* Should match &#39;num&#39; in actual definition */</span>

    <span class="cm">/* rpmsg vdev entry */</span>
    <span class="k">struct</span> <span class="n">fw_rsc_vdev</span> <span class="n">rpmsg_vdev</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">fw_rsc_vdev_vring</span> <span class="n">rpmsg_vring0</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">fw_rsc_vdev_vring</span> <span class="n">rpmsg_vring1</span><span class="p">;</span>

    <span class="cm">/* text carveout entry */</span>
    <span class="k">struct</span> <span class="n">fw_rsc_carveout</span> <span class="n">text_cout</span><span class="p">;</span>

    <span class="cm">/* data carveout entry */</span>
    <span class="k">struct</span> <span class="n">fw_rsc_carveout</span> <span class="n">data_cout</span><span class="p">;</span>

    <span class="cm">/* ipcdata carveout entry */</span>
    <span class="k">struct</span> <span class="n">fw_rsc_carveout</span> <span class="n">ipcdata_cout</span><span class="p">;</span>

    <span class="cm">/* trace entry */</span>
    <span class="k">struct</span> <span class="n">fw_rsc_trace</span> <span class="n">trace</span><span class="p">;</span>

    <span class="cm">/* devmem entry */</span>
    <span class="k">struct</span> <span class="n">fw_rsc_devmem</span> <span class="n">devmem0</span><span class="p">;</span>

    <span class="cm">/* devmem entry */</span>
    <span class="k">struct</span> <span class="n">fw_rsc_devmem</span> <span class="n">devmem1</span><span class="p">;</span>

    <span class="cm">/* devmem entry */</span>
    <span class="k">struct</span> <span class="n">fw_rsc_devmem</span> <span class="n">devmem2</span><span class="p">;</span>

    <span class="cm">/* devmem entry */</span>
    <span class="k">struct</span> <span class="n">fw_rsc_devmem</span> <span class="n">devmem3</span><span class="p">;</span>

    <span class="cm">/* devmem entry */</span>
    <span class="k">struct</span> <span class="n">fw_rsc_devmem</span> <span class="n">devmem4</span><span class="p">;</span>

    <span class="cm">/* devmem entry */</span>
    <span class="k">struct</span> <span class="n">fw_rsc_devmem</span> <span class="n">devmem5</span><span class="p">;</span>

    <span class="cm">/* devmem entry */</span>
    <span class="k">struct</span> <span class="n">fw_rsc_devmem</span> <span class="n">devmem6</span><span class="p">;</span>

    <span class="cm">/* devmem entry */</span>
    <span class="k">struct</span> <span class="n">fw_rsc_devmem</span> <span class="n">devmem7</span><span class="p">;</span>

    <span class="cm">/* devmem entry */</span>
    <span class="k">struct</span> <span class="n">fw_rsc_devmem</span> <span class="n">devmem8</span><span class="p">;</span>

    <span class="cm">/* devmem entry */</span>
    <span class="k">struct</span> <span class="n">fw_rsc_devmem</span> <span class="n">devmem9</span><span class="p">;</span>

    <span class="cm">/* devmem entry */</span>
    <span class="k">struct</span> <span class="n">fw_rsc_devmem</span> <span class="n">devmem10</span><span class="p">;</span>

    <span class="cm">/* devmem entry */</span>
    <span class="k">struct</span> <span class="n">fw_rsc_devmem</span> <span class="n">devmem11</span><span class="p">;</span>

    <span class="cm">/* devmem entry */</span>
    <span class="k">struct</span> <span class="n">fw_rsc_devmem</span> <span class="n">devmem12</span><span class="p">;</span>

    <span class="cm">/* devmem entry */</span>
    <span class="k">struct</span> <span class="n">fw_rsc_devmem</span> <span class="n">devmem13</span><span class="p">;</span>

    <span class="cm">/* devmem entry */</span>
    <span class="k">struct</span> <span class="n">fw_rsc_devmem</span> <span class="n">devmem14</span><span class="p">;</span>

    <span class="cm">/* devmem entry */</span>
    <span class="k">struct</span> <span class="n">fw_rsc_devmem</span> <span class="n">devmem15</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">ti_trace_SysMin_Module_State_0_outbuf__A</span><span class="p">;</span>
<span class="cp">#define TRACEBUFADDR (UInt32)&amp;ti_trace_SysMin_Module_State_0_outbuf__A</span>

<span class="cp">#pragma DATA_SECTION(ti_ipc_remoteproc_ResourceTable, &quot;.resource_table&quot;)</span>
<span class="cp">#pragma DATA_ALIGN(ti_ipc_remoteproc_ResourceTable, 4096)</span>

<span class="k">struct</span> <span class="n">my_resource_table</span> <span class="n">ti_ipc_remoteproc_ResourceTable</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">1</span><span class="p">,</span>      <span class="cm">/* we&#39;re the first version that implements this */</span>
    <span class="mi">21</span><span class="p">,</span>     <span class="cm">/* number of entries in the table */</span>
    <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>   <span class="cm">/* reserved, must be zero */</span>
    <span class="cm">/* offsets to entries */</span>
    <span class="p">{</span>
        <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_resource_table</span><span class="p">,</span> <span class="n">rpmsg_vdev</span><span class="p">),</span>
        <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_resource_table</span><span class="p">,</span> <span class="n">text_cout</span><span class="p">),</span>
        <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_resource_table</span><span class="p">,</span> <span class="n">data_cout</span><span class="p">),</span>
        <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_resource_table</span><span class="p">,</span> <span class="n">ipcdata_cout</span><span class="p">),</span>
        <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_resource_table</span><span class="p">,</span> <span class="n">trace</span><span class="p">),</span>
        <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_resource_table</span><span class="p">,</span> <span class="n">devmem0</span><span class="p">),</span>
        <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_resource_table</span><span class="p">,</span> <span class="n">devmem1</span><span class="p">),</span>
        <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_resource_table</span><span class="p">,</span> <span class="n">devmem2</span><span class="p">),</span>
        <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_resource_table</span><span class="p">,</span> <span class="n">devmem3</span><span class="p">),</span>
        <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_resource_table</span><span class="p">,</span> <span class="n">devmem4</span><span class="p">),</span>
        <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_resource_table</span><span class="p">,</span> <span class="n">devmem5</span><span class="p">),</span>
        <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_resource_table</span><span class="p">,</span> <span class="n">devmem6</span><span class="p">),</span>
        <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_resource_table</span><span class="p">,</span> <span class="n">devmem7</span><span class="p">),</span>
        <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_resource_table</span><span class="p">,</span> <span class="n">devmem8</span><span class="p">),</span>
        <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_resource_table</span><span class="p">,</span> <span class="n">devmem9</span><span class="p">),</span>
        <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_resource_table</span><span class="p">,</span> <span class="n">devmem10</span><span class="p">),</span>
        <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_resource_table</span><span class="p">,</span> <span class="n">devmem11</span><span class="p">),</span>
        <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_resource_table</span><span class="p">,</span> <span class="n">devmem12</span><span class="p">),</span>
        <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_resource_table</span><span class="p">,</span> <span class="n">devmem13</span><span class="p">),</span>
        <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_resource_table</span><span class="p">,</span> <span class="n">devmem14</span><span class="p">),</span>
        <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_resource_table</span><span class="p">,</span> <span class="n">devmem15</span><span class="p">),</span>
    <span class="p">},</span>

    <span class="cm">/* rpmsg vdev entry */</span>
    <span class="p">{</span>
        <span class="n">TYPE_VDEV</span><span class="p">,</span> <span class="n">VIRTIO_ID_RPMSG</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">RPMSG_IPU_C0_FEATURES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
        <span class="cm">/* no config data */</span>
    <span class="p">},</span>
    <span class="cm">/* the two vrings */</span>
    <span class="p">{</span> <span class="n">IPU_MEM_RPMSG_VRING0</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="n">IPU_RPMSG_VQ0_SIZE</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">IPU_MEM_RPMSG_VRING1</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="n">IPU_RPMSG_VQ1_SIZE</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>

    <span class="p">{</span>
        <span class="n">TYPE_CARVEOUT</span><span class="p">,</span>
        <span class="n">IPU_MEM_TEXT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">IPU_MEM_TEXT_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;IPU_MEM_TEXT&quot;</span><span class="p">,</span>
    <span class="p">},</span>

    <span class="p">{</span>
        <span class="n">TYPE_CARVEOUT</span><span class="p">,</span>
        <span class="n">IPU_MEM_DATA</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">IPU_MEM_DATA_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;IPU_MEM_DATA&quot;</span><span class="p">,</span>
    <span class="p">},</span>

    <span class="p">{</span>
        <span class="n">TYPE_CARVEOUT</span><span class="p">,</span>
        <span class="n">IPU_MEM_IPC_DATA</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">IPU_MEM_IPC_DATA_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;IPU_MEM_IPC_DATA&quot;</span><span class="p">,</span>
    <span class="p">},</span>

    <span class="p">{</span>
        <span class="n">TYPE_TRACE</span><span class="p">,</span> <span class="n">TRACEBUFADDR</span><span class="p">,</span> <span class="mh">0x8000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;trace:sysm3&quot;</span><span class="p">,</span>
    <span class="p">},</span>

    <span class="p">{</span>
        <span class="n">TYPE_DEVMEM</span><span class="p">,</span>
        <span class="n">IPU_MEM_IPC_VRING</span><span class="p">,</span> <span class="n">PHYS_MEM_IPC_VRING</span><span class="p">,</span>
        <span class="n">IPU_MEM_IPC_VRING_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;IPU_MEM_IPC_VRING&quot;</span><span class="p">,</span>
    <span class="p">},</span>

    <span class="p">{</span>
        <span class="n">TYPE_DEVMEM</span><span class="p">,</span>
        <span class="n">IPU_MEM_IOBUFS</span><span class="p">,</span> <span class="n">PHYS_MEM_IOBUFS</span><span class="p">,</span>
        <span class="n">IPU_MEM_IOBUFS_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;IPU_MEM_IOBUFS&quot;</span><span class="p">,</span>
    <span class="p">},</span>

    <span class="p">{</span>
        <span class="n">TYPE_DEVMEM</span><span class="p">,</span>
        <span class="n">IPU_TILER_MODE_0_1</span><span class="p">,</span> <span class="n">L3_TILER_MODE_0_1</span><span class="p">,</span>
        <span class="n">SZ_256M</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;IPU_TILER_MODE_0_1&quot;</span><span class="p">,</span>
    <span class="p">},</span>

    <span class="p">{</span>
        <span class="n">TYPE_DEVMEM</span><span class="p">,</span>
        <span class="n">IPU_TILER_MODE_2</span><span class="p">,</span> <span class="n">L3_TILER_MODE_2</span><span class="p">,</span>
        <span class="n">SZ_128M</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;IPU_TILER_MODE_2&quot;</span><span class="p">,</span>
    <span class="p">},</span>

    <span class="p">{</span>
        <span class="n">TYPE_DEVMEM</span><span class="p">,</span>
        <span class="n">IPU_TILER_MODE_3</span><span class="p">,</span> <span class="n">L3_TILER_MODE_3</span><span class="p">,</span>
        <span class="n">SZ_128M</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;IPU_TILER_MODE_3&quot;</span><span class="p">,</span>
    <span class="p">},</span>

    <span class="p">{</span>
        <span class="n">TYPE_DEVMEM</span><span class="p">,</span>
        <span class="n">IPU_PERIPHERAL_L4CFG</span><span class="p">,</span> <span class="n">L4_PERIPHERAL_L4CFG</span><span class="p">,</span>
        <span class="n">SZ_16M</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;IPU_PERIPHERAL_L4CFG&quot;</span><span class="p">,</span>
    <span class="p">},</span>

    <span class="p">{</span>
        <span class="n">TYPE_DEVMEM</span><span class="p">,</span>
        <span class="n">IPU_PERIPHERAL_L4PER1</span><span class="p">,</span> <span class="n">L4_PERIPHERAL_L4PER1</span><span class="p">,</span>
        <span class="n">SZ_2M</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;IPU_PERIPHERAL_L4PER1&quot;</span><span class="p">,</span>
    <span class="p">},</span>

    <span class="p">{</span>
        <span class="n">TYPE_DEVMEM</span><span class="p">,</span>
        <span class="n">IPU_PERIPHERAL_L4PER2</span><span class="p">,</span> <span class="n">L4_PERIPHERAL_L4PER2</span><span class="p">,</span>
        <span class="n">SZ_4M</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;IPU_PERIPHERAL_L4PER2&quot;</span><span class="p">,</span>
    <span class="p">},</span>

    <span class="p">{</span>
        <span class="n">TYPE_DEVMEM</span><span class="p">,</span>
        <span class="n">IPU_PERIPHERAL_L4PER3</span><span class="p">,</span> <span class="n">L4_PERIPHERAL_L4PER3</span><span class="p">,</span>
        <span class="n">SZ_8M</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;IPU_PERIPHERAL_L4PER3&quot;</span><span class="p">,</span>
    <span class="p">},</span>

    <span class="p">{</span>
        <span class="n">TYPE_DEVMEM</span><span class="p">,</span>
        <span class="n">IPU_PERIPHERAL_L4EMU</span><span class="p">,</span> <span class="n">L4_PERIPHERAL_L4EMU</span><span class="p">,</span>
        <span class="n">SZ_16M</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;IPU_PERIPHERAL_L4EMU&quot;</span><span class="p">,</span>
    <span class="p">},</span>

    <span class="p">{</span>
        <span class="n">TYPE_DEVMEM</span><span class="p">,</span>
        <span class="n">IPU_PERIPHERAL_PRUSS</span><span class="p">,</span> <span class="n">L3_PERIPHERAL_PRUSS</span><span class="p">,</span>
        <span class="n">SZ_1M</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;IPU_PERIPHERAL_PRUSS&quot;</span><span class="p">,</span>
    <span class="p">},</span>

    <span class="p">{</span>
        <span class="n">TYPE_DEVMEM</span><span class="p">,</span>
        <span class="n">IPU_IVAHD_CONFIG</span><span class="p">,</span> <span class="n">L3_IVAHD_CONFIG</span><span class="p">,</span>
        <span class="n">SZ_16M</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;IPU_IVAHD_CONFIG&quot;</span><span class="p">,</span>
    <span class="p">},</span>

    <span class="p">{</span>
        <span class="n">TYPE_DEVMEM</span><span class="p">,</span>
        <span class="n">IPU_IVAHD_SL2</span><span class="p">,</span> <span class="n">L3_IVAHD_SL2</span><span class="p">,</span>
        <span class="n">SZ_16M</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;IPU_IVAHD_SL2&quot;</span><span class="p">,</span>
    <span class="p">},</span>

    <span class="p">{</span>
        <span class="n">TYPE_DEVMEM</span><span class="p">,</span>
        <span class="n">IPU_PERIPHERAL_DMM</span><span class="p">,</span> <span class="n">L3_PERIPHERAL_DMM</span><span class="p">,</span>
        <span class="n">SZ_1M</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;IPU_PERIPHERAL_DMM&quot;</span><span class="p">,</span>
    <span class="p">},</span>

    <span class="p">{</span>
        <span class="n">TYPE_DEVMEM</span><span class="p">,</span>
        <span class="n">IPU_OCMC_RAM</span><span class="p">,</span> <span class="n">L3_OCMC_RAM</span><span class="p">,</span>
        <span class="n">SZ_4M</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;IPU_OCMC_RAM&quot;</span><span class="p">,</span>
    <span class="p">},</span>

    <span class="p">{</span>
        <span class="n">TYPE_DEVMEM</span><span class="p">,</span>
        <span class="n">IPU_EMIF_SDRAM</span><span class="p">,</span> <span class="n">L3_EMIF_SDRAM</span><span class="p">,</span>
        <span class="n">SZ_256M</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;IPU_EMIF_SDRAM&quot;</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">};</span>
</pre></div>
</div>
<p>You can find 3 new TYPE_DEVMEM entries added in above resource table.</p>
<ul class="simple">
<li><p>L3_PERIPHERAL_PRUSS</p></li>
<li><p>IPU_OCMC_RAM</p></li>
<li><p>IPU_EMIF_SDRAM</p></li>
</ul>
<p>All ELF section placements (as well as the VRINGS, which aren’t in an
ELF section) are placed in memory allocated from the remoteproc CMA area
and are mapped to the virtual address as specified in the TYPE_CARVEOUT
entries.</p>
<p>The virtual addresses #defined are:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#define IPU_MEM_TEXT            0x0</span>
<span class="cp">#define IPU_MEM_DATA            0x80000000</span>

<span class="cp">#define IPU_MEM_IOBUFS          0x90000000</span>

<span class="cp">#define IPU_MEM_IPC_DATA        0x9F000000</span>
<span class="cp">#define IPU_MEM_IPC_VRING       0x60000000</span>
</pre></div>
</div>
<p>The followings are fixed physical address to facilitate a fixed MMU
table.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#if defined(VAYU_IPU_1)</span>
<span class="cp">#define PHYS_MEM_IPC_VRING      0x9D000000</span>
<span class="cp">#elif defined (VAYU_IPU_2)</span>
<span class="cp">#define PHYS_MEM_IPC_VRING      0x95800000</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>These PHYS_MEM values match exactly the physical address specified in
the remoteproc CMA area in Linux DTS file:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>ipu2_cma_pool: ipu2_cma@95800000 {
        compatible = &quot;shared-dma-pool&quot;;
        reg = &lt;0x95800000 0x3800000&gt;;
        reusable;
        status = &quot;okay&quot;;
};

ipu1_cma_pool: ipu1_cma@9d000000 {
        compatible = &quot;shared-dma-pool&quot;;
        reg = &lt;0x9d000000 0x2000000&gt;;
        reusable;
        status = &quot;okay&quot;;
};
</pre></div>
</div>
<p>The 1st entry in the resource table is:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* rpmsg vdev entry */</span>
<span class="p">{</span>
    <span class="n">TYPE_VDEV</span><span class="p">,</span> <span class="n">VIRTIO_ID_RPMSG</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">RPMSG_IPU_C0_FEATURES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
    <span class="cm">/* no config data */</span>
<span class="p">},</span>
<span class="cm">/* the two vrings */</span>
<span class="p">{</span> <span class="n">IPU_MEM_RPMSG_VRING0</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="n">IPU_RPMSG_VQ0_SIZE</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
<span class="p">{</span> <span class="n">IPU_MEM_RPMSG_VRING1</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="n">IPU_RPMSG_VQ1_SIZE</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
</pre></div>
</div>
<p>This tells remoteproc to allocate the vrings and vring buffers, and the
remoteproc CMA area is used for this.</p>
<p>The 2nd-4th entries are:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="n">TYPE_CARVEOUT</span><span class="p">,</span>
    <span class="n">IPU_MEM_TEXT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">IPU_MEM_TEXT_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;IPU_MEM_TEXT&quot;</span><span class="p">,</span>
<span class="p">},</span>
<span class="p">{</span>
    <span class="n">TYPE_CARVEOUT</span><span class="p">,</span>
    <span class="n">IPU_MEM_DATA</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">IPU_MEM_DATA_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;IPU_MEM_DATA&quot;</span><span class="p">,</span>
<span class="p">},</span>
<span class="p">{</span>
    <span class="n">TYPE_CARVEOUT</span><span class="p">,</span>
    <span class="n">IPU_MEM_IPC_DATA</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">IPU_MEM_IPC_DATA_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;IPU_MEM_IPC_DATA&quot;</span><span class="p">,</span>
<span class="p">},</span>
</pre></div>
</div>
<p>These carveouts tell remoteproc to allocate memory from its CMA area and
map the allocated physical address to the virtual address specified in
the carveout (the 1st field after TYPE_CARVEOUT), in the IPU’s MMU
(“iommu” in Linux kernel parlance). These are for the ELF sections that
are placed (mapped) in those virtual address.</p>
<p>The TYPE_TRACE entry tells remoteproc where the remote executable’s
trace buffer is, using its C symbol.</p>
<p>The TYPE_DEVMEM entries are virtual &lt;-&gt; physical mappings. remoteproc
just creates an IPU MMU mapping for the entry. The 1st TYPE_DEVMEM entry
corresponds to the vrings and creates the IPU MMU mapping needed to
access them from the IPU core:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="n">TYPE_DEVMEM</span><span class="p">,</span>
    <span class="n">IPU_MEM_IPC_VRING</span><span class="p">,</span> <span class="n">PHYS_MEM_IPC_VRING</span><span class="p">,</span>
    <span class="n">IPU_MEM_IPC_VRING_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;IPU_MEM_IPC_VRING&quot;</span><span class="p">,</span>
<span class="p">},</span>
</pre></div>
</div>
</div>
<div class="section" id="new-type-devmem-entry">
<h4>4.4.14.6.4. New TYPE_DEVMEM entry<a class="headerlink" href="#new-type-devmem-entry" title="Permalink to this headline">¶</a></h4>
<p>To add a new TYPE_DEVMEM entry, for example, to access PRU-ICSS from IPU</p>
<ul class="simple">
<li><ol class="arabic simple">
<li><p>specify the physical address of PRU-ICSS and its virutal address.</p></li>
</ol>
</li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#define L3_PERIPHERAL_PRUSS     0x4B200000</span>
<span class="cp">#define IPU_PERIPHERAL_PRUSS    0x6B200000</span>
</pre></div>
</div>
<ul class="simple">
<li><ol class="arabic simple" start="2">
<li><p>increase size of <strong>offset[X]</strong> array in struct my_resource_table.</p></li>
</ol>
</li>
<li><p>3. add new <strong>struct fw_rsc_devmem devmemY</strong> entry in struct
my_resource_table.</p></li>
<li><ol class="arabic simple" start="4">
<li><p>increase <strong>number</strong> of entries in ti_ipc_remoteproc_ResourceTable.</p></li>
</ol>
</li>
<li><p>5. add a <strong>offsetof(struct my_resource_table, devmemY)</strong> in
ti_ipc_remoteproc_ResourceTable.</p></li>
<li><ol class="arabic simple" start="6">
<li><p>add actual entry in ti_ipc_remoteproc_ResourceTable.</p></li>
</ol>
</li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="n">TYPE_DEVMEM</span><span class="p">,</span>
    <span class="n">IPU_PERIPHERAL_PRUSS</span><span class="p">,</span> <span class="n">L3_PERIPHERAL_PRUSS</span><span class="p">,</span>
    <span class="n">SZ_1M</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;IPU_PERIPHERAL_PRUSS&quot;</span><span class="p">,</span>
<span class="p">},</span>
</pre></div>
</div>
<p>Note, when MMU is enabled, even though it is a one-to-one mapping, you
need to have an entry mapped in the MMU for that, e.g. to access
PRU-ICSS from DSP, you must add the following entry in
<strong>rsc_table_vayu_dsp.h</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#define L3_PRU_ICSS             0x4B200000</span>
<span class="cp">#define DSP_PRU_ICSS            0x4B200000</span>
</pre></div>
</div>
<p>The MMU pagetable can be dumped through debugfs - “cat
/sys/kernel/debug/omap_iommu/&lt;iommu_name&gt;/pagetable”</p>
</div>
</div>
<div class="section" id="resource-usage">
<h3>4.4.14.7. Resource Usage<a class="headerlink" href="#resource-usage" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id79">
<h4>4.4.14.7.1. Overview<a class="headerlink" href="#id79" title="Permalink to this headline">¶</a></h4>
<p>The main aim of this page is to capture details about the different
resources used in the IPC drivers.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This page is under construction</p>
</div>
</div>
<div class="section" id="interrupt-map-usage">
<h4>4.4.14.7.2. Interrupt map usage<a class="headerlink" href="#interrupt-map-usage" title="Permalink to this headline">¶</a></h4>
<div class="section" id="am57xx-interrupt-resources">
<h5>4.4.14.7.2.1. AM57xx Interrupt resources<a class="headerlink" href="#am57xx-interrupt-resources" title="Permalink to this headline">¶</a></h5>
<p>The following table captures the interrupt resources used by IPC
associated with different cores for the AM57xx platform. If customer
wants to use any of the interrupt resources, it is better to make sure
any of the resources listed here are not used.</p>
<p><strong>A15 Interrupt Mapping</strong></p>
<table class="docutils align-default">
<colgroup>
<col style="width: 8%" />
<col style="width: 12%" />
<col style="width: 8%" />
<col style="width: 25%" />
<col style="width: 16%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Index</p></th>
<th class="head"><p>Addr</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Source</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>134</p></td>
<td><p>0x4A002B44</p></td>
<td><p>127</p></td>
<td><p>EVE1_IRQ_MBX0_USER3</p></td>
<td><p>EVE1_MAILBOX0</p></td>
<td><p>Eve1 Mailbox 0 user 3 interrupt</p></td>
</tr>
<tr class="row-odd"><td><p>135</p></td>
<td><p>0x4A002B44</p></td>
<td><p>128</p></td>
<td><p>EVE2_IRQ_MBX0_USER3</p></td>
<td><p>EVE2_MAILBOX0</p></td>
<td><p>Eve2 Mailbox 0 user 3 interrupt</p></td>
</tr>
<tr class="row-even"><td><p>136</p></td>
<td><p>0x4A002B48</p></td>
<td><p>129</p></td>
<td><p>MAILBOX5_IRQ_USER2</p></td>
<td><p>MAILBOX5</p></td>
<td><p>Mailbox 5 user 2 interrupt</p></td>
</tr>
<tr class="row-odd"><td><p>137</p></td>
<td><p>0x4A002B48</p></td>
<td><p>130</p></td>
<td><p>EVE3_IRQ_MBX0_USER3</p></td>
<td><p>EVE3_MAILBOX0</p></td>
<td><p>Eve 3 Mailbox 0 user 3 interrupt</p></td>
</tr>
<tr class="row-even"><td><p>138</p></td>
<td><p>0x4A002B4C</p></td>
<td><p>131</p></td>
<td><p>EVE4_IRQ_MBX0_USER3</p></td>
<td><p>EVE4_MAILBOX0</p></td>
<td><p>Eve4 Mailbox 0 user 3 interrupt</p></td>
</tr>
<tr class="row-odd"><td><p>141</p></td>
<td><p>0x4A002B50</p></td>
<td><p>134</p></td>
<td><p>MAILBOX6_IRQ_USER2</p></td>
<td><p>MAILBOX6</p></td>
<td><p>Mailbox 6 user 2 interrupt</p></td>
</tr>
</tbody>
</table>
<p><strong>DSP1 Interrupt Mapping</strong></p>
<table class="docutils align-default">
<colgroup>
<col style="width: 8%" />
<col style="width: 12%" />
<col style="width: 8%" />
<col style="width: 25%" />
<col style="width: 16%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Index</p></th>
<th class="head"><p>Addr</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Source</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>55</p></td>
<td><p>0x4A002974</p></td>
<td><p>24</p></td>
<td><p>EVE1_IRQ_MBX0_USER1</p></td>
<td><p>EVE1_MAILBOX0</p></td>
<td><p>Eve1 Mailbox 0 user 1 interrupt</p></td>
</tr>
<tr class="row-odd"><td><p>56</p></td>
<td><p>0x4A002978</p></td>
<td><p>25</p></td>
<td><p>EVE2_IRQ_MBX0_USER1</p></td>
<td><p>EVE2_MAILBOX0</p></td>
<td><p>Eve2 Mailbox 0 user 1 interrupt</p></td>
</tr>
<tr class="row-even"><td><p>57</p></td>
<td><p>0x4A002978</p></td>
<td><p>26</p></td>
<td><p>MAILBOX5_IRQ_USER0</p></td>
<td><p>MAILBOX5</p></td>
<td><p>Mailbox 5 user 0 interrupt</p></td>
</tr>
<tr class="row-odd"><td><p>58</p></td>
<td><p>0x4A00297C</p></td>
<td><p>27</p></td>
<td><p>EVE3_IRQ_MBX0_USER1</p></td>
<td><p>EVE3_MAILBOX0</p></td>
<td><p>Eve 3 Mailbox 0 user 1 interrupt</p></td>
</tr>
<tr class="row-even"><td><p>59</p></td>
<td><p>0x4A00297C</p></td>
<td><p>28</p></td>
<td><p>EVE4_IRQ_MBX0_USER1</p></td>
<td><p>EVE4_MAILBOX0i</p></td>
<td><p>Eve4 Mailbox 0 user 1 interrupt</p></td>
</tr>
<tr class="row-odd"><td><p>60</p></td>
<td><p>0x4A002980</p></td>
<td><p>29</p></td>
<td><p>MAILBOX7_IRQ_USER0</p></td>
<td><p>MAILBOX7</p></td>
<td><p>Mailbox 7 user 0 interrupt</p></td>
</tr>
<tr class="row-even"><td><p>61</p></td>
<td><p>0x4A002980</p></td>
<td><p>30</p></td>
<td><p>MAILBOX8_IRQ_USER0</p></td>
<td><p>MAILBOX8</p></td>
<td><p>Mailbox 8 user 0 interrupt</p></td>
</tr>
</tbody>
</table>
<p><strong>DSP2 Interrupt Mapping</strong></p>
<table class="docutils align-default">
<colgroup>
<col style="width: 8%" />
<col style="width: 12%" />
<col style="width: 8%" />
<col style="width: 25%" />
<col style="width: 16%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Index</p></th>
<th class="head"><p>Addr</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Source</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>55</p></td>
<td><p>0x4A0029F4</p></td>
<td><p>24</p></td>
<td><p>EVE1_IRQ_MBX1_USER1</p></td>
<td><p>EVE1_MAILBOX1</p></td>
<td><p>Eve1 Mailbox 1 user 1 interrupt</p></td>
</tr>
<tr class="row-odd"><td><p>56</p></td>
<td><p>0x4A0029F8</p></td>
<td><p>25</p></td>
<td><p>EVE2_IRQ_MBX1_USER1</p></td>
<td><p>EVE2_MAILBOX1</p></td>
<td><p>Eve2 Mailbox 1 user 1 interrupt</p></td>
</tr>
<tr class="row-even"><td><p>57</p></td>
<td><p>0x4A0029F8</p></td>
<td><p>26</p></td>
<td><p>MAILBOX6_IRQ_USER0</p></td>
<td><p>MAILBOX6</p></td>
<td><p>Mailbox 6 user 0 interrupt</p></td>
</tr>
<tr class="row-odd"><td><p>58</p></td>
<td><p>0x4A0029FC</p></td>
<td><p>27</p></td>
<td><p>EVE3_IRQ_MLBX1_USER1</p></td>
<td><p>EVE3_MAILBOX1</p></td>
<td><p>Eve 3 Mailbox 1 user 1 interrupt</p></td>
</tr>
<tr class="row-even"><td><p>59</p></td>
<td><p>0x4A0029FC</p></td>
<td><p>28</p></td>
<td><p>EVE4_IRQ_MBX1_USER1</p></td>
<td><p>EVE4_MAILBOX1</p></td>
<td><p>Eve4 Mailbox 1 user 1 interrupt</p></td>
</tr>
<tr class="row-odd"><td><p>60</p></td>
<td><p>0x4A002A00</p></td>
<td><p>29</p></td>
<td><p>MAILBOX7_IRQ_USER1</p></td>
<td><p>MAILBOX7</p></td>
<td><p>Mailbox 7 user 1 interrupt</p></td>
</tr>
<tr class="row-even"><td><p>61</p></td>
<td><p>0x4A002A00</p></td>
<td><p>30</p></td>
<td><p>MAILBOX8_IRQ_USER1</p></td>
<td><p>MAILBOX8</p></td>
<td><p>Mailbox 8 user 1 interrupt</p></td>
</tr>
</tbody>
</table>
<p><strong>IPU1 Interrupt Mapping</strong></p>
<table class="docutils align-default">
<colgroup>
<col style="width: 8%" />
<col style="width: 12%" />
<col style="width: 8%" />
<col style="width: 25%" />
<col style="width: 16%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Index</p></th>
<th class="head"><p>Addr</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Source</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>64</p></td>
<td><p>0x4A002830</p></td>
<td><p>42</p></td>
<td><p>EVE1_IRQ_MBX0_USER2</p></td>
<td><p>EVE1_MAILBOX0</p></td>
<td><p>Eve1 Mailbox 0 user 2 interrupt</p></td>
</tr>
<tr class="row-odd"><td><p>65</p></td>
<td><p>0x4A002834</p></td>
<td><p>43</p></td>
<td><p>EVE2_IRQ_MBX0_USER2</p></td>
<td><p>EVE2_MAILBOX0</p></td>
<td><p>Eve2 Mailbox 0 user 2 interrupt</p></td>
</tr>
<tr class="row-even"><td><p>66</p></td>
<td><p>0x4A002834</p></td>
<td><p>44</p></td>
<td><p>MAILBOX5_IRQ_USER1</p></td>
<td><p>MAILBOX5</p></td>
<td><p>Mailbox 5 user 1 interrupt</p></td>
</tr>
<tr class="row-odd"><td><p>67</p></td>
<td><p>0x4A002838</p></td>
<td><p>45</p></td>
<td><p>EVE3_IRQ_MBX0_USER2</p></td>
<td><p>EVE3_MAILBOX0</p></td>
<td><p>Eve 3 Mailbox 0 user 2 interrupt</p></td>
</tr>
<tr class="row-even"><td><p>68</p></td>
<td><p>0x4A002838</p></td>
<td><p>46</p></td>
<td><p>EVE4_IRQ_MBX0_USER2</p></td>
<td><p>EVE4_MAILBOX0</p></td>
<td><p>Eve4 Mailbox 0 user 2 interrupt</p></td>
</tr>
<tr class="row-odd"><td><p>69</p></td>
<td><p>0x4A00283C</p></td>
<td><p>47</p></td>
<td><p>MAILBOX7_IRQ_USER2</p></td>
<td><p>MAILBOX7</p></td>
<td><p>Mailbox 7 user 2 interrupt</p></td>
</tr>
<tr class="row-even"><td><p>70</p></td>
<td><p>0x4A00283C</p></td>
<td><p>48</p></td>
<td><p>MAILBOX8_IRQ_USER2</p></td>
<td><p>MAILBOX8</p></td>
<td><p>Mailbox 8 user 2 interrupt</p></td>
</tr>
<tr class="row-odd"><td><p>71</p></td>
<td><p>0x4A002840</p></td>
<td><p>49</p></td>
<td><p>EVE1_IRQ_MBX1_USER3</p></td>
<td><p>EVE1_MAILBOX1</p></td>
<td><p>Eve1 Mailbox 1 user 3 interrupt</p></td>
</tr>
<tr class="row-even"><td><p>72</p></td>
<td><p>0x4A002840</p></td>
<td><p>50</p></td>
<td><p>EVE2_IRQ_MBX1_USER3</p></td>
<td><p>EVE2_MAILBOX1</p></td>
<td><p>Eve2 Mailbox 1 user 3 interrupt</p></td>
</tr>
<tr class="row-odd"><td><p>73</p></td>
<td><p>0x4A002844</p></td>
<td><p>51</p></td>
<td><p>MAILBOX5_IRQ_USER3</p></td>
<td><p>MAILBOX5</p></td>
<td><p>Mailbox 5 user 3 interrupt</p></td>
</tr>
<tr class="row-even"><td><p>74</p></td>
<td><p>0x4A002844</p></td>
<td><p>52</p></td>
<td><p>EVE3_IRQ_MBX1_USER3</p></td>
<td><p>EVE3_MAILBOX1</p></td>
<td><p>Eve 3 Mailbox 1 user 3 interrupt</p></td>
</tr>
<tr class="row-odd"><td><p>75</p></td>
<td><p>0x4A002848</p></td>
<td><p>53</p></td>
<td><p>EVE4_IRQ_MBX1_USER3</p></td>
<td><p>EVE4_MAILBOX1</p></td>
<td><p>Eve4 Mailbox 1 user 3 interrupt</p></td>
</tr>
<tr class="row-even"><td><p>76</p></td>
<td><p>0x4A002848</p></td>
<td><p>54</p></td>
<td><p>MAILBOX8_IRQ_USER2</p></td>
<td><p>MAILBOX8</p></td>
<td><p>Mailbox 8 user 2 interrupt</p></td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p><strong>IPU2 Interrupt Mapping</strong></p>
<table class="docutils align-default">
<colgroup>
<col style="width: 8%" />
<col style="width: 12%" />
<col style="width: 8%" />
<col style="width: 25%" />
<col style="width: 16%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Index</p></th>
<th class="head"><p>Addr</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Source</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>64</p></td>
<td><p>0x4A0028A4</p></td>
<td><p>42</p></td>
<td><p>EVE1_IRQ_MBX1_USER2</p></td>
<td><p>EVE1_MAILBOX1</p></td>
<td><p>Eve1 Mailbox 1 user 2 interrupt</p></td>
</tr>
<tr class="row-odd"><td><p>65</p></td>
<td><p>0x4A0028A8</p></td>
<td><p>43</p></td>
<td><p>EVE2_IRQ_MBX1_USER2</p></td>
<td><p>EVE2_MAILBOX1</p></td>
<td><p>Eve2 Mailbox 1 user 2 interrupt</p></td>
</tr>
<tr class="row-even"><td><p>66</p></td>
<td><p>0x4A0028A8</p></td>
<td><p>44</p></td>
<td><p>MAILBOX6_IRQ_USER1</p></td>
<td><p>MAILBOX6</p></td>
<td><p>Mailbox 6 user 1 interrupt</p></td>
</tr>
<tr class="row-odd"><td><p>67</p></td>
<td><p>0x4A0028AC</p></td>
<td><p>45</p></td>
<td><p>EVE3_IRQ_MBX1_USER2</p></td>
<td><p>EVE3_MAILBOX1</p></td>
<td><p>Eve 3 Mailbox 1 user 2 interrupt</p></td>
</tr>
<tr class="row-even"><td><p>68</p></td>
<td><p>0x4A0028AC</p></td>
<td><p>46</p></td>
<td><p>EVE4_IRQ_MBX1_USER2</p></td>
<td><p>EVE4_MAILBOX1</p></td>
<td><p>Eve4 Mailbox 1 user 2 interrupt</p></td>
</tr>
<tr class="row-odd"><td><p>69</p></td>
<td><p>0x4A0028B0</p></td>
<td><p>47</p></td>
<td><p>MAILBOX7_IRQ_USER3</p></td>
<td><p>MAILBOX7</p></td>
<td><p>Mailbox 7 user 3 interrupt</p></td>
</tr>
<tr class="row-even"><td><p>70</p></td>
<td><p>0x4A0028B0</p></td>
<td><p>48</p></td>
<td><p>MAILBOX8_IRQ_USER3</p></td>
<td><p>MAILBOX8</p></td>
<td><p>Mailbox 8 user 3 interrupt</p></td>
</tr>
<tr class="row-odd"><td><p>71</p></td>
<td><p>0x4A0028B4</p></td>
<td><p>49</p></td>
<td><p>EVE1_IRQ_MBX1_USER3</p></td>
<td><p>EVE1_MAILBOX1</p></td>
<td><p>Eve1 Mailbox 1 user 3 interrupt</p></td>
</tr>
<tr class="row-even"><td><p>72</p></td>
<td><p>0x4A0028B4</p></td>
<td><p>50</p></td>
<td><p>EVE2_IRQ_MBX1_USER3</p></td>
<td><p>EVE2_MAILBOX1</p></td>
<td><p>Eve2 Mailbox 1 user 3 interrupt</p></td>
</tr>
<tr class="row-odd"><td><p>73</p></td>
<td><p>0x4A0028B8</p></td>
<td><p>51</p></td>
<td><p>MAILBOX6_IRQ_USER3</p></td>
<td><p>MAILBOX6</p></td>
<td><p>Mailbox 6 user 3 interrupt</p></td>
</tr>
<tr class="row-even"><td><p>74</p></td>
<td><p>0x4A0028B8</p></td>
<td><p>52</p></td>
<td><p>EVE3_IRQ_MBX1_USER3</p></td>
<td><p>EVE3_MAILBOX1</p></td>
<td><p>Eve 3 Mailbox 1 user 3 interrupt</p></td>
</tr>
<tr class="row-odd"><td><p>75</p></td>
<td><p>0x4A0028BC</p></td>
<td><p>53</p></td>
<td><p>EVE4_IRQ_MBX1_USER3</p></td>
<td><p>EVE4_MAILBOX1</p></td>
<td><p>Eve4 Mailbox 1 user 3 interrupt</p></td>
</tr>
<tr class="row-even"><td><p>76</p></td>
<td><p>0x4A0028BC</p></td>
<td><p>54</p></td>
<td><p>MAILBOX8_IRQ_USER3</p></td>
<td><p>MAILBOX8</p></td>
<td><p>Mailbox 8 user 3 interrupt</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="section" id="ipc-faq">
<h2>4.4.15. IPC FAQ<a class="headerlink" href="#ipc-faq" title="Permalink to this headline">¶</a></h2>
<div class="section" id="i-have-a-question-that-s-not-answered-here-what-now">
<h3>4.4.15.1. I have a question that’s not answered here, what now?<a class="headerlink" href="#i-have-a-question-that-s-not-answered-here-what-now" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>There are lots of knowledgeable experts on the <a class="reference external" href="http://e2e.ti.com/">TI E2E Support Forums</a> - posts
welcome!</p></li>
<li><p>Have you tried <a class="reference external" href="http://www.google.com">Google</a>? IPC’s been around
a while, and Google has lots of details about it.</p></li>
</ul>
</div>
<div class="section" id="does-ipc-3-x-support-smp-bios">
<h3>4.4.15.2. Does IPC 3.x support SMP BIOS?<a class="headerlink" href="#does-ipc-3-x-support-smp-bios" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="http://processors.wiki.ti.com/index.php/SMP/BIOS">SMP BIOS is described here</a>. It is currently
only available for dual-core ARM M-class devices, sometimes called
“Benelli” or “Ducati”.</p>
<p>Specifically where IPC 3.x is concerned, SMP BIOS is only applicable to
the following cores/devices:</p>
<ul class="simple">
<li><p>IPU on OMAP54XX</p></li>
<li><p>IPU1 (and IPU2, if present) on DRA7XX (e.g. Vayu)</p></li>
</ul>
<p>The answer to this question depends on whether you are developing an
HLOS-based or BIOS-based system.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>HLOS-Based
(e.g. Linux, QNX, Android on the
Cortex-A)</p></th>
<th class="head"><p>BIOS-Based
(i.e. BIOS on the Cortex-A)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>IPC 3.x <strong>only</strong> supports SMP
BIOS on the IPU(s).
In an HLOS-based system, the
IPU(s) are loaded and managed as
slaves (not peers).</p>
<p>When managing the IPU as a slave,
issues like power management,
loading/resetting, and error
recovery are key features.
Because the 2 cores in a single
IPU can’t easily be seen as truly
independent (e.g. they share a
power domain), treating them as
one slave (running SMP BIOS) is
simpler and more natural.</p>
</td>
<td><p>IPC 3.x supports either SMP BIOS
or non-SMP BIOS. Note that
specifically on DRA7XX’s
<strong>IPU2</strong>, IPC 3.x only supports
SMP BIOS (to reduce the number of
core-to-core permutations and
thus reduce the number of
mailboxes required).
In a BIOS-based environment, the
IPU(s) are treated as peers (not
slaves), and as such some of the
concerns about power management,
loading, error recovery are no
longer an issue.</p>
<p>Note that the MultiProc
configuration used on all cores
reflects your SMP-or-not-SMP
decision. When using non-SMP
BIOS, you must include “IPU1-0”
and “IPU1-1” (rather than “IPU1”
used when running SMP BIOS) in
your MultiProc configuration. See
the ex11_ping example provided
with the IPC product for an
example that supports either
“IPU1” or “IPU1-0 and IPU1-1”.</p>
</td>
</tr>
</tbody>
</table>
<p>Finally, there are a few notable benefits to using SMP BIOS. Many are
described in the <a class="reference external" href="http://processors.wiki.ti.com/index.php/SMP/BIOS">SMP/BIOS</a> article, but two are
highlighted here:</p>
<ul class="simple">
<li><p><strong>Free load balancing</strong> - SMP BIOS schedules tasks to run on the
less-loaded core to balance IPU usage. Without SMP BIOS, when one of
the cores became heavily loaded, users had to repartition the
resources; often this meant moving tasks/code from one core to the
other, which can affect memory maps, build/config scripts, etc.</p></li>
<li><p><strong>Simpler system integration</strong> - there’s one fewer core to manage the
memory map and resource allocation for. Without SMP BIOS, the single
unicache needed to understand AMMU and cache needs for both cores,
and often confusing and error-prone integration issue.</p></li>
</ul>
</div>
<div class="section" id="build-questions">
<h3>4.4.15.3. Build Questions<a class="headerlink" href="#build-questions" title="Permalink to this headline">¶</a></h3>
<div class="section" id="bios-side-build">
<h4>4.4.15.3.1. BIOS-side Build<a class="headerlink" href="#bios-side-build" title="Permalink to this headline">¶</a></h4>
<div class="section" id="how-do-i-change-the-memory-map">
<h5>4.4.15.3.1.1. How do I change the Memory Map?<a class="headerlink" href="#how-do-i-change-the-memory-map" title="Permalink to this headline">¶</a></h5>
<p>Standard techniques for changing the memory map of any BIOS executable
generally apply (e.g. <a class="reference external" href="http://rtsc.eclipse.org/docs-tip/Demo_of_the_RTSC_Platform_Wizard_in_CCSv4">creating your own custom
platform</a>,
<a class="reference external" href="http://rtsc.eclipse.org/docs-tip/Using_Targets_and_Platforms">creating an instance of an existing
platform</a>,
etc). However when building an executable which is loaded by an HLOS,
you also need to ensure the resource table is aligned with the memory
map. The <a class="reference external" href="index_Foundational_Components.html#resource-custom-table">IPC Resource
customTable</a> article describes
how to override the default resource table, which among other things,
includes the memory map.</p>
<p>Obviously be sure to also ensure changes to the memory map don’t collide
with memory usage on other cores.</p>
</div>
<div class="section" id="why-are-the-peripherals-mapped-to-0x6xxx-xxxx-virtual-memory-for-ipu-cortex-m4-test-images">
<h5>4.4.15.3.1.2. Why are the peripherals mapped to 0x6XXX:XXXX virtual memory for IPU (Cortex-M4) test images?<a class="headerlink" href="#why-are-the-peripherals-mapped-to-0x6xxx-xxxx-virtual-memory-for-ipu-cortex-m4-test-images" title="Permalink to this headline">¶</a></h5>
<p>The ARM Cortex-M4 memory map includes a bit-banding region of memory
from 0x4000:0000 to 0x400F:FFFF and 0x4200:0000 to 0x43FF:FFFF. Here is
a Cortex-M4 memory map picture from ARM:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="nl">http</span><span class="p">:</span><span class="c1">//infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0553a/CHDBIJJE.html</span>
</pre></div>
</div>
<p>Many Vayu components running on the IPUs, including IPC, must access
peripherals physically located in this bit-banding region. As a result,
these accesses must be performed indirectly using a virtual memory
address, mapped using the IPU’s AMMU.</p>
<p>Many of the components aligned on mapping this memory using one Large
AMMU page that maps 512M of physical memory beginning at 0x4000:0000 to
virtual memory beginning at 0x6000:0000. Then the components (by
default) access the peripherals using the 0x6XXX:XXXX address space.</p>
<ul class="simple">
<li><p>IPC specifics:</p></li>
</ul>
<p>IPC follows the convention of, by default, accessing memory physically
located at 0x4XXX:XXXX using virtual memory at 0x6XXX:XXXX. You can see
an example of this here - note the mailbox addresses configured here are
in the 06XXX:XXXX range:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="nl">http</span><span class="p">:</span><span class="c1">//git.ti.com/cgit/cgit.cgi/ipc/ipcdev.git/tree/packages/ti/sdo/ipc/family/vayu/InterruptIpu.xs</span>
</pre></div>
</div>
<p>In that same file, you can see that these addresses are configurable,
and the default 0x6XXX:XXXX addresses are only used if other addresses
haven’t already been configured by the system integrator (e.g. in a .cfg
script). Users can override these default mailbox addresses using the
ti.sdo.ipc.family.vayu.InterruptIpu module’s mailboxBaseAddr[] array,
documented here:</p>
<p><a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/ti/sdo/ipc/family/vayu/InterruptIpu.html#metamailbox.Base.Addr">http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/cdoc/ti/sdo/ipc/family/vayu/InterruptIpu.html#metamailbox.Base.Addr</a></p>
</div>
</div>
<div class="section" id="linux-build">
<h4>4.4.15.3.2. Linux Build<a class="headerlink" href="#linux-build" title="Permalink to this headline">¶</a></h4>
<p>For details on the Linux build process see the <a class="reference external" href="index_Foundational_Components.html#linux-install-guide">IPC Install Guide for
Linux</a>.</p>
<div class="section" id="try-cleaning-first">
<h5>4.4.15.3.2.1. Try Cleaning First<a class="headerlink" href="#try-cleaning-first" title="Permalink to this headline">¶</a></h5>
<p>Sometimes the generated autotools makefiles can get confused, especially
if your often switching from one platform to another, between static and
dynamic libraries, etc. And sometimes simply cleaning and retrying can
help.</p>
<p>“make clean” does a ‘light’ cleaning, leaving the autotools-generated
config files so you can just retry ‘make’:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># make clean</span>
<span class="cp">#</span>
<span class="cp"># make</span>
</pre></div>
</div>
<p>“make distclean” does a more aggressive clean, requiring you to re-run
the config before running ‘make’:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># make distclean</span>
<span class="cp">#</span>
<span class="cp"># make -f ipc-linux.mak</span>
<span class="cp"># make</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="qnx-build">
<h4>4.4.15.3.3. QNX Build<a class="headerlink" href="#qnx-build" title="Permalink to this headline">¶</a></h4>
<p>For details on the QNX build process see the <a class="reference external" href="index_Foundational_Components.html#qnx-install-guide">IPC Install Guide for
QNX</a>.</p>
<div class="section" id="id80">
<h5>4.4.15.3.3.1. How do I change the Memory Map?<a class="headerlink" href="#id80" title="Permalink to this headline">¶</a></h5>
<p>For the standpoint of the QNX OS, it owns all external memory by
default. When the ‘ipc’ resource manager is launched and the slave cores
are loaded, the resource table in each slave executable is read and
interpreted. All resource entries of type CARVEOUT are automatically
allocated from QNX-owned memory. Similarly, the first DEVMEM entry
always corresponds to the vring memory used by MessageQ and rpmsg_rpc,
and is also automatically allocated from QNX-owned memory, regardless of
which physical memory address is specified in the resource table entry.
If any other DEVMEM resource entry resides in external memory, QNX would
need to be told to not use that particular range. This is usually done
using the ‘-r’ flag in the startup command in the ‘build’ file of the
QNX IFS (refer to your QNX BSP documentation for more details):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">startup</span><span class="o">-</span><span class="n">dra74x</span><span class="o">-</span><span class="n">vayu</span><span class="o">-</span><span class="n">evm</span> <span class="o">-</span><span class="n">r0xBA300000</span><span class="p">,</span><span class="mh">0x5A00000</span> <span class="o">-</span><span class="n">v</span> <span class="o">-</span><span class="n">n852</span><span class="p">,</span><span class="mi">668</span> <span class="o">-</span><span class="n">W</span> <span class="o">-</span><span class="n">G</span>
</pre></div>
</div>
<p>For example, the above ‘-r’ flag would reserve 0x5A00000 bytes starting
at physical address 0xBA300000 from being used by the QNX OS on the
DRA74x. This technique is often used for the memory range used by
shmemallocator (resource table entry PHYS_MEM_IOBUFS) and/or by
SharedRegions. After modifying the startup flags, rebuild the QNX IFS
and use the new one to boot your board.</p>
</div>
<div class="section" id="how-do-i-configure-the-memory-used-by-shmemallocator">
<h5>4.4.15.3.3.2. How do I configure the memory used by shmemallocator?<a class="headerlink" href="#how-do-i-configure-the-memory-used-by-shmemallocator" title="Permalink to this headline">¶</a></h5>
<p>shmemallocator stands for “Shared Memory Allocator”. It is a utility
that is built alongside the core IPC driver whenever the IPC product is
built. The user can optionally use this utility to allocate contiguous
shared memory for exchanging data between the host and the slave cores.
The memory it allocates from is defined in
&lt;IPC_INSTALL_DIR&gt;qnxsrcipc3x_devsharedmemallocatorresmgrSharedMemoryAllocator.c
thru some #define statements:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#define SH_MEM_BLOCK1_START 0xBA300000</span>
<span class="cp">#define SH_MEM_BLOCK1_SIZE  0x5A00000</span>
</pre></div>
</div>
<p>Typically, even though the code base (as of IPC 3.35) supports up to two
blocks, only block 1 is used when allocating memory using the function
SHM_alloc(), as shown in the IPC examples. When adjusting this block, It
is important that the memory matches a corresponding DEVMEM entry
(PHYS_MEM_IOBUFS) in the resource table so that this memory is mapped to
the slave core’s MMU, and that the memory is reserved in the QNX IFS
startup command as per <a class="reference external" href="index_Foundational_Components.html#how-do-i-change-the-memory-map">“How do I change the Memory
Map?”</a>.</p>
</div>
</div>
<div class="section" id="runtime-troubleshooting">
<h4>4.4.15.3.4. Runtime Troubleshooting<a class="headerlink" href="#runtime-troubleshooting" title="Permalink to this headline">¶</a></h4>
<div class="section" id="linux-spurious-msg-received-with-no-recepient">
<h5>4.4.15.3.4.1. Linux spurious “msg received with no recepient”<a class="headerlink" href="#linux-spurious-msg-received-with-no-recepient" title="Permalink to this headline">¶</a></h5>
<p>When a Linux-loaded slave communicates to the Linux host, it sends a msg
using an rpmsg “channel”. Sometimes there’s no one listening on that
channel, for example if there are no host-side IPC applications running.
When a host-side application calls Ipc_start(), these channels start to
be monitored, but until then, no one’s listening.</p>
<p>When, for example, a slave does a NameServer lookup, this query is often
sent to all cores in the system. If there’s no host-side application
running, there’s no one listening for these msgs, and when the
underlying rpmsg driver detects an arriving msg that no one’s listening
for, it issues a dev_warn() call to report this, drops the message, and
moves along.</p>
<p>These warnings are often benign, and sometimes just reflect chatter
between the various slaves. Perhaps the dev_warn() should be changed to
a dev_dbg().</p>
<p>And yes, that’s a typo - ‘recepient’ is really spelled ‘recipient’.
Submit a patch and get your initials into the Linux kernel.  :)</p>
</div>
<div class="section" id="disabling-auto-recovery">
<h5>4.4.15.3.4.2. Disabling auto-recovery<a class="headerlink" href="#disabling-auto-recovery" title="Permalink to this headline">¶</a></h5>
<p>When the HLOS detects a fault on a slave (e.g. an MMU fault), it reloads
and restarts the slave. Sometimes, especially when debugging slave-side
errors, it’s useful to disable this feature so the state of the crashed
slave isn’t reset and can be examined.</p>
<div class="section" id="id81">
<h6>4.4.15.3.4.2.1. Linux<a class="headerlink" href="#id81" title="Permalink to this headline">¶</a></h6>
<p>You can disable recovery of a given remote processor using remoteproc’s
debugfs features. First, find the slave you want to disable (e.g.
<code class="docutils literal notranslate"><span class="pre">cat</span> <span class="pre">/debug/remoteproc/remoteproc0/name</span></code>) and then echo “disabled” to
the “recovery” file.</p>
<p>For example, if “remoteproc0” is the core you want to disable:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target# echo &quot;disabled&quot; &gt; /debug/remoteproc/remoteproc0/recovery
</pre></div>
</div>
</div>
<div class="section" id="id82">
<h6>4.4.15.3.4.2.2. QNX<a class="headerlink" href="#id82" title="Permalink to this headline">¶</a></h6>
<p>Starting in IPC 3.22, you can simply throw the ‘-d’ option when
launching the ipc resource manager to disable the recovery mechanism.</p>
<p>If you are using IPC 3.21 or older, there are a couple of tricks to
prevent the slaves from being automatically reloaded and restarted:</p>
<ul class="simple">
<li><p>If you have the QNX Momentics IDE installed, you can set a breakpoint
on the entry of ipc_recover() in
&lt;IPC_INSTALL_DIR&gt;/qnx/src/ipc3x_dev/ti/syslink/build/Qnx/resmgr/syslink_main.c.
This function is the callback that is invoked when an MMU fault
occurs to perform the reload. Halting the host at that point would
prevent it from reloading the DSP, and gives you time to inspect the
DSP memory. This is nice because it does not necessitate a rebuild of
IPC.</p></li>
<li><p>If you do not have access to the QNX debugger, you can rebuild IPC
after commenting out the lines in ipc_recover(), and use the modified
IPC resource manager binary for debugging. That would prevent it from
reloading the DSP.</p></li>
</ul>
</div>
</div>
</div>
</div>
<div class="section" id="when-should-ipc-start-be-called">
<h3>4.4.15.4. When should Ipc_start() be called?<a class="headerlink" href="#when-should-ipc-start-be-called" title="Permalink to this headline">¶</a></h3>
<p>On a slave core, Ipc_start() should be called only if there is a need to
initialize the SharedRegion module and/or to perform slave-to-slave IPC
communication. In other words, if communication strictly happens between
host and slave(s), and SharedRegions are not defined, then there is no
need to call Ipc_start() on the slave. In fact, if SR0 (SharedRegion 0)
is not defined on a slave core, do not call Ipc_start() on that slave
core. The call would fail when it tries to look for SR0.</p>
<p>For an example that shows a call to Ipc_start() on the slave cores,
refer to the ex41_forwardmsg example, which showcases both host-to-slave
and slave-to-slave communication paths. Specifically, this line in
Dsp1.cfg and Ipu1.cfg adds a call to Ipc_start() within BIOS_start():</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>BIOS.addUserStartupFunction(&#39;&amp;IpcMgr_callIpcStart&#39;);
</pre></div>
</div>
<p>On the host core, Ipc_start() always needs to be called to initialize
IPC. Given host-side IPC code does not use SharedRegion, the function is
strictly used to perform initialization for other IPC modules.</p>
</div>
<div class="section" id="linux-ipc-start-failures">
<h3>4.4.15.5. Linux Ipc_start() Failures<a class="headerlink" href="#linux-ipc-start-failures" title="Permalink to this headline">¶</a></h3>
<div class="section" id="lad-reports-nameserver-setup-connect-failed-22-invalid-argument">
<h4>4.4.15.5.1. LAD reports NameServer_setup: connect failed: 22, Invalid argument<a class="headerlink" href="#lad-reports-nameserver-setup-connect-failed-22-invalid-argument" title="Permalink to this headline">¶</a></h4>
<p>Internally, LAD tries to connect to sockets created by the rpmsg_proto
kernel driver. This connection can fail for several reasons, so this is
a common “general” error code. Some examples that generate this error
condition are below.</p>
<ul class="simple">
<li><p>Failure to load the slave image. If the a slave executable fails to
load, the sockets to communicate with it are not created. Make sure
the slaves you need to communicate with are already loaded.</p></li>
<li><p>Failure to provide the correct KERNEL_INSTALL_DIR when building the
user-side IPC libraries. Some customers reported this error when
using Linux 3.9+ kernels (where the AF_MAX value in socket.h has
increased). This created a mismatch in what AF_RPMSG was set to in
user libs and the kernel, and the connect call failed. The solution
was to require users set KERNEL_INSTALL_DIR when building the
user-space libraries so IPC can interrogate the kernel version and
set AF_RPMSG appropriately.</p></li>
<li><p>Failure to configure the slave image correctly. Internally, the
slave-side MessageQ transport (TransportRpmsg) broadcasts its
availability to the Linux host. If this broadcast doesn’t occur
(e.g., b/c the slave wasn’t configured with TransportRpmsg), the
socket connection will fail with error 22.</p></li>
<li><p>General slave-to-host interrupt failure. Some devices (e.g. DRA7XX)
have interrupt crossbars that must be configured correctly as part of
system boot (e.g. uboot). If these crossbars aren’t initialized
correctly, the slave-side broadcast that TransportRpmsg is available
won’t be received, the underlying socket connection won’t be
available, and the first sign of failure will be LAD trying to
connect to the socket.</p></li>
</ul>
</div>
<div class="section" id="lad-reports-lad-connect-failed-4">
<h4>4.4.15.5.2. LAD reports LAD_connect() failed: 4<a class="headerlink" href="#lad-reports-lad-connect-failed-4" title="Permalink to this headline">¶</a></h4>
<p>This is a LAD_IOFAILURE = 4. The HOST OS-side application was unable to
communicate with LAD due to an OS_level I/O failure.</p>
<p>This is typically caused by LAD directory permissions.</p>
<ul class="simple">
<li><p>In Linux <strong>/tmp/LAD</strong></p></li>
<li><p>In Android <strong>/data/lad/LAD</strong></p></li>
</ul>
<p>The application was attempting to create or read from LAD’s response
FIFO but was unable to by the application.</p>
<p>LAD must be started as root(su). IPC user applications communicating
with LAD, can be executed in <strong>user</strong> mode but need to ensure LAD is
stared with the correct permission.</p>
<ul class="simple">
<li><p><strong>%</strong> lad_dra7xx -l log.txt -p 777</p></li>
</ul>
<p>You can also run both LAD and user application as root(su), thus not
requiring permission to be properly set when starting LAD.</p>
</div>
<div class="section" id="lad-reports-gatemp-ti-dgate-not-found">
<h4>4.4.15.5.3. LAD reports _GateMP_TI_dGate not found<a class="headerlink" href="#lad-reports-gatemp-ti-dgate-not-found" title="Permalink to this headline">¶</a></h4>
<p>When the -g option is thrown, the LAD log may show an error about not
finding the symbol _GateMP_TI_dGate:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mf">22.583839</span><span class="p">]</span> <span class="nl">NameServer_getRemote</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="nl">GateMP</span><span class="p">:</span><span class="n">_GateMP_TI_dGate</span> <span class="n">not</span> <span class="n">found</span><span class="p">.</span>
<span class="p">[</span><span class="mf">22.583852</span><span class="p">]</span> <span class="nl">GateMP_attach</span><span class="p">:</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">open</span> <span class="k">default</span> <span class="n">gate</span> <span class="n">on</span> <span class="n">procId</span> <span class="mi">4</span>
<span class="p">[</span><span class="mf">22.583862</span><span class="p">]</span>     <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span>
<span class="p">[</span><span class="mf">22.583871</span><span class="p">]</span> <span class="n">DONE</span>
</pre></div>
</div>
<p>This is because LAD is looking for the default GateMP instance, and did
not find it. On the DRA7xx, verify</p>
<ol class="arabic simple">
<li><p>SharedRegion 0 is defined on DSP1. GateMP implementation on the host
requires use of SharedRegion</p></li>
<li><p>DSP1 is the owner of SharedRegion 0</p></li>
<li><p>Ipc_start() is called on DSP1. This ensures the default GateMP
instance is created.</p></li>
</ol>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="hlos-loading-failures">
<h3>4.4.15.6. HLOS loading failures<a class="headerlink" href="#hlos-loading-failures" title="Permalink to this headline">¶</a></h3>
<div class="section" id="bios-side-virtqueue-assertions">
<h4>4.4.15.6.1. BIOS-side VirtQueue assertions<a class="headerlink" href="#bios-side-virtqueue-assertions" title="Permalink to this headline">¶</a></h4>
<p>The slave loads ok, but communication fails, and in the slave trace
output you find the following assert (line number and timestamp may
vary):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">[</span>      <span class="mf">0.000</span><span class="p">]</span> <span class="p">[</span><span class="n">t</span><span class="o">=</span><span class="mh">0x00d090ce</span><span class="p">]</span> <span class="n">ti</span><span class="p">.</span><span class="n">ipc</span><span class="p">.</span><span class="n">family</span><span class="p">.</span><span class="n">vayu</span><span class="p">.</span><span class="nl">VirtQueue</span><span class="p">:</span> <span class="nl">ERROR</span><span class="p">:</span> <span class="s">&quot;VirtQueue.c&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">296</span><span class="o">:</span>
<span class="p">[</span>      <span class="mf">0.000</span><span class="p">]</span> <span class="n">ti</span><span class="p">.</span><span class="n">ipc</span><span class="p">.</span><span class="n">family</span><span class="p">.</span><span class="n">vayu</span><span class="p">.</span><span class="nl">VirtQueue</span><span class="p">:</span> <span class="s">&quot;VirtQueue.c&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">296</span><span class="o">:</span>
<span class="p">[</span>      <span class="mf">0.000</span><span class="p">]</span> <span class="n">xdc</span><span class="p">.</span><span class="n">runtime</span><span class="p">.</span><span class="n">Error</span><span class="p">.</span><span class="nl">raise</span><span class="p">:</span> <span class="n">terminating</span> <span class="n">execution</span>
</pre></div>
</div>
<p>This error often indicates a mismatch in VRING addresses between the
HLOS side and the slave. Often this is because a <a class="reference external" href="index_Foundational_Components.html#resource-custom-table">custom resource
table</a> was provided and the
VRING addresses specified don’t match the HLOS-side addresses.</p>
</div>
<div class="section" id="qnx-ipc-driver-takes-a-long-time-to-load-the-slave-executable-s-when-g-is-thrown">
<h4>4.4.15.6.2. QNX IPC driver takes a long time to load the slave executable(s) when ‘-g’ is thrown<a class="headerlink" href="#qnx-ipc-driver-takes-a-long-time-to-load-the-slave-executable-s-when-g-is-thrown" title="Permalink to this headline">¶</a></h4>
<p>The ‘-g’ option to the IPC driver is used to enable optional support for
GateMP on the host processor. During the setup of GateMP module, it
polls the slave processors for the default gate instance, which is
created by the owner of SharedRegion 0. If none of the cores loaded has
created the default gate, the driver will continue polling and
eventually timeout after 2 seconds, which means the loading procedure
may be delayed by 2 seconds as a consequence. To better suit a given
application, one can adjust the polling interval and the timeout
duration in the file
&lt;IPC_INSTALL_DIR&gt;/qnx/src/ipc3x_dev/ti/syslink/ipc/hlos/knl/GateMP_daemon.c
(this code excerpt may look slightly different depending on the version
of IPC you are looking at, but the idea is the same):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Timeout duration is SETUP_TIMEOUT * polling interval</span>
<span class="cp">#define SETUP_TIMEOUT         2</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Int</span> <span class="nf">GateMP_setup</span><span class="p">(</span><span class="n">Int32</span> <span class="o">*</span> <span class="n">sr0ProcId</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
   <span class="n">UInt</span>              <span class="n">timeout</span> <span class="o">=</span> <span class="n">SETUP_TIMEOUT</span><span class="p">;</span>
<span class="p">...</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">GateMP_S_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
       <span class="cm">/* The default gate creator is the owner of SR0 */</span>
       <span class="k">while</span> <span class="p">(((</span><span class="n">status</span> <span class="o">=</span> <span class="n">GateMP_openDefaultGate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">GateMP_module</span><span class="o">-&gt;</span><span class="n">defaultGate</span><span class="p">,</span>
           <span class="o">&amp;</span><span class="n">procId</span><span class="p">))</span> <span class="o">==</span> <span class="n">GateMP_E_NOTFOUND</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
           <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>  <span class="c1">// polling interval</span>
           <span class="n">timeout</span><span class="o">--</span><span class="p">;</span>
       <span class="p">}</span>
<span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the case where the owner of SharedRegion 0 is not being loaded by the
IPC driver, reducing the timeout duration (SETUP_TIMEOUT) may be useful
to reduce the delay that results when the driver cannot find the default
gate.</p>
<p>In the case where the owner of SharedRegion 0 is indeed loaded by the
IPC driver, using usleep() instead of sleep() to reduce the polling
interval can be beneficial in cases where the initial poll happens
before the slave core (owner of SR0) has even got to the point in its
initialization to create the default gate. A faster polling rate would
ensure that a second or a third poll is performed more quickly thereby
giving a chance for the driver to move on. On the other hand, reducing
the polling interval too much may cause the driver to swamp the slave
cores with gate lookup requests, counterproductively slowing down the
loading process. As a rule of thumb, it is recommended to keep the
polling interval above 1 ms in modern platforms at the time of writing.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="disabling-runtime-auto-suspend">
<h3>4.4.15.7. Disabling runtime auto-suspend<a class="headerlink" href="#disabling-runtime-auto-suspend" title="Permalink to this headline">¶</a></h3>
<p>When the HLOS detects that there has been no communication with the
slave for a defined amount of time and the slave is idled and in standby
state, then it can initiate suspend of the slave. Sometimes, the slave
may be performing some tasks that don’t require communication with the
HLOS and does not wish to enter suspend. Or, it may be useful to
temporarily disable auto-suspend while debugging some errors.</p>
<div class="section" id="id83">
<h4>4.4.15.7.1. Linux<a class="headerlink" href="#id83" title="Permalink to this headline">¶</a></h4>
<p>The runtime suspend feature can be enabled or disabled by writing ‘auto’
or ‘on’ to the device’s ‘control’ power field. The default is enabled.
First, find the slave you want to disable (e.g.
<code class="docutils literal notranslate"><span class="pre">cat</span> <span class="pre">/debug/remoteproc/remoteproc0/name</span></code>) and then echo “on” to the
device’s “control” power field.</p>
<p>For example, if “remoteproc0” is the core you want to disable:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>target# echo &quot;on&quot; &gt; /sys/bus/platform/devices/58820000.ipu/power/control
</pre></div>
</div>
</div>
<div class="section" id="sys-bios">
<h4>4.4.15.7.2. SYS/BIOS<a class="headerlink" href="#sys-bios" title="Permalink to this headline">¶</a></h4>
<p>Alternatively, the slave can choose to deny the runtime suspend request,
preventing suspend. To prevent the slave from suspending, add the
<a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_ipc_power_8h.html#aef7ede8453ad5a6a52623188c412f2fc">IpcPower_hibernateLock()</a>
call to the slave software. When you wish to allow suspend again, call
<a class="reference external" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/_ipc_power_8h.html#a2aa7348faba4bccb24da503fed3274f9">IpcPower_hibernateUnlock()</a>.
As long as the lock is held, the slave will deny all suspend requests
from the HLOS.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">IpcPower_hibernateLock</span><span class="p">();</span>
<span class="p">...</span>
<span class="c1">// Perform tasks</span>
<span class="p">...</span>
<span class="n">IpcPower_hibernateUnlock</span><span class="p">();</span>
</pre></div>
</div>
<p>In this case, it is not necessary to also disable auto-suspend from the
HLOS.</p>
</div>
<div class="section" id="id84">
<h4>4.4.15.7.3. QNX<a class="headerlink" href="#id84" title="Permalink to this headline">¶</a></h4>
<p>Runtime auto-suspend is not supported in QNX.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="faq-for-keystone-devices">
<h3>4.4.15.8. FAQ For Keystone Devices<a class="headerlink" href="#faq-for-keystone-devices" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id85">
<h4>4.4.15.8.1. Overview<a class="headerlink" href="#id85" title="Permalink to this headline">¶</a></h4>
<p>This wiki article is a collection of frequently asked questions (FAQ) on
IPC on Keystone family of devices , along with some useful collateral
and software reference links.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="guide-on-building-and-running-the-ipc-examples-of-processor-sdk">
<h4>4.4.15.8.2. Guide on building and running the IPC examples of Processor SDK<a class="headerlink" href="#guide-on-building-and-running-the-ipc-examples-of-processor-sdk" title="Permalink to this headline">¶</a></h4>
<div class="line-block">
<div class="line">This guide will give step by step instruction on how to bring up the
target EVMs and how to run the run the IPC examples of processor SDK
on target EVM.</div>
</div>
<div class="line-block">
<div class="line">Download the guide from <a class="reference download internal" download="" href="../_downloads/ef4bce06bd0fba65336c949b588db9d3/Guide_Keystone_II_IPC_examples_.zip"><code class="xref download docutils literal notranslate"><span class="pre">Keystone</span> <span class="pre">II</span> <span class="pre">IPC</span> <span class="pre">Examples</span></code></a></div>
</div>
<div class="line-block">
<div class="line">This guide will have steps on</div>
<div class="line">1. Flashing the u-boot and boot u-boot.</div>
<div class="line">2. Flashing the UBIFS image ( Linux and root filesystem ) into NAND
and boot Linux.</div>
<div class="line">3. Building the IPC package.</div>
<div class="line">4. Building and running the IPC examples ( ex02_MessageQ,
ex44_compute, ex45_host and ex46_graph ) on target EVM.</div>
<div class="line">5. Real-time debugging on the DSP side programs using CCS.</div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="keystone-ipc-frequently-asked-questions-faq">
<h4>4.4.15.8.3. Keystone IPC Frequently Asked Questions (FAQ)<a class="headerlink" href="#keystone-ipc-frequently-asked-questions-faq" title="Permalink to this headline">¶</a></h4>
<p class="rubric" id="q-where-do-i-look-for-the-list-of-ipc-api-reference-document">Q: Where do I look for the list of IPC API reference
document?</p>
<p><strong>Ans:</strong></p>
<p>Please visit :
<a class="reference external" href="http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/index.html">http://downloads.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/latest/docs/doxygen/html/index.html</a></p>
<p>The IPC product contains the following APIs:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>•GateMP (BIOS, Linux, QNX)
•HeapBufMP (BIOS)
•HeapMemMP (BIOS)
•HeapMultiBufMP (BIOS)
•Ipc (BIOS, Linux, QNX)
•ListMP (BIOS)
•MessageQ (BIOS, Linux, QNX)
•MultiProc (BIOS, Linux, QNX)
•NameServer (BIOS, Linux, QNX)
•Notify (BIOS)
•SharedRegion (BIOS)
•IpcPower (BIOS)
</pre></div>
</div>
<p>Some environments also provide a “Multimedia RPC” interface. Currently
this is limited to OMAP5 and DRA7XX devices running an HLOS.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>•MmRpc (Linux, QNX)
•MmServiceMgr (BIOS)
</pre></div>
</div>
<p class="rubric" id="q-how-to-re-build-the-ipc-package-and-its-libraries">Q: How to re-build the IPC package and its libraries?</p>
<p><strong>Ans:</strong></p>
<p>Actually, the user guide which comes along with the IPC package ( under
docs folder) is sufficient to build the IPC package. However, we have
extracted below steps from user guide. For building IPC package, you can
use either Cygwin/Command-line utility in windows machine or Linux
machine. This cannot be built through CCS.</p>
<div class="line-block">
<div class="line">1. Install the mcsdk_bios_3_xx_xx_xx which will install the IPC
package version, ipc_3_xx_xx_xx</div>
<div class="line">2. Go to the directory where the IPC package is installed.</div>
<div class="line">3. Open the products.mak file and make sure the following parameters
are set appropriately.</div>
</div>
<div class="line-block">
<div class="line">For example:- ( For ipc-linux build )</div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">PLATFORM</span> <span class="o">=</span> <span class="n">TCI6638</span>
<span class="n">DESTDIR</span> <span class="o">=</span> <span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">ipc_3_xx_xx_xx</span><span class="o">/</span><span class="n">ipc_3_xx_xx_xx_lib</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">XDC_INSTALL_DIR</span> <span class="o">=</span> <span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">xdctools_3_xx_xx_xx</span>
<span class="n">BIOS_INSTALL_DIR</span> <span class="o">=</span> <span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">bios_6_xx_xx_xx</span>
<span class="n">ti</span><span class="p">.</span><span class="n">targets</span><span class="p">.</span><span class="n">elf</span><span class="p">.</span><span class="n">C66</span> <span class="o">=</span> <span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">ccsv5</span><span class="o">/</span><span class="n">tools</span><span class="o">/</span><span class="n">compiler</span><span class="o">/</span><span class="n">C6000_7</span><span class="mf">.4.5</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">4. $cd /opt/ti/ ipc_3_xx_xx_xx</div>
<div class="line">5. $make distclean</div>
<div class="line">6. $make –f ipc-linux.mak config</div>
<div class="line">7. $make</div>
<div class="line">8. $make install</div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p class="rubric" id="q-is-there-any-simple-example-to-demonstrate-ipc-methods-like-message-q-or-notify-for-keystone-ii">Q: Is there any simple example to demonstrate IPC methods
like message Q or notify for Keystone-II ?</p>
<p><strong>Ans:</strong></p>
<div class="line-block">
<div class="line">Please look at the ex44_compute.zip
in :~/ti/ipc_3_3x_xx_xx/examples/TCI6638_linux_elf</div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>~/ti/ipc_3_3x_xx_xx/examples$ ls
C6472_bios_elf C6A8149_bios_elf DRA7XX_android_elf DRA7XX_linux_elf makefile TCI6638_linux_elf
TI814X_bios_elf C6678_bios_elf dosrc.bat DRA7XX_bios_elf DRA7XX_qnx_elf OMAPL138_linux_elf TDA3XX_bios_elf
</pre></div>
</div>
<p>Please refer the readme.txt to run and build the example according to
the target used. For K2, use the cluster ID as 0 instead of 18.</p>
<ol class="arabic simple">
<li><p>perl patchExec.pl 0 compute_dspN.xe66 compute_dspN_patched.xe66</p></li>
<li><p>lad_tci6638 -r 8 -n 9 -b 0 -l log.txt</p></li>
</ol>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p class="rubric" id="q-for-keystone-ii-is-there-any-ccs-based-examples-to-demonstrate-a-simple-communication-between-arm-dsp">Q: For Keystone II, is there any CCS based examples to
demonstrate a simple communication between ARM-DSP?</p>
<p><strong>Ans:</strong></p>
<p>No. We have only Image Processing Demo.</p>
<p>In MCSDK 3.x, the ARM core only runs Linux kernel and User Space
applications. There isn’t any Linux application example using CCS and if
any, it will be using Linux commands.</p>
<p class="rubric" id="q-in-ipc-packages-there-are-lot-of-test-examplesample-c-code-given-in-the-path-ipc-3-3x-xx-xxpackagestiipctests-but-there-is-only-command-line-option-to-build-the-whole-ipc-package-no-option-available-to-build-the-test-examples-individually-this-is-time-consuming-to-build-the-whole-ipc-package-customers-were-asking-for-ccs-based-environment-to-build-and-test-as-individual-example-for-both-dsp-and-arm-side">Q: In IPC packages, there are lot of test example(sample.c)
code given in the path: “~ipc_3_3x_xx_xxpackagestiipctests”. But
there is only command line option to build the whole IPC package. No
option available to build the test examples individually. This is
time consuming to build the whole IPC package. Customers were asking
for CCS based environment to build and test as individual example for
both DSP and ARM side.</p>
<p><strong>Ans:</strong></p>
<p>The IPC package has been developed to work on multiple platforms like
Linux, Android, QNX and TI-RTOS(SYS/BIOS) so the command line build is
selected which is common across all these platforms and we do not have
CCS based projects for these examples.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p class="rubric" id="q-for-keystone-ii-devices-where-do-i-find-the-source-code-of-the-image-processing-demo-and-how-to-i-re-build-them-using-arm-core-as-a-master-dsp-cores-as-slaves">Q: For keystone-II devices, where do I find the source code
of the image processing demo and how to I re-build them? Using ARM
core as a master, DSP cores as slaves.</p>
<p><strong>Ans:</strong></p>
<p>Tested version : “mcsdk_bios_3_00_03_15”. The Image processing demo was
tested multiple times with this version and it works fine.</p>
<p>The image processing demo source code can be found in below path.</p>
<p><strong>PATH:</strong> C:timcsdk_bios_3_0x_0x_0xdemosimage_processingipc (master,
slave and common directories)</p>
<p><strong>Building Slave Code:</strong>
The project can be imported into CCS and can be rebuilt.</p>
<p><em>For K2E:</em>
“~mcsdk_bios_3_0x_0x_0xdemosimage_processingipcevm66ak2eslave”</p>
<p><em>For K2K:</em>
“~mcsdk_bios_3_0x_0x_0xdemosimage_processingipcevmtci6638k2kslave”</p>
<p><em>For K2L:</em>
“~mcsdk_bios_3_0x_0x_0xdemosimage_processingipcevmtci6630k2lslave”</p>
<p><strong>Building Master Code:</strong></p>
<p>This can be built in the linux environment using the makefile provided
at</p>
<p>(~mcsdk_bios_3_0x_0x_0xdemosimage_processingipcevm66ak2xmastermake
) which in turn uses the makefile located at
~mcsdk_bios_3_0x_0x_0xdemosimage_processingipcmastersrc</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p class="rubric" id="qhow-to-import-the-slave-code-of-image-processing-demo-and-how-do-i-build-it">Q: How to import the slave code of Image processing demo and
how do I build it?</p>
<p><strong>Ans:</strong></p>
<p>Refer the screenshot below in which the correct path should be provided
to pick up the project and its sources. Note that the option for “Copy
projects into work space” should be unchecked.</p>
<img alt="../_images/ImportPjt.jpg" src="../_images/ImportPjt.jpg" />
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>In the project explorer screen, check whether you are able to see the
folders, slave –&gt; src –&gt; *.c files…. Right click on the project and
give build.</p>
<img alt="../_images/Sourcefilepjt.jpg" src="../_images/Sourcefilepjt.jpg" />
<p class="rubric" id="q-after-building-the-slave-code-of-the-image-processing-demo-using-ccs-where-it-needs-to-be-replaced-in-the-linux-file-system">Q: After building the slave code of the Image processing
demo using CCS, where it needs to be replaced in the linux file
system?</p>
<p><strong>Ans:</strong></p>
<p>Take the binary file, image_processing_evmtci66xxk2x_slave.out and
replace it in the path target Linux filesystem,
“/usr/share/matrix-gui-2.0/apps/demo_imageproc/bin/”</p>
<p class="rubric" id="q-while-building-the-armmaster-side-code-of-image-processing-demo-i-see-a-compilation-error-message-about-std-h-as-below-when-i-make-it-with-or-without-build-localtrue">Q:  While building the ARM(master) side code of Image
processing demo, I see a compilation error message about Std.h as
below when I make it with or without BUILD_LOCAL=true.</p>
<div class="line-block">
<div class="line"><em>Error:</em></div>
<div class="line"><strong>*user&#64;ubuntu:~/ti/mcsdk_bios_3_0x_0x_0x/demos/image_processing/ipc/evm66ak2x/master$*</strong>
make</div>
</div>
<div class="line-block">
<div class="line"><em>make[1]: Entering directory
`/home/user/ti/mcsdk_bios_3_0x_0x_0x/demos/image_processing/ipc/master/src’
mcip_mem_mgmt.c:53:24: fatal error: ti/ipc/Std.h: No such file or
directory #include &lt;ti/ipc/Std.h&gt; Compilation terminated.</em></div>
</div>
<div class="line-block">
<div class="line"><strong>Ans:</strong></div>
<div class="line">There is an error in the Makefile. Make file needs to be updated for
including the appropriate search path for “Std.h”. You will find it at
“../ti/ipc_3_3x_0x_0x/linux/include</div>
</div>
<p>Update the Makefile located at
“mcsdk_bios_3_0x_0x_0xdemosimage_processingipcmastersrcmakefile”
as below,</p>
<div class="line-block">
<div class="line"><em>For example:</em></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>IPC_INSTALL_DIR := /opt/ti/ipc_3_xx_0x_0x
CFLAGS  := -Wall -I$(COMMON_INC) -I$(MASTER_INC) -I$(IPC_INSTALL_DIR)/linux/include -I$(IPC_INSTALL_DIR)/packages -D_GNU_SOURCE
</pre></div>
</div>
<p class="rubric" id="q-while-building-the-armmaster-side-code-of-image-processing-demo-i-see-a-linker-error-message-like-below">Q: While building the ARM(master) side code of Image
processing demo, I see a linker error message like below.</p>
<div class="line-block">
<div class="line"><em>Error:</em></div>
<div class="line"><em>/usr/bin/ld: skipping incompatible
/opt/ti/ipc_3_35_01_07/examples/TCI6638_linux_elf
/ex44_compute_bkp/lib//libtitransportrpmsg.a when searching for
-ltitransportrpmsg
/usr/bin/ld: cannot find –ltitransportrpmsg</em></div>
<div class="line">usr/bin/ld: cannot find -ltiipcutils</div>
<div class="line">collect2: error: ld returned 1 exit status</div>
<div class="line">make: *** [../../master/image_processing_master.out] Error 1</div>
<div class="line"><a class="reference external" href="mailto:root&#37;&#52;&#48;e2e">root<span>&#64;</span>e2e</a>:/opt/ti/mcsdk_bios_3_0x_xx_xx/demos/image_processing/ipc/master/src#*
*</div>
</div>
<div class="line-block">
<div class="line"><strong>Ans:</strong></div>
<div class="line">For these errors, please make sure you already built the Whole IPC
package and installed the libraries such as transportrpmsg in a
destination directory. This destination directory should be given in
the makefile to find those libraries.</div>
</div>
<div class="line-block">
<div class="line">For example, in the makefile located at
mcsdk_bios_3_0x_xx_xxdemosimage_processingipcmastersrcmakefile</div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="nl">IPC_INSTALL_DIR</span> <span class="p">:</span><span class="o">=</span> <span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">ipc_3_3x_xx_xx</span>

<span class="cp">#The location where the libraries are installed after building the IPC package</span>
<span class="nl">SIPC_LINUX_DIR</span> <span class="p">:</span><span class="o">=</span> <span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">ipc_3_3x_xx_xx</span><span class="o">/</span><span class="n">IPC_Linux_libraries</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>CROSS_COMPILE ?= arm-linux-gnueabihf-
CC            := $(CROSS_COMPILE)gcc
CFLAGS        := -Wall -I$(COMMON_INC) -I$(MASTER_INC) -I$(IPC_INSTALL_DIR)/linux/include -I$(IPC_INSTALL_DIR)/packages -D_GNU_SOURCE
LFLAGS        := -lpthread -L$(SIPC_LINUX_DIR)/ -ltitransportrpmsg -L$(SIPC_LINUX_DIR)/ -ltiipc -L$(SIPC_LINUX_DIR)/ -ltiipcutils
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p class="rubric" id="q-the-image-processing-demo-does-not-work-on-the-version-of-mcsdk-v3-0x-xx-x-on-both-the-k2h-and-k2e-evms-the-earlier-version-of-mcsdk-works-on-both-the-evms-will-it-be-fixed-on-next-version">Q: The Image processing demo does not work on the version of
MCSDK, V3.0x.xx.x on both the K2H and K2E EVMs. The earlier version
of MCSDK works on both the EVMs. Will it be fixed on next version?</p>
<p><strong>Ans:</strong></p>
<div class="line-block">
<div class="line">Make sure the u-boot environments is set as below to work on MCSDK
3.x.</div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>u-boot# env default –f –a
u-boot# setenv mem_reserve 1536M
u-boot# saveenv
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p class="rubric" id="q-how-to-build-and-run-the-qmssipcbenchmark-on-c6678-evm">Q: How to build and run the qmssIpcBenchmark on C6678 EVM?</p>
<p><strong>Ans:</strong></p>
<p><strong>Hardware set up:</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Set</span> <span class="n">the</span> <span class="n">boot</span> <span class="n">mode</span> <span class="n">dip</span> <span class="k">switch</span> <span class="n">to</span> <span class="n">no</span> <span class="n">boot</span><span class="o">/</span><span class="n">EMIF16</span> <span class="n">mode</span><span class="p">,</span> <span class="n">Connect</span> <span class="n">power</span> <span class="n">and</span> <span class="n">emulator</span> <span class="n">to</span> <span class="n">C6678</span> <span class="n">EVM</span><span class="p">.</span>
</pre></div>
</div>
<p><strong>Software setup:</strong>
1. After power ON the EVM, create and launch the target configuration
file(.ccxml) for CCS debugging.</p>
<ol class="arabic simple" start="2">
<li><p>Group Core 0 and Core 1 in CCS.</p></li>
<li><p>Connect to both cores via the group.</p></li>
</ol>
<p>4. Load the evmc66xxl.gel to initialize the DDR. The GEL can be found in
the “CCS install
dir”ccsv5ccs_base_x.x.x.xxxxxemulationboardsevmc66xxlgel
directory. Once loaded execute the default setup script on each core. In
the CCS menu go to Scripts-&gt;EVMC6678L Init
Functions-&gt;Global_Default_Setup.</p>
<p>5. Highlighting the Group in the CCS Debug window, load
transportipcexamplesqmssIpcBenchmarkDebugqmssIpcBenchmark_c66xx.out
on each core</p>
<p>6. Highlighting the Group in CCS Debug window, run the program in CCS on
both cores simultaneously, qmssIpcBenchmark_c66xx will send messageQ
messages between the cores via the QMSS transport. The messages will be
used to measure the transport’s performance. The test will be complete
after the throughput (msg/s) has been calculated.</p>
<img alt="../_images/Qmss_IPC.png" src="../_images/Qmss_IPC.png" />
<p class="rubric" id="q-how-can-i-build-the-qmssipcbenchmark-of-pdk-c6678-1-1-2-x-pdk-c6678-1-1-2-x-with-release-build-configuration">Q: How can I build the qmssIpcbenchmark of pdk_C6678_1_1_2_x
pdk_C6678_1_1_2_x with release build configuration ?</p>
<p><strong>Ans:</strong></p>
<div class="line-block">
<div class="line">Actually the option, “-mo -o3 -q -k -eo.o” works for building the
IPC-QMSS transport library in release mode and the option “-mo -g -q -k -eo.o”
works for building the IPC-QMSS transport library in debug mode.</div>
<div class="line">But the common.bld script of IPC doesnot create a “release” folder. By
default it always creates the “debug” folder and dumps all the
binaries.</div>
<div class="line">By tweaking the common.bld, release folder can be made and hence the
the IPC - qmssIpcBenchmark project can be built in release mode.</div>
<div class="line"><strong>How to change the Common.bld:</strong></div>
<div class="line">1. Go to C:tiipc_3_00_xx_xxpackagestisdoipcbuildCommon.bld (
Note: Go to the IPC version you use for building the transport
library. Here, it refers to IPC version : 3.00.4.29)</div>
<div class="line">2. Modify</div>
<div class="line">Line No:88 profiles[0] = “release”;</div>
<div class="line">Line No: 99 var libPath = “lib/ipc/release/”;</div>
<div class="line">3. Build with option : -mo -o3 -q -k -eo.o in config.bld of transport
library located at
“..tipdk_C6678_1_1_2_xpackagestitransportipcqmsstransports”</div>
<div class="line">4. Now build qmssIpcBenchmark project.</div>
<div class="line">Screenshot of the successful release build of qmssIpcBenchmark
project.</div>
</div>
<img alt="../_images/QMSSIPC_project1.png" src="../_images/QMSSIPC_project1.png" />
<div class="line-block">
<div class="line"><br /></div>
</div>
<p class="rubric" id="q-how-to-re-build-the-ipc-qmss-transport-library-and-generate-ti-transport-ipc-qmss-transports-ae66">Q: How to re-build the IPC - QMSS transport library and
generate “ti.transport.ipc.qmss.transports.ae66” ?</p>
<p><strong>Ans:</strong></p>
<p>After installing PDK, go to path
“~tipdk_C6678_1_1_2_xpackagestitransportipcqmsstransports”</p>
<p>1. [Optional - Required for debug single stepping] Modify the transports
config.bld file C66LE/BE.ccOpts.prefix to remove optimization and add
symbolic debug</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="nl">From</span><span class="p">:</span> <span class="s">&quot;-mo -o3 -q -k -eo.o&quot;</span>
<span class="nl">To</span><span class="p">:</span> <span class="s">&quot;-mo -g -q -k -eo.o&quot;</span>
</pre></div>
</div>
<p>2. From a command prompt navigate to the
pdkpackagestitransportipc(qmss or srio) directory 3 Configure the
XDCPATH environment variable with the BIOS and IPC install locations:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>set XDCPATH=c:\ti\bios_w_xx_yy_zz\packages\
set XDCPATH=%XDCPATH%;c:\ti\ipc_w_xx_yy_zz\packages\
</pre></div>
</div>
<p>4 Configure the XDCCGROOT environment variable with the compiler install
path (Using CGT 7.2.4 installed as part of CCS as an example)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>set XDCCGROOT=c:\ti\ccsv5\tools\compiler\c6000_7.2.4
</pre></div>
</div>
<p>5 Add the XDC Tools to your system PATH</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>set PATH=%PATH%;c:\ti\xdctools_w_xx_yy_zz\
</pre></div>
</div>
<p>6 Clean the transport</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="n">xdc</span> <span class="n">clean</span> <span class="o">-</span><span class="n">PR</span> <span class="p">.</span>
</pre></div>
</div>
<p>7 Build the transport</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="n">xdc</span> <span class="o">-</span><span class="n">PR</span> <span class="p">.</span>
</pre></div>
</div>
<p>If we try this option, we should be able to build in releasemode. Note:
To allow single-step debug of the IPC and BIOS source rebuild the
example projects with the following command added to the example’s .cfg
file BIOS.libType = BIOS.LibType_Debug; &lt;— here.</p>
<img alt="../_images/Qmss_transports.png" src="../_images/Qmss_transports.png" />
</div>
</div>
</div>
</div>
<div class="section" id="opencl">
<h1>4.5. OpenCL<a class="headerlink" href="#opencl" title="Permalink to this headline">¶</a></h1>
<p><a class="reference external" href="http://downloads.ti.com/mctools/esd/docs/opencl/index.html">OpenCL</a></p>
</div>
<div class="section" id="boot">
<h1>4.6. Boot<a class="headerlink" href="#boot" title="Permalink to this headline">¶</a></h1>
<div class="section" id="fc-boot-label">
<span id="id86"></span><h2>4.6.1. Overview<a class="headerlink" href="#fc-boot-label" title="Permalink to this headline">¶</a></h2>
<p>This page provides an overview about the Secondary Bootloader support
provided in Processor SDK RTOS.</p>
<p>The Secondary Bootloader (SBL) sets-up the PLL clocks, powers on the
I/O Peripherals, initializes the DDR, loads the application image into
DDR &amp; brings the slave cores for applicable SOCs out of reset.
Additional details including execution boot flow is covered in more
elaborate detail under individual SOC section.</p>
</div>
<div class="section" id="boot-modes">
<h2>4.6.2. Boot Modes<a class="headerlink" href="#boot-modes" title="Permalink to this headline">¶</a></h2>
<div class="section" id="mmcsd">
<h3>4.6.2.1. MMCSD<a class="headerlink" href="#mmcsd" title="Permalink to this headline">¶</a></h3>
<p>MMCSD bootloader is required to boot target using an SD card containing
bootloader and application images. When the board is powered ON the ROM
bootloader detects the MMCSD bootloader image and loads it to the
internal memory.The bootloader initializes the board, copies the
application image from SD card to the DDR memory and gives control to
the application.</p>
</div>
<div class="section" id="qspi">
<h3>4.6.2.2. QSPI<a class="headerlink" href="#qspi" title="Permalink to this headline">¶</a></h3>
<p>A flash device interfaced with QSPI is flashed with QSPI bootloader and
application images. When the board is powered ON the ROM bootloader
detects the bootloader image from flash device and loads it to the
internal memory. The Bootloader initializes the board, copies the
application image from QSPI device to the DDR memory and gives control
to the application.</p>
</div>
<div class="section" id="uart">
<h3>4.6.2.3. UART<a class="headerlink" href="#uart" title="Permalink to this headline">¶</a></h3>
<p>A Serial connection is used for transferring the bootloader binary from
PC to target board through XMODEM protocol. The bootloader on execution
prompts for application image to transfer through XMODEM. On providing
the path, the application binary is transferred through serial
connection to DDR memory and the control is passed to application to
execute.</p>
</div>
<div class="section" id="mcspi-spi">
<h3>4.6.2.4. MCSPI/SPI<a class="headerlink" href="#mcspi-spi" title="Permalink to this headline">¶</a></h3>
<p>A SPI flash device flashed with MCSPI/SPI bootloader and application
images is used for booting the board. When the board is powered ON the
ROM bootloader detects the bootloader image from flash device and loads
it to the internal memory. The Bootloader initializes the board, copies
the application image from flash to the DDR memory and gives control to
the application.</p>
</div>
<div class="section" id="nand">
<h3>4.6.2.5. NAND<a class="headerlink" href="#nand" title="Permalink to this headline">¶</a></h3>
<p>NAND flash with bootloader and and application images is used for
booting the board. When the board is powered ON the ROM bootloader
detects the bootloader image from flash device and loads it to the
internal memory. The bootloader initializes the board, copies the
application image from flash to the DDR memory and gives control to the
application.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For information on boot mode setting, see the applicable <a class="reference external" href="index_release_specific.html#supported-platforms-and-versions">EVM Hardware User Guide</a></p>
</div>
</div>
</div>
<div class="section" id="platforms">
<h2>4.6.3. Platforms<a class="headerlink" href="#platforms" title="Permalink to this headline">¶</a></h2>
<div class="section" id="am335x-am437x">
<h3>4.6.3.1. AM335x/AM437x<a class="headerlink" href="#am335x-am437x" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id87">
<h4>4.6.3.1.1. Overview<a class="headerlink" href="#id87" title="Permalink to this headline">¶</a></h4>
<p>Bootloader supports power-on-reset bootstraps for the board. It
initializes board, loads application from the memory device to DDR and
transfers control to application. Section provides additional details
including flashing and booting instructions across different media.</p>
</div>
<div class="section" id="source-reference">
<h4>4.6.3.1.2. Source Reference<a class="headerlink" href="#source-reference" title="Permalink to this headline">¶</a></h4>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>&lt; BASE_DIR = PDK_INSTALL_DIR\packages\ti\starterware&gt;
</pre></div>
</div>
<div class="section" id="bootloader-build-files-for-am335x-am437x">
<h5>4.6.3.1.2.1. Bootloader build files for AM335x/AM437x<a class="headerlink" href="#bootloader-build-files-for-am335x-am437x" title="Permalink to this headline">¶</a></h5>
<p><strong>Source files:</strong></p>
<ul class="simple">
<li><p><strong>BASE_DIRbootloadersrc</strong>: Common source files for bootloader
functionality</p></li>
<li><p><strong>BASE_DIRbootloadersrc&lt;device&gt;</strong>: Files specific to device to
initialize platform features like PLL, pinmux and DDR</p></li>
</ul>
<p><strong>Build Files:</strong></p>
<ul class="simple">
<li><p><strong>BASE_DIR/build/makerules/rules_a8.mk</strong>: Common Compiler flags used
for A8 cores. Applies to AMIC110 and AM335x</p></li>
<li><p><strong>BASE_DIR/build/makerules/rules_a8.mk</strong>: Common Compiler flags used
for A9 cores. Applies to AM437x devices</p></li>
<li><p><strong>BASE_DIR/build/makerules/platform.mk</strong>: Global settings for all
components for a particular platform.</p></li>
<li><p><strong>BASE_DIR/build/makerules/components.mk</strong>: Specific settings for
components in starterware</p></li>
<li><p><strong>BASE_DIR/build/makerules/build_cfg.mk</strong>: Flags to enable features
in the build</p></li>
<li><p><strong>BASE_DIR/bootloader/Makefile</strong>: Makefile for bootloader that
provides list of source files and library to create bootloader
binary.</p></li>
</ul>
<p><strong>Boot and flashing tools:</strong></p>
<ul class="simple">
<li><p><strong>BASE_DIR/tools Contains tools to create boot images and flashing
tools to program the boot binary on the boot media.</strong></p></li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="bootloader-execution-sequence">
<h4>4.6.3.1.3. Bootloader execution sequence<a class="headerlink" href="#bootloader-execution-sequence" title="Permalink to this headline">¶</a></h4>
<p>The Processor SDK RTOS boot loader uses a two stage boot process. The
different stages of the application boot sequence using Processor SDK
RTOS bootloader are shown below:</p>
<div class="section" id="boot-sequence">
<h5>4.6.3.1.3.1. Boot Sequence<a class="headerlink" href="#boot-sequence" title="Permalink to this headline">¶</a></h5>
<ol class="arabic simple">
<li><p>Power on Reset</p></li>
<li><p>ROM Bootloader (RBL)</p>
<ul class="simple">
<li><p>Platform configuration and initialization.</p>
<ul>
<li><p>DPLL and clock settings for MPU, I2C, MMCSD, USB, SPI, QSPI,
Ethernet etc.</p></li>
</ul>
</li>
<li><p>Checks Sysboot pins and choose booting device</p>
<ul>
<li><p>If no valid bootloader found on booting device, RBL checks for
next booting device. The sequence depends on RBL execution flow
and Sysboot pins.</p></li>
</ul>
</li>
<li><p>RBL gets image size and load address by checking TI Image Header
appended on bootloader binary(.bin). Check <a class="reference external" href="index_Foundational_Components.html#tools-and-binary-formats">binary
formats</a>.</p></li>
<li><p>Loads the binary to internal OCMC memory at the Load address
fetched from TI Image Header</p></li>
<li><p>Passes control to Secondary Bootloader(SBL)</p></li>
</ul>
</li>
<li><p>Secondary Bootloader(SBL)</p>
<ul class="simple">
<li><p>Configure PLL and Initialize DDR</p></li>
<li><p>Configure PRCM and PinMux  for Boot Peripherals</p></li>
<li><p>Copies application image to DDR</p></li>
<li><p>Passes execution control to Application</p></li>
</ul>
</li>
<li><p>Application execution</p></li>
</ol>
</div>
</div>
<div class="section" id="tools-and-binary-formats">
<h4>4.6.3.1.4. Tools and Binary formats<a class="headerlink" href="#tools-and-binary-formats" title="Permalink to this headline">¶</a></h4>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Binary format</p></td>
<td><p>Requirement</p></td>
<td><p>Details</p></td>
</tr>
<tr class="row-even"><td><p>.bin</p></td>
<td><p>QSPI bootloader,</p>
<p>UART bootloader and
app</p>
</td>
<td><p>QSPI bootloader
binary should in .bin
format and
Application binary
should be in _ti.bin
format.</p>
<p>UART bootloader and
applications are
loaded in .bin format
through XMODEM in
terminal.</p>
</td>
</tr>
<tr class="row-odd"><td><p>_ti.bin</p></td>
<td><p>MMCSD bootloader
and app,</p>
<p>NAND bootloader and
app,</p>
<p>MCSPI boot loader and
app,</p>
<p>QSPI app.</p>
</td>
<td><p>.bin binaries are
converted to
_ti.bin format by
adding Image
size(4bytes) and
Image load
address(4bytes) as
image header.
Refer to Image
format section in
Initialization
chapter of <a class="reference external" href="http://www.ti.com/lit/ug/spruhl7h/spruhl7h.pdf">AM437x
TRM</a></p>
<p>MMCSD, NAND and MCSPI
boot loaders and
application binaries
should be appended
with ti image header.</p>
</td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p><strong>TI Boot image</strong></p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Binary value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x00000000</p></td>
<td><p><strong>Size</strong></p></td>
</tr>
<tr class="row-odd"><td><p>0x00000004</p></td>
<td><p><strong>Entry Point (Location)</strong></p></td>
</tr>
<tr class="row-even"><td><p>0x00000008</p></td>
<td><p><strong>Binary (.bin)</strong></p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>For bootloader Entry point is usually 0x402f0000</p></li>
<li><p>For the app the entry point is usually 0x80000000.</p></li>
</ul>
</div>
<div class="section" id="binary-format-conversion-procedure">
<h5>4.6.3.1.4.1. Binary format conversion procedure<a class="headerlink" href="#binary-format-conversion-procedure" title="Permalink to this headline">¶</a></h5>
<div class="section" id="binary-format-conversion-in-linux">
<h6>4.6.3.1.4.1.1. Binary format conversion in Linux<a class="headerlink" href="#binary-format-conversion-in-linux" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li><p>To convert from .out -&gt; .bin</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TOOLCHAIN_PATH_</span><span class="o">&lt;</span><span class="n">A8</span><span class="o">/</span><span class="n">A9</span><span class="o">&gt;/</span><span class="n">bin</span><span class="o">/</span><span class="n">arm</span><span class="o">-</span><span class="n">none</span><span class="o">-</span><span class="n">eabi</span><span class="o">-</span><span class="n">objcopy</span> <span class="o">-</span><span class="n">O</span> <span class="n">binary</span> <span class="o">&lt;</span><span class="n">application</span><span class="o">&gt;</span><span class="p">.</span><span class="n">out</span> <span class="o">&lt;</span><span class="n">application</span><span class="o">&gt;</span><span class="p">.</span><span class="n">bin</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>Build tiimage.out. Go to starterware/tools/ti_image/</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>gcc tiimage.c –o tiimage.out
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li><p>To convert from .bin -&gt; _ti.bin</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">tiimage</span><span class="p">.</span><span class="n">out</span> <span class="o">&lt;</span><span class="n">Image</span> <span class="n">Load</span> <span class="n">Address</span><span class="o">&gt;</span> <span class="n">NONE</span> <span class="o">&lt;</span><span class="n">application</span><span class="o">&gt;</span><span class="p">.</span><span class="n">bin</span> <span class="o">&lt;</span><span class="n">application</span><span class="o">&gt;</span><span class="n">_ti</span><span class="p">.</span><span class="n">bin</span>
</pre></div>
</div>
</div>
<div class="section" id="binary-format-conversion-in-windows">
<h6>4.6.3.1.4.1.2. Binary format conversion in Windows<a class="headerlink" href="#binary-format-conversion-in-windows" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li><p>To convert from .out -&gt; .bin</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TOOLCHAIN_PATH_</span><span class="o">&lt;</span><span class="n">A8</span><span class="o">/</span><span class="n">A9</span><span class="o">&gt;/</span><span class="n">bin</span><span class="o">/</span><span class="n">arm</span><span class="o">-</span><span class="n">none</span><span class="o">-</span><span class="n">eabi</span><span class="o">-</span><span class="n">objcopy</span> <span class="o">-</span><span class="n">O</span> <span class="n">binary</span> <span class="o">&lt;</span><span class="n">application</span><span class="o">&gt;</span><span class="p">.</span><span class="n">out</span> <span class="o">&lt;</span><span class="n">application</span><span class="o">&gt;</span><span class="p">.</span><span class="n">bin</span>
</pre></div>
</div>
<p>2) To convert from .bin -&gt; _ti.bin. tiimage.exe is provided as prebuilt
binary in starterware/tools/ti_image.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">tiimage</span><span class="p">.</span><span class="n">exe</span> <span class="o">&lt;</span><span class="n">Image</span> <span class="n">Load</span> <span class="n">Address</span><span class="o">&gt;</span> <span class="n">NONE</span> <span class="o">&lt;</span><span class="n">application</span><span class="o">&gt;</span><span class="p">.</span><span class="n">bin</span> <span class="o">&lt;</span><span class="n">application</span><span class="o">&gt;</span><span class="n">_ti</span><span class="p">.</span><span class="n">bin</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
</div>
<div class="section" id="boot-modes-supported">
<h4>4.6.3.1.5. Boot Modes supported<a class="headerlink" href="#boot-modes-supported" title="Permalink to this headline">¶</a></h4>
<p>Following are the Boot Modes supported through AM335x/AM437x bootloader
for the various EVMs.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
</colgroup>
<tbody>
<tr class="row-odd"><td></td>
<td><p><strong>MMCSD</strong></p></td>
<td><p><strong>NAND</strong></p></td>
<td><p><strong>McSPI</strong></p></td>
<td><p><strong>QSPI</strong></p></td>
<td><p><strong>UART</strong></p></td>
</tr>
<tr class="row-even"><td><p><strong>AM335x
GPEVM</strong></p></td>
<td><p>YES</p></td>
<td><p>YES</p></td>
<td><p>YES</p></td>
<td><p>NO</p></td>
<td><p>YES</p></td>
</tr>
<tr class="row-odd"><td><p><strong>AM335x
ICEv2</strong></p></td>
<td><p>YES</p></td>
<td><p>NO</p></td>
<td><p>YES</p></td>
<td><p>NO</p></td>
<td><p>NO</p></td>
</tr>
<tr class="row-even"><td><p><strong>AM335x
StarterKi
t</strong></p></td>
<td><p>YES</p></td>
<td><p>NO</p></td>
<td><p>NO</p></td>
<td><p>NO</p></td>
<td><p>YES</p></td>
</tr>
<tr class="row-odd"><td><p><strong>AM335x
BeagleBon
eBlack</strong></p></td>
<td><p>YES</p></td>
<td><p>NO</p></td>
<td><p>NO</p></td>
<td><p>NO</p></td>
<td><p>YES</p></td>
</tr>
<tr class="row-even"><td><p><strong>AM437x
GPEVM</strong></p></td>
<td><p>YES</p></td>
<td><p>NO</p></td>
<td><p>NO</p></td>
<td><p>NO</p></td>
<td><p>YES</p></td>
</tr>
<tr class="row-odd"><td><p><strong>AM437x
IDK</strong></p></td>
<td><p>YES</p></td>
<td><p>NO</p></td>
<td><p>NO</p></td>
<td><p>YES</p></td>
<td><p>NO</p></td>
</tr>
<tr class="row-even"><td><p><strong>AM437x
StarterKi
t</strong></p></td>
<td><p>YES</p></td>
<td><p>NO</p></td>
<td><p>NO</p></td>
<td><p>NO</p></td>
<td><p>NO</p></td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="building-the-bootloader">
<h4>4.6.3.1.6. Building the Bootloader<a class="headerlink" href="#building-the-bootloader" title="Permalink to this headline">¶</a></h4>
<dl class="simple">
<dt><strong>Pre-requisite:</strong> Setup SDK build environment as described in article</dt><dd><p><a class="reference external" href="index_overview.html#setup-environment">Setup_Environment</a></p>
</dd>
</dl>
<p class="rubric" id="normal-operation-of-bootloader">Normal Operation of Bootloader:</p>
<p>Bootloading an application from flash into DDR memory as in case of TI
evaluation platforms is described as normal operation mode for the
bootloader. This is the default behaviour of the bootloader and can be
built using the following command in starterware.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">gmake</span> <span class="n">bootloader</span> <span class="n">BUILDCFG</span><span class="o">=</span><span class="n">boot</span> <span class="n">BOOTMODE</span><span class="o">=&lt;</span><span class="n">BOOT_MODE</span><span class="o">&gt;</span> <span class="n">PLATFORM</span><span class="o">=&lt;</span><span class="n">EVM</span><span class="o">&gt;</span> <span class="n">PROFILE</span><span class="o">=&lt;</span><span class="n">BUILD_PROFILE</span><span class="o">&gt;</span> <span class="o">-</span><span class="n">s</span> <span class="n">KW_BUILD</span><span class="o">=</span><span class="n">no</span>
</pre></div>
</div>
<ul class="simple">
<li><p>BOOT_MODE: mcspi, nand, qspi, mmcsd, uart (Check supported boot modes
for your evaluation platform)</p></li>
<li><p>EVM: am335x-evm, am43xx-evm, amic110-ddrless</p></li>
<li><p>BUILD_PROFILE: debug, release</p></li>
</ul>
<p class="rubric" id="additional-build-options-currently-support-only-for-amic110am335x-ice-users">Additional Build options (currently support only for
AMIC110/AM335x ICE Users)</p>
<ul class="simple">
<li><p><strong>DDR less Application boot setup</strong></p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">gmake</span> <span class="n">bootloader</span> <span class="n">BUILDCFG</span><span class="o">=</span><span class="n">boot</span> <span class="n">BOOTMODE</span><span class="o">=</span><span class="n">mcspi</span> <span class="n">PLATFORM</span><span class="o">=</span><span class="n">amic110</span><span class="o">-</span><span class="n">ddrless</span> <span class="n">PROFILE</span><span class="o">=</span><span class="n">debug</span> <span class="o">-</span><span class="n">s</span> <span class="n">KW_BUILD</span><span class="o">=</span><span class="n">no</span> <span class="n">USE_DDR</span><span class="o">=</span><span class="n">no</span>
<span class="n">gmake</span> <span class="n">bootloader</span> <span class="n">BUILDCFG</span><span class="o">=</span><span class="n">boot</span> <span class="n">BOOTMODE</span><span class="o">=</span><span class="n">mcspi</span> <span class="n">PLATFORM</span><span class="o">=</span><span class="n">amic110</span><span class="o">-</span><span class="n">ddrless</span> <span class="n">PROFILE</span><span class="o">=</span><span class="n">release</span> <span class="o">-</span><span class="n">s</span> <span class="n">KW_BUILD</span><span class="o">=</span><span class="n">no</span> <span class="n">USE_DDR</span><span class="o">=</span><span class="n">no</span>
</pre></div>
</div>
<p>This option builds an ultra light weight (&lt;10 KB) bootloader for cost
optimized application that don`t external DDR memory.</p>
<ul class="simple">
<li><p><strong>PRU/ICSS Enable in SBL</strong></p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">gmake</span> <span class="n">bootloader</span> <span class="n">BUILDCFG</span><span class="o">=</span><span class="n">boot</span> <span class="n">BOOTMODE</span><span class="o">=</span><span class="n">mcspi</span> <span class="n">PLATFORM</span><span class="o">=</span><span class="n">am335x</span><span class="o">-</span><span class="n">evm</span> <span class="n">PROFILE</span><span class="o">=</span><span class="n">debug</span> <span class="o">-</span><span class="n">s</span> <span class="n">KW_BUILD</span><span class="o">=</span><span class="n">no</span> <span class="n">ENABLE_PRU</span><span class="o">=</span><span class="n">yes</span>
<span class="n">gmake</span> <span class="n">bootloader</span> <span class="n">BUILDCFG</span><span class="o">=</span><span class="n">boot</span> <span class="n">BOOTMODE</span><span class="o">=</span><span class="n">mcspi</span> <span class="n">PLATFORM</span><span class="o">=</span><span class="n">am335x</span><span class="o">-</span><span class="n">evm</span> <span class="n">PROFILE</span><span class="o">=</span><span class="n">release</span> <span class="o">-</span><span class="n">s</span> <span class="n">KW_BUILD</span><span class="o">=</span><span class="n">no</span> <span class="n">ENABLE_PRU</span><span class="o">=</span><span class="n">yes</span>
</pre></div>
</div>
<p>This feature is required in application that need to quick wake up of
ICSS/PRU cores. The PRU cores can be woken up and loaded from the SBL by
combining the ENABLE_PRU and BIN_LOAD arguments.</p>
<ul class="simple">
<li><p><strong>Load additional binaries from flash</strong></p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">gmake</span> <span class="n">bootloader</span> <span class="n">BUILDCFG</span><span class="o">=</span><span class="n">boot</span> <span class="n">BOOTMODE</span><span class="o">=</span><span class="n">mcspi</span> <span class="n">PLATFORM</span><span class="o">=</span><span class="n">am335x</span><span class="o">-</span><span class="n">evm</span> <span class="n">PROFILE</span><span class="o">=</span><span class="n">debug</span> <span class="o">-</span><span class="n">s</span> <span class="n">KW_BUILD</span><span class="o">=</span><span class="n">no</span> <span class="n">BIN_LOAD</span><span class="o">=</span><span class="n">yes</span>
<span class="n">gmake</span> <span class="n">bootloader</span> <span class="n">BUILDCFG</span><span class="o">=</span><span class="n">boot</span> <span class="n">BOOTMODE</span><span class="o">=</span><span class="n">mcspi</span> <span class="n">PLATFORM</span><span class="o">=</span><span class="n">am335x</span><span class="o">-</span><span class="n">evm</span> <span class="n">PROFILE</span><span class="o">=</span><span class="n">release</span> <span class="o">-</span><span class="n">s</span> <span class="n">KW_BUILD</span><span class="o">=</span><span class="n">no</span> <span class="n">BIN_LOAD</span><span class="o">=</span><span class="n">yes</span>
</pre></div>
</div>
<p>The location of binaries in offset is configured using
sbl_flash_offset_cfg.h in the bootloader source. Users are required to
use TIIMAGE tool to append an header to the binary so that the
bootloader knows the loction and size of the binary to be loaded.</p>
<p class="rubric" id="industrial-ddrless-booting">Industrial DDRless Booting</p>
<p>The AMIC110 DDRLESS platform provides a superset flag to enable all the
above features and build the bootloader . The superset build is invoked
using <strong>BUILD_ICSS_DDRLESS_BOOT=yes</strong> as shown below:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">gmake</span> <span class="n">bootloader</span> <span class="n">BUILDCFG</span><span class="o">=</span><span class="n">boot</span> <span class="n">BOOTMODE</span><span class="o">=</span><span class="n">mcspi</span> <span class="n">PLATFORM</span><span class="o">=</span><span class="n">amic110</span><span class="o">-</span><span class="n">ddrless</span> <span class="n">PROFILE</span><span class="o">=</span><span class="n">debug</span> <span class="o">-</span><span class="n">s</span> <span class="n">KW_BUILD</span><span class="o">=</span><span class="n">no</span> <span class="n">BUILD_ICSS_DDRLESS_BOOT</span><span class="o">=</span><span class="n">yes</span>
<span class="n">gmake</span> <span class="n">bootloader</span> <span class="n">BUILDCFG</span><span class="o">=</span><span class="n">boot</span> <span class="n">BOOTMODE</span><span class="o">=</span><span class="n">mcspi</span> <span class="n">PLATFORM</span><span class="o">=</span><span class="n">amic110</span><span class="o">-</span><span class="n">ddrless</span> <span class="n">PROFILE</span><span class="o">=</span><span class="n">release</span> <span class="o">-</span><span class="n">s</span> <span class="n">KW_BUILD</span><span class="o">=</span><span class="n">no</span> <span class="n">BUILD_ICSS_DDRLESS_BOOT</span><span class="o">=</span><span class="n">yes</span>
</pre></div>
</div>
<p>Prebuilt binaries inside the Processor SDK RTOS for AMIC110-DDRLESS will
be configured using this option to allow for testing of cost optimized
industrial use case.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="boot-mode-settings">
<h4>4.6.3.1.7. Boot Mode settings<a class="headerlink" href="#boot-mode-settings" title="Permalink to this headline">¶</a></h4>
<p>Boot mode settings for all supported AM335x and AM437x boards are <a class="reference external" href="http://processors.wiki.ti.com/index.php/Processor_SDK_RTOS_CSL_AM335x/AM437x_Boot_mode_settings">here</a></p>
</div>
<div class="section" id="id88">
<h4>4.6.3.1.8. Boot Modes<a class="headerlink" href="#id88" title="Permalink to this headline">¶</a></h4>
<div class="section" id="booting-via-sd-card">
<h5>4.6.3.1.8.1. Booting Via SD Card<a class="headerlink" href="#booting-via-sd-card" title="Permalink to this headline">¶</a></h5>
<p>Booting from SD Card involves two steps.</p>
<ol class="arabic simple">
<li><p>Preparing SD card.</p></li>
<li><p>Booting target.</p></li>
</ol>
<div class="section" id="preparing-sd-card">
<h6>4.6.3.1.8.1.1. Preparing SD card<a class="headerlink" href="#preparing-sd-card" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li><p>To boot target the SD card should be bootable. Follow the steps at
<a class="reference external" href="index_overview.html#windows-sd-card-creation-guide">Creating bootable SD card in windows</a>
or <a class="reference external" href="index_overview.html#linux-sd-card-creation-guide">Creating bootable SD card in Linux</a>.</p></li>
<li><p>Delete the “<em>MLO</em>” and “<em>app</em>” in the bootable SD card which are
created in the process of making the SD bootable.</p></li>
<li><p>Bootloader images with ti header (&lt;mmcsd_bootloader&gt;_ti.bin)should be
renamed to “<em>MLO</em>”. Bootloader images are located at
<em>&lt;PDK_INSTALL_DIRpackagestistarterwarestarterwarebinarybootloaderbin&lt;TargetType</em>&gt;</p></li>
<li><p>Similarly the converted application binary image has to be renamed to
“<em>app</em>” from “<em>&lt;app_name&gt;_ti.bin</em>”</p></li>
<li><p>Copy both the boot loader image “<em>MLO</em>” and the application image
“<em>app</em>” to the SD card.</p></li>
<li><p>The SD card is ready for use on target.</p></li>
</ol>
</div>
<div class="section" id="booting-target">
<h6>4.6.3.1.8.1.2. Booting target<a class="headerlink" href="#booting-target" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li><p>Insert SD card to the base board SD slot. Connect a UART cable to a
host running a serial terminal application (teraterm/hyperterminal)
with 115200 baud, 8bit, No parity and 1 STOP bit configuration.</p></li>
<li><p>Configure the board for SD Boot mode</p>
<ol class="arabic simple">
<li><p>SD instance 0 (on base board) is available in all profiles.</p></li>
<li><p>SD instance 0 boot mode needs to appropriately set. For SD boot to
be selected first, SD boot should appear first in the boot device
list in the boot mode. If any other boot mode is selected, even if
a SD boot card is inserted, and does not appear first in the list,
the first available sane boot image (like NAND or SPI etc) is
booted and SD is not selected. Only if no sane boot image is found
in the first devices, SD boot image will be selected.</p></li>
</ol>
</li>
<li><p>Once SD boot image is chosen, the <em>MLO</em> is first detected and copied
and executed from the OCMC0 RAM. The <em>MLO</em> then copies the
application image (<em>app</em>) from the card to the SDRAM and passes the
control to the application. If the process is succesful, messages
identifying board and SoC will appear on the serial console.</p></li>
</ol>
<p>After this the application will take control and execute.</p>
<p><strong>NOTE:</strong> If board have BootMode selection pins choose proper Boot
Selection pins from hardware reference manuals.</p>
<div class="line-block">
<div class="line">If the boards have no boot mode selection pins and a valid boot image
is present on McSPI flash, Booting will happen from McSPI flash. Erase
McSPI flash in such cases to boot from SD card <a class="reference external" href="http://processors.wiki.ti.com/index.php?title=StarterWare_Booting_And_Flashing&amp;action=edit&amp;redlink=1">McSPI flash
erase</a>
. The boot sequence depends on ROM bootloader.</div>
</div>
</div>
</div>
<div class="section" id="booting-via-qspi">
<h5>4.6.3.1.8.2. Booting Via QSPI<a class="headerlink" href="#booting-via-qspi" title="Permalink to this headline">¶</a></h5>
<p>Booting from QSPI flash involves two steps-</p>
<ol class="arabic simple">
<li><p>Preparing Flash Device</p></li>
<li><p>Booting target.</p></li>
</ol>
<div class="section" id="preparing-flash-device">
<h6>4.6.3.1.8.2.1. Preparing Flash Device<a class="headerlink" href="#preparing-flash-device" title="Permalink to this headline">¶</a></h6>
<p>Procedure relies on contents being copied to SD card. Additional
details below:</p>
<ol class="arabic simple">
<li><p>Copy bootloader image(bootloader_boot_qspi_a9host_debug.bin rename)
and app image(“&lt;app_name&gt;_ti.bin”) into the SD card.
The file names have to be renamed in such a way that the length of
name is less than 9 characters. Any file name less than 9 characters
can be used.
Rename the bootloader file to ‘boot’ and application image to ‘app’
with no extensions.</p></li>
<li><p>Copy the ‘config’ file into the SD card which will contain the names
of the image to be flashed and the offset.
A sample config file can be found at
<em>&lt;PDK_INSTALL_DIRpackagestistarterwarestarterwaretoolsqspiconfig&gt;
directory</em>. Do not change name of the <strong>config</strong> file.
<strong>NOTE:</strong> “config” file can be used without any modifications if
bootloader and application images are renamed to “boot” and “app”.
<strong>NOTE:</strong> Do not rename bootloader to be copied to SD card as
“<em>MLO</em>”, as MMCSD bootloader expects “<em>MLO</em>” and “<em>app</em>” to boot.</p></li>
<li><p>Now SD card contains 1)boot 2)app 3)config files.
config file contains the address of boot image as <strong>0x0</strong> and app
image as <strong>0x80000</strong>.
Insert it into the SD card slot.</p></li>
<li><p>Connect the board with CCS and load the prebuilt qspi flash writer
application from
<em>&lt;PDK_INSTALL_DIRpackagestistarterwarestarterwarebinaryqspi_app_flash_writerbinm43xx-evm&gt;</em></p></li>
<li><p>Run the QSPI flash writer application. Following logs expected on
console.</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">StarterWare</span> <span class="n">QSPI</span> <span class="n">Flash</span> <span class="n">Writer</span><span class="o">!!</span>
<span class="n">BOARDInit</span> <span class="n">status</span> <span class="p">[</span><span class="mh">0x0</span><span class="p">]</span>
<span class="nl">SoC</span>                   <span class="p">:</span> <span class="p">[</span><span class="n">AM43XX</span><span class="p">]</span>
<span class="nl">Core</span>                  <span class="p">:</span> <span class="p">[</span><span class="n">A9</span><span class="p">]</span>
<span class="n">Board</span> <span class="nl">Detected</span>        <span class="p">:</span> <span class="p">[</span><span class="n">IDKEVM</span><span class="p">]</span>
<span class="n">Base</span> <span class="n">Board</span> <span class="nl">Revision</span>   <span class="p">:</span> <span class="p">[</span><span class="n">UNKNOWN</span><span class="p">]</span>
<span class="n">Daughter</span> <span class="n">Card</span> <span class="nl">Revision</span><span class="p">:</span> <span class="p">[</span><span class="n">UNKNOWN</span><span class="p">]</span>
<span class="n">Copying</span> <span class="n">boot</span> <span class="n">to</span> <span class="n">QSPI</span> <span class="n">Flash</span>
<span class="n">Copying</span> <span class="n">app</span> <span class="n">to</span> <span class="n">QSPI</span> <span class="n">Flash</span>
<span class="n">Changing</span> <span class="n">read</span> <span class="n">to</span> <span class="n">quad</span> <span class="n">mode</span>
<span class="n">Read</span> <span class="n">mode</span> <span class="n">has</span> <span class="n">been</span> <span class="n">changed</span> <span class="n">to</span> <span class="n">Quad</span> <span class="n">mode</span>
<span class="n">SUCCESS</span><span class="o">!!!</span>
<span class="n">Flashing</span> <span class="n">completed</span>
</pre></div>
</div>
</div>
<div class="section" id="booting-the-target">
<h6>4.6.3.1.8.2.2. Booting the target.<a class="headerlink" href="#booting-the-target" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li><p>Connect UART cable to a host running serial terminal application
(teraterm/hyperterminal) with 115200 baud, 8bit, No parity and 1 STOP
bit configuration.</p></li>
<li><p>After flashing successfully remove SD card and reboot to see
following logs</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">StarterWare</span> <span class="n">Boot</span> <span class="n">Loader</span>
<span class="n">BOARDInit</span> <span class="n">status</span> <span class="p">[</span><span class="mh">0x0</span><span class="p">]</span>
<span class="nl">SoC</span>                   <span class="p">:</span> <span class="p">[</span><span class="n">AM43XX</span><span class="p">]</span>
<span class="nl">Core</span>                  <span class="p">:</span> <span class="p">[</span><span class="n">A9</span><span class="p">]</span>
<span class="n">Board</span> <span class="nl">Detected</span>        <span class="p">:</span> <span class="p">[</span><span class="n">IDKEVM</span><span class="p">]</span>
<span class="n">Base</span> <span class="n">Board</span> <span class="nl">Revision</span>   <span class="p">:</span> <span class="p">[</span><span class="n">UNKNOWN</span><span class="p">]</span>
<span class="n">Daughter</span> <span class="n">Card</span> <span class="nl">Revision</span><span class="p">:</span> <span class="p">[</span><span class="n">UNKNOWN</span><span class="p">]</span>
<span class="n">Copying</span> <span class="n">Header</span> <span class="n">of</span> <span class="n">the</span> <span class="n">application</span> <span class="n">image</span>
<span class="n">Copying</span> <span class="n">image</span> <span class="n">from</span> <span class="n">flash</span> <span class="n">to</span> <span class="n">DDR</span>
<span class="n">Jumping</span> <span class="n">to</span> <span class="n">StarterWare</span> <span class="n">Application</span><span class="p">...</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="nl">NOTE</span><span class="p">:</span> <span class="n">Boot</span> <span class="n">logs</span> <span class="n">will</span> <span class="n">appear</span> <span class="n">approximately</span> <span class="n">after</span> <span class="mi">25</span> <span class="n">seconds</span> <span class="n">on</span> <span class="n">reset</span><span class="p">.</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span> <span class="nl">NOTE</span><span class="p">:</span><span class="n">If</span> <span class="n">there</span> <span class="n">is</span> <span class="n">no</span> <span class="n">boot</span> <span class="n">mode</span> <span class="n">selection</span> <span class="n">present</span> <span class="n">on</span> <span class="n">board</span><span class="p">,</span> <span class="n">boot</span> <span class="n">image</span> <span class="n">will</span> <span class="n">be</span> <span class="n">loaded</span> <span class="n">depending</span> <span class="n">on</span> <span class="n">ROM</span> <span class="n">boot</span> <span class="n">sequence</span>
<span class="nl">Example</span><span class="p">:</span> <span class="n">If</span> <span class="n">QSPI</span> <span class="n">flash</span> <span class="n">and</span> <span class="n">MMCSD</span> <span class="n">has</span> <span class="n">valid</span> <span class="n">bootloaders</span><span class="p">,</span> <span class="n">on</span> <span class="n">reset</span> <span class="n">MMCSD</span> <span class="n">boot</span> <span class="n">image</span> <span class="n">will</span> <span class="n">be</span> <span class="n">loaded</span> <span class="n">following</span> <span class="n">ROM</span> <span class="n">Boot</span> <span class="n">sequence</span><span class="p">.</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="booting-via-uart">
<h5>4.6.3.1.8.3. Booting Via UART<a class="headerlink" href="#booting-via-uart" title="Permalink to this headline">¶</a></h5>
<p>ROM and Bootloader supports XMODEM protocol with images being binary
not requiring any additional headers. Following are steps for boot:</p>
<ol class="arabic simple">
<li><p>Configure board for UART boot mode :
UART boot need to be first in the boot device list. Note: In case if
any other boot mode is selected, the first available boot image
(eg:NAND or MMCSD etc) will override. In case of no valid images,
UART boot will be selected.</p>
<ul class="simple">
<li><p>Select View-&gt;Memory Browser through CCS.</p></li>
<li><p>Select address 0x44e10040.</p></li>
<li><p>Write 0x19 to last 2 bytes of this memory address.(UART boot)</p></li>
<li><p>Soft reset the board. This is a volatile bit which gets reset
after power on.</p></li>
</ul>
</li>
<li><p>ROM code will print “CC..” on UART console expecting Bootloader via
XMODEM. File can be sent via xmodem through tera-term File-&gt; Transfer
-&gt; XMODEM -&gt; Send.</p></li>
<li><p>On transmitting bootloader
image, bootloader_boot_uart_a9host_debug.bin via XMODEM, following
message will be expected on serial console.</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">CCCCCCCCCCCCCCCCCCCCCCCCCCCC</span>
<span class="n">StarterWare</span> <span class="n">Boot</span> <span class="n">Loader</span>
<span class="n">BOARDInit</span> <span class="n">status</span> <span class="p">[</span><span class="mh">0x0</span><span class="p">]</span>
 <span class="nl">SoC</span>                   <span class="p">:</span> <span class="p">[</span><span class="n">AM43XX</span><span class="p">]</span>
 <span class="nl">Core</span>                  <span class="p">:</span> <span class="p">[</span><span class="n">A9</span><span class="p">]</span>
 <span class="n">Board</span> <span class="nl">Detected</span>        <span class="p">:</span> <span class="p">[</span><span class="n">IDKEVM</span><span class="p">]</span>
 <span class="n">Base</span> <span class="n">Board</span> <span class="nl">Revision</span>   <span class="p">:</span> <span class="p">[</span><span class="n">UNKNOWN</span><span class="p">]</span>
 <span class="n">Daughter</span> <span class="n">Card</span> <span class="nl">Revision</span><span class="p">:</span> <span class="p">[</span><span class="n">UNKNOWN</span><span class="p">]</span>
<span class="n">GPIO</span> <span class="n">Instance</span> <span class="nl">number</span><span class="p">:</span> <span class="mi">0</span>
<span class="n">Pin</span> <span class="nl">number</span><span class="p">:</span> <span class="mi">22</span>
<span class="n">Please</span> <span class="n">transfer</span> <span class="nl">file</span><span class="p">:</span>
<span class="n">CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC</span>
</pre></div>
</div>
<p>  4.  As  a next step application binary (without header) can be sent
via XMODEM which will lead to application start executing.</p>
</div>
<div class="section" id="booting-via-mcspi">
<h5>4.6.3.1.8.4. Booting Via McSPI<a class="headerlink" href="#booting-via-mcspi" title="Permalink to this headline">¶</a></h5>
<p>Booting from McSPI involves two steps.</p>
<ol class="arabic simple">
<li><p>Preparing Flash Device</p></li>
<li><p>Booting the target.</p></li>
</ol>
<p class="rubric" id="preparing-flash-device-1">Preparing Flash Device</p>
<ul class="simple">
<li><p>Set the appropriate bootmode if applicable for EVM.Refer <a class="reference external" href="http://processors.wiki.ti.com/index.php/Processor_SDK_RTOS_CSL_AM335x/AM437x_Boot_mode_settings">Boot mode
settings</a>.
<strong>Note</strong>: Most of the boards may not have switch settings.</p></li>
<li><p>Add a required target configuration in CCS depending on emulator and
board connected.</p></li>
<li><p>Connect target to required core. Ex: A8.</p></li>
<li><p>Load the flash writer from
<em>&lt;PDK_INSTALL_DIRpackagestistarterwarestarterwaretoolsflash_writerspi_flash_writer_AM335X.out</em>
onto the EVM.</p></li>
<li><p>Run the application and observe the logs on CCS console.</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Starting</span> <span class="n">SPIWriter</span><span class="p">.</span>
<span class="n">Choose</span> <span class="nl">Operation</span><span class="p">:</span>
<span class="n">Enter</span> <span class="mi">1</span> <span class="o">----&gt;</span> <span class="n">To</span> <span class="n">FLASH</span> <span class="n">an</span> <span class="n">Image</span>
<span class="n">Enter</span> <span class="mi">2</span> <span class="o">----&gt;</span> <span class="n">To</span> <span class="n">ERASE</span> <span class="n">Flash</span>
<span class="n">Enter</span> <span class="mi">3</span> <span class="o">----&gt;</span> <span class="n">To</span> <span class="n">EXIT</span>
</pre></div>
</div>
<ul class="simple">
<li><p>When Flash option is chosen program prompts to enter file name.</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Enter</span> <span class="n">the</span> <span class="n">File</span> <span class="n">Name</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Provide the complete path of file
<em>bootloader_boot_mcspi_a8host_release_ti.bin</em> at directory
“binary/bootloader/bin/&lt;PLATFORM&gt;/&lt;gcc/ccs&gt;/” and hit Enter.</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Enter</span> <span class="n">the</span> <span class="n">Offset</span> <span class="n">in</span> <span class="n">bytes</span> <span class="p">(</span><span class="n">in</span> <span class="n">HEX</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Provide <strong>0x00000</strong> to flash bootloader.</p></li>
<li><p>To flash application binary image &lt;app_name&gt;_a8host_ti.bin, provide
<strong>0x20000</strong>.</p></li>
<li><p>Wait for few miniuits as flashing is a slower process.</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>Erasing flash at byte offset: xx, byte length: xxxx
SF: Successfully erased xxxx bytes @ xxxx
Writing flash at page offset: x, number of pages: xxxx
Flashing is in progress...
Verifying... Success.
</pre></div>
</div>
<ul class="simple">
<li><p>Once SPI flash writing completes disconnect target.</p></li>
</ul>
<p class="rubric" id="id89">Booting the target</p>
<ol class="arabic simple">
<li><p>Connect a serial cable to a host running a serial terminal
application (teraterm/hyperterminal) with 115200 baud, 8bit, No
parity and 1 STOP bit configuration.</p></li>
<li><p>Configure the board for SPI boot mode.</p></li>
<li><p>On reset, ROM bootloder copies the bootloader from flash to internal
memory. The bootloader then copies the application image from flash
to DDR and passes the control to the application.</p></li>
</ol>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="booting-via-nand">
<h5>4.6.3.1.8.5. Booting Via NAND<a class="headerlink" href="#booting-via-nand" title="Permalink to this headline">¶</a></h5>
<p>Booting from NAND involves two steps.</p>
<ol class="arabic simple">
<li><p>Preparing Flash Device</p></li>
<li><p>Booting the target.</p></li>
</ol>
<p class="rubric" id="preparing-flash-device-2">Preparing Flash Device</p>
<ul class="simple">
<li><p>Configure BOOT pins for NAND <a class="reference external" href="http://processors.wiki.ti.com/index.php/Processor_SDK_RTOS_CSL_AM335x/AM437x_Boot_mode_settings">Boot mode
settings</a></p></li>
<li><p>Connect target with CCS.</p></li>
<li><p>Load the
<em>&lt;PDK_INSTALL_DIRpackagestistarterwarestarterwaretoolsflash_writernand_flash_writer_AM335X.out&gt;</em>
to target and Run. Flash writer will output messages to CCS console.
When it prompts for inputs, proper inputs shall be given via CCS
console.</p></li>
<li><p>When prompted for binary file name, update file with proper path.</p></li>
<li><p>Select option for flashing.</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Choose</span> <span class="n">your</span> <span class="n">operation</span>
<span class="n">Enter</span> <span class="mi">1</span> <span class="o">---&gt;</span> <span class="n">To</span> <span class="n">Flash</span> <span class="n">an</span> <span class="n">Image</span>
<span class="n">Enter</span> <span class="mi">2</span> <span class="o">---&gt;</span> <span class="n">To</span> <span class="n">ERASE</span> <span class="n">the</span> <span class="n">whole</span> <span class="n">NAND</span>
<span class="n">Enter</span> <span class="mi">3</span> <span class="o">---&gt;</span> <span class="n">To</span> <span class="n">EXIT</span>
</pre></div>
</div>
<ul class="simple">
<li><p>If Option 1 is selected, enter image path to flash when prompted as
shown below.</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Enter</span> <span class="n">image</span> <span class="n">file</span> <span class="n">path</span>
</pre></div>
</div>
<p>    Provide the complete path (e.g.
&lt;PDK_INSTALL_DIRpackagestistarterwarestarterwarebinarybootloaderbin&lt;am335x/am437x-evm&gt;&lt;compiler&gt;bootloader_boot_nand_a8host_&lt;debug/release&gt;_ti.bin)</p>
<ul class="simple">
<li><p>Enter offset when prompted as shown below.</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Enter</span> <span class="n">offset</span> <span class="p">(</span><span class="n">in</span> <span class="n">hex</span><span class="p">)</span><span class="o">:</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">    This offset is start location from where the image should be
flashed.</div>
<div class="line">NOTE:</div>
</div>
<ol class="arabic simple">
<li><p>Use hex format</p></li>
<li><p>If bootloader is to be flashed, provide <strong>0x00000</strong>. For application
binary, provide <strong>0x80000</strong>.</p></li>
</ol>
<ul class="simple">
<li><p>Select ECC for flashing.</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Choose</span> <span class="n">the</span> <span class="n">ECC</span> <span class="n">scheme</span> <span class="n">from</span> <span class="n">given</span> <span class="n">options</span>
<span class="n">Enter</span> <span class="mi">1</span> <span class="o">---&gt;</span> <span class="n">BCH</span> <span class="mi">8</span> <span class="n">bit</span>
<span class="n">Enter</span> <span class="mi">2</span> <span class="o">---&gt;</span> <span class="n">HAM</span>
<span class="n">Enter</span> <span class="mi">3</span> <span class="o">---&gt;</span> <span class="n">T0</span> <span class="n">EXIT</span>
<span class="n">Please</span> <span class="n">enter</span> <span class="n">ECC</span> <span class="n">scheme</span> <span class="nl">type</span><span class="p">:</span>
</pre></div>
</div>
<p>    Always select BCH8 for bootloader and application as ROM code and
bootloader uses the BCH8 ECC scheme.</p>
<ul class="simple">
<li><p>Ensure that flash info displayed by tool matches NAND flash in EVM.</p></li>
<li><p>After this tool should first erase the required region in flash and
then start flashing new image.</p></li>
<li><p>If flashing procedure is complete following message should be
displayed.</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Application</span> <span class="n">is</span> <span class="n">successfully</span> <span class="n">flashed</span>
<span class="n">NAND</span> <span class="n">flashing</span> <span class="n">successful</span><span class="o">!</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Once NAND flash writing completes, disconnect from CCS.</p></li>
</ul>
<p class="rubric" id="booting-the-target-1">Booting the target</p>
<ul class="simple">
<li><p>Connect a UART cable to a host running a serial terminal application
(teraterm/hyperterminal) with 115200 baud, 8bit, No parity and 1 STOP
bit configuration.</p></li>
<li><p>Configure the board for NAND boot mode. Refer  <a class="reference external" href="http://processors.wiki.ti.com/index.php/Processor_SDK_RTOS_CSL_AM335x/AM437x_Boot_mode_settings">Boot mode
settings</a></p></li>
<li><p>On reset, ROM detects bootloader from NAND and copies it to internal
memory. Bootloader then copies application image from the NAND to DDR
and passes control to application. If the process is succesful,
following messages appear in serial console.</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>   <span class="n">StarterWare</span> <span class="n">Boot</span> <span class="n">Loader</span>
<span class="n">BOARDInit</span> <span class="n">status</span> <span class="p">[</span><span class="mh">0x0</span><span class="p">]</span>
<span class="nl">SoC</span>                   <span class="p">:</span> <span class="p">[</span><span class="n">AM335X</span><span class="p">]</span>
<span class="nl">Core</span>                  <span class="p">:</span> <span class="p">[</span><span class="n">A8</span><span class="p">]</span>
<span class="n">Board</span> <span class="nl">Detected</span>        <span class="p">:</span> <span class="p">[</span><span class="n">GPEVM</span><span class="p">]</span>
<span class="n">Base</span> <span class="n">Board</span> <span class="nl">Revision</span>   <span class="p">:</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">]</span>
<span class="n">Daughter</span> <span class="n">Card</span> <span class="nl">Revision</span><span class="p">:</span> <span class="p">[</span><span class="n">UNKNOWN</span><span class="p">]</span>
<span class="n">NAND</span> <span class="n">flash</span> <span class="n">is</span> <span class="n">connected</span> <span class="n">to</span> <span class="n">GPMC</span> <span class="n">on</span> <span class="k">this</span> <span class="n">board</span>
<span class="n">Jumping</span> <span class="n">to</span> <span class="n">StarterWare</span> <span class="n">Application</span><span class="p">...</span>
</pre></div>
</div>
<p>After this application should take control and execute.</p>
</div>
</div>
<div class="section" id="test-application">
<h4>4.6.3.1.9. Test Application<a class="headerlink" href="#test-application" title="Permalink to this headline">¶</a></h4>
<p>The section explains steps for building and booting a sample pdk
application for am335x or am437x using MMCSD bootloader.</p>
<div class="section" id="test-application-image-creation">
<h5>4.6.3.1.9.1. Test Application Image Creation<a class="headerlink" href="#test-application-image-creation" title="Permalink to this headline">¶</a></h5>
<p>Follow below steps to generate the bootable application image.</p>
<ol class="arabic simple">
<li><p>Generate .out files using steps for <a class="reference external" href="index_how_to_guides.html#rebuild-drivers-from-pdk-directory">Rebuilding
PDK</a>. Locate .out file in directory
<em>&lt;PDK_INSTALL_PATH/MyExampleProjects/&lt;ExampleProjectDirectory&gt;/Debug&gt;</em></p></li>
<li><p>Convert files to support MMCSD boot using steps as per <a class="reference external" href="index_Foundational_Components.html#binary-format-conversion-procedure">Binary format
conversion procedure</a>.</p></li>
<li><p>Rename generated &lt;Application&gt;_ti.bin to “app”.</p></li>
</ol>
</div>
<div class="section" id="loading-test-application">
<h5>4.6.3.1.9.2. Loading Test application<a class="headerlink" href="#loading-test-application" title="Permalink to this headline">¶</a></h5>
<p>Follow procedure to use “app” file as per section <a class="reference external" href="index_Foundational_Components.html#booting-via-sd-card">Booting Via SD
Card</a>.</p>
</div>
</div>
<div class="section" id="usage-notes">
<h4>4.6.3.1.10. Usage Notes<a class="headerlink" href="#usage-notes" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><strong>Bootloader Memory map</strong></p></li>
</ul>
<p>The bootloader code runs from internal OCMC memory and occupies certain
amount of OCMC memory that is not available for application to use
during booting.</p>
<p>Refer to the map file for the boot loader to check for latest
information on the memory utilization in the boot loader.</p>
<p>Location of linker command file:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>BASE_DIR\binary\bootloader\bin\&lt;platform&gt;\gcc
</pre></div>
</div>
<p>After SBL execution is complete, this region can be used as per
application requirement.</p>
<ul class="simple">
<li><p><strong>Configuring entry point for SBL</strong></p></li>
</ul>
<p>The three files that help setup the entry point in the bootloader build
are “PDK_INSTALL_PATHpackagestistarterwaresocarmv7agccsbl_init.S”
and the linker command file
“PDK_INSTALL_PATHpackagestistarterwareexamplesgcc&lt;device&gt;_boot.lds”.
The global symbol Entry is used to provide the entry point to the
bootloader. The Base address of the memory section OCMCRAM (starts at 1K
offset in OCMC RAM as defined in TRM) is then used by the tiimage or
GPHEader tool to provide RBL the guidance to find the entry point to
pass control. After MLO is created check the TI image format file(
_ti.bin) to confirm that the entry point matches the location of Entry
symbol in the .map file.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The object file created by sbl_init.S should always be the first object
file in the link order for the symbol Entry to be placed at the BASE
address of the memory section SBL_MEM</p>
</div>
<ul class="simple">
<li><p><strong>Boot image creation tools generates a large boot image if load
sections are fragmented</strong></p></li>
</ul>
<p>Please note that when using objcopy the compiler generates a contiguous
binary that gets loaded by the bootloader at the location specified in
the header appended by TIIMAGE boot utility. IF you have some code
sections in OCMC or SRAM and some section in DDR the compiler will
generates a binary that spans across full memory range which would be in
order of MB or even GB size so it is recommended that you create compact
binaries that can be loaded into memory or implement a ELF parser to
bootloader memory sections that may be fragmented in the address space.
you can also load separate binaries for OCMC sections and DDR memory and
load the sections separately</p>
<ul class="simple">
<li><p><strong>Removing Heap section from application binary to speed up boot
times</strong></p></li>
</ul>
<p>A common issue reported with the ARM GCC compiler is that it appends
Heap section associated with the binary to the binary image used to
boot. The Heap section is usually filled with zeros so can cause
significant delay in boot times. Essentially the bootloader will be
writing a bunch of zeros in memory so is inefficient. Following work
around has been used to circumvent the issue</p>
<p><strong>Option 1:</strong> Eliminate the heap by using the compiler option
“–remove-section” as described in the E2E post below:</p>
<p><strong>Refer:</strong> <a class="reference external" href="https://e2e.ti.com/support/arm/sitara_arm/f/791/p/604616/2225826">E2E post to configure Heap in ARM application binary by
adding
“–remove-section”</a></p>
<p><strong>Example BIOS configuration:</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">heap1</span> <span class="o">=</span> <span class="n">HeapMem</span><span class="p">.</span><span class="n">create</span><span class="p">();</span>
<span class="n">heap1</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">256</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
<span class="n">heap1</span><span class="p">.</span><span class="n">sectionName</span> <span class="o">=</span> <span class="s">&quot;.stack&quot;</span><span class="p">;</span>
<span class="n">Memory</span><span class="p">.</span><span class="n">defaultHeapInstance</span> <span class="o">=</span> <span class="n">heap1</span><span class="p">;</span>
</pre></div>
</div>
<p><strong>Compiler Setting :</strong> –remove-section=.stack</p>
<p><strong>Option 2</strong> Configure Segment type to be “NO LOAD” in .cfg and use
excludeSections</p>
<p>SYSBIOS Memory map configurations allows user to specify the section
name, length and type. by configuring the section type to “NOLOAD” and
using excludeSection option the heap memory can be eliminated from the
final binary.</p>
<p><strong>Example BIOS configuration:</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Program</span><span class="p">.</span><span class="n">sectMap</span><span class="p">[</span><span class="s">&quot;.biosheap&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Program</span><span class="p">.</span><span class="n">SectionSpec</span><span class="p">();</span>
<span class="n">Program</span><span class="p">.</span><span class="n">sectMap</span><span class="p">[</span><span class="s">&quot;.biosheap&quot;</span><span class="p">].</span><span class="n">runSegment</span> <span class="o">=</span> <span class="s">&quot;DDR2&quot;</span>
<span class="n">Program</span><span class="p">.</span><span class="n">sectMap</span><span class="p">[</span><span class="s">&quot;.biosheap&quot;</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="s">&quot;NOLOAD&quot;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Program</span><span class="p">.</span><span class="n">sectionsExclude</span> <span class="o">=</span> <span class="s">&quot;.biosheap&quot;</span>
</pre></div>
</div>
<p>Alternate approach using linker command file:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">ddr3Heap</span> <span class="p">(</span><span class="n">NOLOAD</span><span class="p">)</span><span class="o">:</span>
  <span class="p">{</span>
      <span class="o">*</span><span class="p">(.</span><span class="n">ddr3Heap</span><span class="p">)</span>
  <span class="p">}</span> <span class="o">&gt;</span> <span class="n">HOST_DDR3</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The approach described above helps improve boot times but Users are
recommended to initialize the HEAP sections to zeros post boot during
initialization to avoid any undesired behavior during normal operation
of the app</p>
</div>
</div>
<div class="section" id="debugging-application-boot">
<h4>4.6.3.1.11. Debugging application boot<a class="headerlink" href="#debugging-application-boot" title="Permalink to this headline">¶</a></h4>
<p>Steps to debug application boot using Processor SDK RTOS bootloader are
discussed in the article <strong>`Common steps to debug application
boot &lt;index_Foundational_Components.html#common-steps-to-debug-application-boot&gt;`__</strong></p>
</div>
</div>
<div class="section" id="am57x">
<h3>4.6.3.2. AM57x<a class="headerlink" href="#am57x" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id90">
<h4>4.6.3.2.1. Overview<a class="headerlink" href="#id90" title="Permalink to this headline">¶</a></h4>
<p>The Secondary Bootloader (SBL) for AM57xx device initializes the
execution environment for multi-core application and this can be used to
demonstrate an out-of-box experience.The section covers additional
details including execution sequence, tools and additional flashing
instructions.</p>
</div>
<div class="section" id="id91">
<h4>4.6.3.2.2. Bootloader Execution Sequence<a class="headerlink" href="#id91" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><strong>Power On Reset</strong></p></li>
<li><p><strong>ROM Bootloader (RBL)</strong></p>
<ul>
<li><p>Software pre-programmed in ROM memory starts executing</p></li>
<li><p>Checks Sysboot pins and choose booting device</p></li>
<li><p>If no valid bootloader found on booting device, RBL checks for
next booting device.</p></li>
<li><p>Platform configuration and initialization.</p></li>
<li><p>Configures DPLL and clock settings for MPU, and boot media like
I2C, MMCSD, SD/MMC, SPI, QSPI, Ethernet etc for reliable boot.</p></li>
<li><p>The sequence depends on RBL execution flow and Sysboot pins.</p></li>
<li><p>RBL gets image size and load address by checking TI Image Header
appended on bootloader binary(.bin). Check binary formats.</p></li>
<li><p>Loads the binary to internal memory at the Load address fetched
from TI Image Header</p></li>
<li><p>Passes control to Secondary Bootloader(SBL)</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Detailed description of ROM bootloader is provided in Initialization
Chapter in <a class="reference external" href="http://www.ti.com/lit/pdf/spruhz6">AM57xx Technical Reference
manual</a></p>
</div>
<ul class="simple">
<li><p><strong>Secondary bootloader(SBL)</strong></p>
<ul>
<li><p>User level secondary bootloader(SBL) begins execution from
internal memory by running basic initialization routines like
setting up Stack, BSS and then jumps to main() to begin Board
Initialization.</p></li>
<li><p>Board Initialization is done by a call to <strong>Board_init()</strong> API.For
additional details refer <a class="reference external" href="index_board.html#board-support">Processor SDK Board
Support</a>.</p></li>
<li><p>It includes setting up PLLs, enabling clocks to all interfaces and
modules, performing pinmux and setting up UART console.</p></li>
<li><p>Once Board Initialization is complete, it enables clocks to the
slave cores like C66x/DSP, IPU, etc and brings them out of reset.</p></li>
<li><p>Parses Multicore Application image located in memory device and
copies it to DDR memory based on load address for different
sections.</p></li>
<li><p>Once copy is successful it transfers control to application.</p></li>
</ul>
</li>
<li><p><strong>Application then starts executing from DDR</strong>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>RBL requires boot loader to be in a special format with a header
appended to the binary image. The header shall contain the load
address of the bootloader and size of the bootloader image.</p></li>
<li><p>For more information on the TI header refer TRM document</p></li>
</ul>
</div>
</div>
<div class="section" id="directory-structure">
<h4>4.6.3.2.3. Directory structure<a class="headerlink" href="#directory-structure" title="Permalink to this headline">¶</a></h4>
<p><strong>Makefiles:</strong></p>
<ul class="simple">
<li><p><strong>PDK_INSTALL_PATH/ti/boot/sbl/board/&lt;EVAL_BOARD&gt;/build</strong>: Makefile
for bootloader that provides list of source files and library and
compiler options to create bootloader binary.</p></li>
</ul>
<p><strong>Source Files:</strong></p>
<ul class="simple">
<li><p><strong>PDK_INSTALL_PATH/ti/boot/sbl/board/&lt;EVAL_BOARD&gt;</strong>: Source to SBL
main function that consolidates all features</p></li>
<li><p><strong>PDK_INSTALL_PATH/ti/boot/sbl/soc</strong>: Source to SOC specific
initialization used in the SBL.</p></li>
<li><p><strong>PDK_INSTALL_PATH/ti/boot/sbl/src</strong>: Source to boot media specific
initialization used in the SBL.</p></li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="id92">
<h4>4.6.3.2.4. Tools and Binary Formats<a class="headerlink" href="#id92" title="Permalink to this headline">¶</a></h4>
<p>This section lists out the various tools and scripts used by SBL for
different boot modes and those required to create a bootable application
image.</p>
<p><strong>SBL/MLO image format:</strong>
To generate the <em>MLO</em>, SBL uses tiImageGen tool to prepend the sbl.bin
image with the TI header information. The image format has been
described in detail in the Image Format Section of the<a class="reference external" href="http://www.ti.com/lit/pdf/spruhz6">AM57xx
Technical Reference manual</a></p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p><strong>Application image format:</strong>
A bootable application image can be created by using the Am57xImageGen
script provided under tools folder as part of sbl. It can be located at
<em>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools/scripts</em> folder.</p>
<p>The Am57xImageGen script uses out2rprc and multicoreImageGen format
conversion tools to create the final application image. Graphical view
of the multicore application image is provided below:</p>
<img alt="../_images/Multicore_app_image.png" src="../_images/Multicore_app_image.png" />
<p>The script creates the bootable image in 2 steps</p>
<p><strong>Step 1: Conversion to RPRC format conversion</strong></p>
<ul class="simple">
<li><p>Firstly, application executable is converted from ELF/COFF format
(.out) to custom TI Rprc binary image using out2rprc tool. This tool
strips out the initialized sections from the executable file (i.e.
*.out) and places them in a compact format that the SBL can
understand. The output (bin) file is typically much smaller than the
original executable (out) file.</p></li>
<li><p>The rprc files are intermediate files in a format that is consumed by
MulticoreImageGen tool that generates the final binary.</p></li>
</ul>
<p><strong>RPRC File Header Format</strong></p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Binary value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x00000000</p></td>
<td><p><strong>Magic Word(43525052)</strong></p></td>
</tr>
<tr class="row-odd"><td><p>0x00000004</p></td>
<td><p><strong>Entry Point (Location)</strong></p></td>
</tr>
<tr class="row-even"><td><p>0x00000008</p></td>
<td><p><strong>Reserved Addr</strong></p></td>
</tr>
<tr class="row-odd"><td><p>0x0000000C</p></td>
<td><p><strong>Section Count</strong></p></td>
</tr>
<tr class="row-even"><td><p>0x00000010</p></td>
<td><p><strong>Version</strong></p></td>
</tr>
</tbody>
</table>
<p><strong>RPRC Section Header Format</strong></p>
<table class="docutils align-default">
<colgroup>
<col style="width: 31%" />
<col style="width: 69%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Binary value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x00000000</p></td>
<td><p><strong>Section start Address</strong></p></td>
</tr>
<tr class="row-odd"><td><p>0x00000004</p></td>
<td><p><strong>Reserved Addr</strong></p></td>
</tr>
<tr class="row-even"><td><p>0x00000008</p></td>
<td><p><strong>Size</strong></p></td>
</tr>
<tr class="row-odd"><td><p>0x0000000C</p></td>
<td><p><strong>Reserved CRC</strong></p></td>
</tr>
<tr class="row-even"><td><p>0x00000010</p></td>
<td><p><strong>Reserved</strong></p></td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p><strong>Step 2: Multicore Image file generation</strong></p>
<ul class="simple">
<li><p>RPRC files for each cores is combined into a single multicore
bootable application image.</p></li>
</ul>
<p><strong>Multicore boot image format</strong></p>
<p><strong>Meta Header Start</strong></p>
<table class="docutils align-default">
<colgroup>
<col style="width: 28%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Binary value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x00000000</p></td>
<td><p><strong>Magic String (0x5254534D)</strong></p></td>
</tr>
<tr class="row-odd"><td><p>0x00000004</p></td>
<td><p><strong>Number of Files</strong></p></td>
</tr>
<tr class="row-even"><td><p>0x00000008</p></td>
<td><p><strong>Device ID</strong></p></td>
</tr>
<tr class="row-odd"><td><p>0x0000000C</p></td>
<td><p><strong>Reserved</strong></p></td>
</tr>
</tbody>
</table>
<p><strong>Meta Header per Core</strong></p>
<table class="docutils align-default">
<colgroup>
<col style="width: 40%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Binary value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x00000000</p></td>
<td><p><strong>Core ID</strong></p></td>
</tr>
<tr class="row-odd"><td><p>0x00000004</p></td>
<td><p><strong>Image Offset</strong></p></td>
</tr>
</tbody>
</table>
<p>Core ID and Device ID for specific devices can be located in the file
sbl_slave_core_boot.h in the boot/sbl/soc/&lt;SOC_NAME&gt; folder</p>
<p>Refer section <a class="reference external" href="index_Foundational_Components.html#application-image-creation">App Image
Creation</a>
for more details on usage of this script and application image creation.</p>
<p><strong>Flashing Tools</strong></p>
<p>SBL provides a CCS based qspi flash writer utility to flash image and
multicore AppImage from a SD card to onboard QSPI device. It
is located at <em>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools/flashWriter/qspi</em></p>
</div>
<div class="section" id="building-the-sbl">
<h4>4.6.3.2.5. Building the SBL<a class="headerlink" href="#building-the-sbl" title="Permalink to this headline">¶</a></h4>
<p><strong>Pre-requisites to Building</strong></p>
<ul class="simple">
<li><p>Set your environment using pdksetupenv.bat or pdksetupenv.sh. Refer
to the Processor SDK RTOS Building page for information on setting up
your build environment</p></li>
<li><p>The SBL has following dependencies and will need the following
libraries built</p>
<ul>
<li><p>Board</p></li>
<li><p>UART</p></li>
<li><p>I2C</p></li>
<li><p>SPI</p></li>
<li><p>CSL</p></li>
<li><p>OSAL</p></li>
<li><p>MMCSD</p></li>
<li><p>PM</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Refer to the makefile for the board you are using for the latest driver
dependency. These libraries should come pre-built with any fresh
installation of the Processor SDK RTOS but may be removed if a gmake
clean is invoked</p>
</div>
<p><strong>Compiling the SBL Components</strong></p>
<p>To build the SBL components:</p>
<ol class="arabic simple">
<li><p><strong>cd &lt;PDK&gt;/packages/ti/board/diag</strong></p></li>
<li><p><strong>make all BOARD=&lt;BOARD_NAME&gt; SOC=&lt;SOC_NAME&gt; BOOTMODE=&lt;BOOTMEDIA&gt;</strong></p></li>
</ol>
<ul class="simple">
<li><p>BOARD_NAME : idkAM572x, idkAM571x, evmAM572x, idkAM574x</p></li>
<li><p>SOC_NAME : AM572x, AM571x, AM574x</p></li>
</ul>
<p>This will make the SBL for a specific $BOARD and $BOOT_MEDIA. Output
files will be located in: <strong>&lt;PDK&gt;/packages/ti/boot/sbl/binary/&lt;BOARD&gt;</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Refer <strong>&lt;PDK&gt;/packages/ti/boot/sbl/sbl_&lt;DEVICE&gt;.sh</strong> for more build
options</p>
</div>
<p class="rubric" id="id93">Boot Modes</p>
<p>This Release of SBL supports MMCSD and QSPI Boot modes. The different
boot modes supported for all the boards is tabulated in the table below.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 53%" />
<col style="width: 19%" />
<col style="width: 14%" />
<col style="width: 14%" />
</colgroup>
<tbody>
<tr class="row-odd"><td></td>
<td><p>MMCSD</p></td>
<td><p>QSPI</p></td>
<td><p>eMMC</p></td>
</tr>
<tr class="row-even"><td><p>AM572x GPEVM</p></td>
<td><p>YES</p></td>
<td><p>NO</p></td>
<td><p>YES</p></td>
</tr>
<tr class="row-odd"><td><p>AM572x IDKEVM</p></td>
<td><p>YES</p></td>
<td><p>YES</p></td>
<td><p>NO</p></td>
</tr>
<tr class="row-even"><td><p>AM571x IDKEVM</p></td>
<td><p>YES</p></td>
<td><p>YES</p></td>
<td><p>NO</p></td>
</tr>
<tr class="row-odd"><td><p>AM574x IDKEVM</p></td>
<td><p>YES</p></td>
<td><p>YES</p></td>
<td><p>NO</p></td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="section" id="id94">
<h5>4.6.3.2.5.1. Booting Via SD Card<a class="headerlink" href="#id94" title="Permalink to this headline">¶</a></h5>
<ol class="arabic simple">
<li><p>Preparing the SD card.</p></li>
<li><p>Booting the target.</p></li>
</ol>
<div class="section" id="preparing-the-sd-card">
<h6>4.6.3.2.5.1.1. Preparing the SD card<a class="headerlink" href="#preparing-the-sd-card" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li><p>To boot the target the SD card should be bootable. Follow the steps
at <a class="reference external" href="index_overview.html#windows-sd-card-creation-guide">Creating bootable SD card in windows</a>
or <a class="reference external" href="index_overview.html#linux-sd-card-creation-guide">Creating bootable SD card in Linux</a>.</p></li>
<li><p>Delete the “MLO” and “app” in the bootable SD card which are created
in the process of making the SD bootable.</p></li>
<li><p>Copy the sbl binary(MLO) to the SD card.</p></li>
<li><p>Copy the Application image(app) generated using the
<a class="reference external" href="index_Foundational_Components.html#application-image-creation">Script</a>
to the SD card.</p></li>
</ol>
</div>
<div class="section" id="id95">
<h6>4.6.3.2.5.1.2. Booting the target<a class="headerlink" href="#id95" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li><p>Insert micro SD card into the SD card slot of the board.</p></li>
<li><p>Open a serial communication terminal like TeraTerm, MiniCom on host
PC and connect to the UART console port</p></li>
<li><p>Do a power reset of the board to boot the appliation from the SD
card.</p></li>
</ol>
</div>
</div>
<div class="section" id="booting-via-emmc">
<h5>4.6.3.2.5.2. Booting Via eMMC<a class="headerlink" href="#booting-via-emmc" title="Permalink to this headline">¶</a></h5>
<ol class="arabic simple">
<li><p>Preparing the eMMC.</p></li>
<li><p>Booting the target.</p></li>
</ol>
<div class="section" id="preparing-the-emmc">
<h6>4.6.3.2.5.2.1. Preparing the eMMC<a class="headerlink" href="#preparing-the-emmc" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li><p>To format the eMMC of the target board, Run the following application on the target board
<a class="reference external" href="Device_Drivers.html#id6">USB_DevMsc_mmcsd</a> .</p></li>
<li><p>To boot the target the eMMC should be bootable. Follow the steps same as SD card
formatting as given
at <a class="reference external" href="Overview.html#windows-sd-card-creation-guide">Creating bootable SD card in windows</a>
or <a class="reference external" href="Overview.html#linux-sd-card-creation-guide">Creating bootable SD card in Linux</a>
except instead of SD card, connect the target board eMMC to the host PC.</p></li>
<li><p>Delete the “MLO” and “app” in the bootable eMMC which are created
in the process of making the eMMC bootable.</p></li>
<li><p>Copy the sbl binary(MLO) to the eMMC.</p></li>
<li><p>Copy the Application image(app) generated using the
<a class="reference external" href="Foundational_Components.html#application-image-creation">Script</a>
to the eMMC.</p></li>
</ol>
</div>
<div class="section" id="id96">
<h6>4.6.3.2.5.2.2. Booting the target<a class="headerlink" href="#id96" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li><p>Set boot settings to eMMC by selecting J3, J4 and J6 jumpers on Pin 2 and 3
of AM572x EVM Board.</p></li>
<li><p>Ensure there is no SD card inserted in the SD card slot.</p></li>
<li><p>Open a serial communication terminal like TeraTerm, MiniCom on host
PC and connect to the UART console port</p></li>
<li><p>Do a power reset of the board to boot the appliation from the eMMC.</p></li>
</ol>
</div>
</div>
<div class="section" id="id97">
<h5>4.6.3.2.5.3. Booting Via QSPI<a class="headerlink" href="#id97" title="Permalink to this headline">¶</a></h5>
<p>Booting from QSPI flash involves two steps-</p>
<ol class="arabic simple">
<li><p>Flashing bootloader and app image to QSPI flash.</p></li>
<li><p>Booting the target.</p></li>
</ol>
<div class="section" id="id98">
<h6>4.6.3.2.5.3.1. Preparing Flash Device<a class="headerlink" href="#id98" title="Permalink to this headline">¶</a></h6>
<p>Use the CCS based qspi_flash_writer.out utility provided in
&lt;<em>TI_PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools/flashwriter/qspi/&lt;Board&gt;’</em>
to flash the SBL image at offset 0 and application image at offset
0x80000 to the QSPI device.</p>
<p>QSPI device Memory Map:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 36%" />
<col style="width: 64%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Offset 0x00</p></td>
<td><p>SBL</p></td>
</tr>
<tr class="row-even"><td><p>Offset 0x80000</p></td>
<td><p>Application Multicore Image</p></td>
</tr>
</tbody>
</table>
<p>The images can be flashed into QSPI flash by following steps given
below.</p>
<ol class="arabic simple">
<li><p>Copy QSPI mode SBL image
<em>TI_PDK_INSTALL_DIRpackagestibootsblbinary&lt;BoardName&gt;qspibinMLO</em>
and application image(app) generated using the Script into the SD
card.
Rename the bootloader file to ‘boot’ and application image to ‘app’
with no extensions.</p></li>
<li><p>Copy ‘config’ file into the SD card, the config file should contain
names of the image to be flashed and the offset.
A sample config file can be found at
<em>TI_PDK_INSTALL_DIRpackagestibootsbltoolsflashWriterqspiconfig</em>.
Do not change the name of the config file.
<strong>NOTE:</strong> “config” file can be used without any modifications if
bootloader and application images are renamed to “boot” and “app”.
<strong>NOTE:</strong> Do not rename the bootloader to be copied to SD card as
“MLO”, as MMCSD bootloader expects “MLO” and “app” to boot.</p></li>
<li><p>Now SD card contains 3 files 1)boot 2)app 3)config files.
config file contains the address of boot image as 0x0 and app image
as 0x80000.
Insert it into the SD card slot.</p></li>
<li><p>Connect the board with CCS and and load the prebuilt qspi flash
writer application from
$(TI_PDK_INSTALL_DIR)packagestibootsbltoolsflashWriterqspibin&lt;BoardName&gt;\</p></li>
<li><p>Run the QSPI flash writer application. You will see the following
logs on the EVM’s UART console.</p></li>
<li><p>After the images have been flashed to the QSPI device disconnect from
CCS and do a power reset to boot from the QSPI memory.</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">PDK</span> <span class="n">QSPI</span> <span class="n">Flash</span> <span class="n">Writer</span><span class="o">!!</span>
<span class="n">Copying</span> <span class="n">boot</span> <span class="n">to</span> <span class="n">QSPI</span> <span class="n">Flash</span>
<span class="n">Copying</span> <span class="n">app</span> <span class="n">to</span> <span class="n">QSPI</span> <span class="n">Flash</span>
<span class="n">Changing</span> <span class="n">read</span> <span class="n">to</span> <span class="n">quad</span> <span class="n">mode</span>
<span class="n">Read</span> <span class="n">mode</span> <span class="n">has</span> <span class="n">been</span> <span class="n">changed</span> <span class="n">to</span> <span class="n">Quad</span> <span class="n">mode</span>
<span class="n">SUCCESS</span><span class="o">!!!</span>
<span class="n">Flashing</span> <span class="n">completed</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>The file names have to be renamed in such a way that the length of
name is less than 9 characters. Any file name less than 9 characters
can be used.</p></li>
<li><p>This application will flash the image at required offset without
taking into consideration any overwriting to previously flashed
image.</p></li>
<li><p>It is the responsibility of the user to provide proper offsets.</p></li>
</ul>
</div>
</div>
</div>
</div>
<div class="section" id="id99">
<h4>4.6.3.2.6. Test Application<a class="headerlink" href="#id99" title="Permalink to this headline">¶</a></h4>
<p>SBL provides a test application to demonstrate booting of multicore
application image on A15 and DSP cores.The multicore sample
application uses mailbox for inter-processor communication. It is used
to validate the multi-core boot-up use case.</p>
<p>Master application sends wake-up message to the DSP slave cores &amp; waits
for acknowledgement message from the slave cores in an infinite
loop.Each slave DSP core waits for wake-up message from the master core
responds back with an acknowledgement message.</p>
<div class="section" id="application-image-creation">
<h5>4.6.3.2.6.1. Application Image Creation<a class="headerlink" href="#application-image-creation" title="Permalink to this headline">¶</a></h5>
<p>Application Image creation involves two steps.</p>
<ol class="arabic simple">
<li><p>Generating the .outs of applications for individual cores</p></li>
<li><p>Combining the .outs of individual cores to create a bootable
multicore image</p></li>
</ol>
<p>The steps to create the bootable image in Linux and Windows environment
are listed below.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Valid SOC settings are AM571x/AM572x</p></li>
<li><p>Valid BOARD settings are evmAM572x/idkAM571x/idkAM572x</p></li>
</ul>
</div>
</div>
<div class="section" id="linux-environment">
<h5>4.6.3.2.6.2. Linux Environment<a class="headerlink" href="#linux-environment" title="Permalink to this headline">¶</a></h5>
<p>Command to build the test application.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>Go to cd (TI_PDK_INSTALL_DIR)\packages\ti\boot\sbl

make example BOARD=&lt;BOARD&gt; SOC=&lt;SOC&gt; to build the application
make example_clean BOARD=&lt;BOARD&gt;
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">example</span> <span class="n">BOARD</span><span class="o">=</span><span class="n">idkAM572x</span> <span class="n">SOC</span><span class="o">=</span><span class="n">AM572x</span>
</pre></div>
</div>
<p>To create the final bootable application image use the AM57xImageGen
script and follow these steps</p>
<p>1. Set the following environment variable in the shell.  BIN_PATH:
Pointing to the path where the AppImage needs to be generated</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>Ex: export BIN_PATH=$(TI_PDK_INSTALL_DIR)/packages/ti/boot/sbl/binary
</pre></div>
</div>
<p>2. Edit the script file to point to the application elf files by setting
the input application variables.</p>
<p>App_MPU_CPU0: Point to the path where the application .out for A15 MPU is located
App_DSP1: Point to the path where the dsp core 1 application is located
App_DSP2: Point to the path where the dsp core 2 application is located</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>export APP_MPU_CPU0=$(TI_PDK_INSTALL_DIR)/packages/ti/boot/sbl/binary/idkAM572x/example/armv7/bin/sbl_app.out

export APP_DSP1=$(TI_PDK_INSTALL_DIR)/packages/ti/boot/sbl/binary/idkAM572x/example/c66/dsp1/bin/sbl_app.xe66

export APP_DSP2=$(TI_PDK_INSTALL_DIR)/packages/ti/boot/sbl/binary/idkAM572x/example/c66/dsp2/bin/sbl_app.xe663

export APP_IPU1_CPU0=$(TI_PDK_INSTALL_DIR)/packages/ti/boot/sbl/binary/idkAM572x/example/m4/ipu1/bin/sbl_app.xem4

export APP_IPU1_CPU0=$(TI_PDK_INSTALL_DIR)/packages/ti/boot/sbl/binary/idkAM572x/example/m4/ipu2/bin/sbl_app.xem4
</pre></div>
</div>
<p>3. If it is not required to load an application on specific core leave
the variable blank.</p>
<ol class="arabic simple" start="4">
<li><p>Run the script file AM57xImageGen found under the path $(TI_PDK_INSTALL_DIR)/packages/ti/boot/sbl/tools/scripts</p></li>
</ol>
<p>5. An application image by name app is created in the path pointed by
BIN_PATH variable</p>
<p>6. Copy the Bootlaoder image(MLO) and application(app) in the SD card to
boot using MMCSD boot mode.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>The AM57xImageGen.sh script depends on tools like mono to execute the
out2rprc.exe.</p></li>
<li><p>The linux host environment needs to have this tool installed to
execute this script.</p></li>
<li><p>Refer this link to download the
<a class="reference external" href="http://www.mono-project.com">mono</a> tool</p></li>
</ul>
</div>
</div>
<div class="section" id="windows-environment">
<h5>4.6.3.2.6.3. Windows environment<a class="headerlink" href="#windows-environment" title="Permalink to this headline">¶</a></h5>
<p>Command to build the test application.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>Go to cd (TI_PDK_INSTALL_DIR)\packages\ti\boot\sbl

gmake example BOARD=&lt;BOARD&gt; SOC=&lt;SOC&gt; to build the application
gmake example_clean BOARD=&lt;BOARD&gt;
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">gmake</span> <span class="n">example</span> <span class="n">BOARD</span><span class="o">=</span><span class="n">idkAM572x</span> <span class="n">SOC</span><span class="o">=</span><span class="n">AM572x</span>
</pre></div>
</div>
<p>To create the final bootable application image use the AM57xImageGen
script and follow these steps</p>
<ol class="arabic simple">
<li><p>Set the following environment variable in windows command prompt</p></li>
</ol>
<p>BIN_PATH: Pointing to the path where the AppImage needs to be generated</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>Ex:  set BIN_PATH=%TI_PDK_INSTALL_DIR%\packages\ti\boot\sbl\binary
</pre></div>
</div>
<p>2. Edit the batch file to point to the application elf files by setting
the input application variables.</p>
<p>App_MPU_CPU0: Point to the path where the application .out for A15 MPU is located
App_DSP1: Point to the path where the dsp core 1 application is located
App_DSP2: Point to the path where the dsp core 2 application is located</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>set App_MPU_CPU0=%TI_PDK_INSTALL_DIR%\packages\ti\boot\sbl\binary\idkAM572x\example\armv7\bin\sbl_app.out

set App_DSP1=%TI_PDK_INSTALL_DIR%\packages\ti\boot\sbl\binary\idkAM572x\example\c66\dsp1\bin\sbl_app.xe66

set App_DSP2=%TI_PDK_INSTALL_DIR%\packages\ti\boot\sbl\binary\idkAM572x\example\c66\dsp2\bin\sbl_app.xe66

set App_IPU1_CPU0=%TI_PDK_INSTALL_DIR%\packages\ti\boot\sbl\binary\idkAM572x\example\m4\ipu1\bin\sbl_app.xem4

set App_IPU2_CPU0=%TI_PDK_INSTALL_DIR%\packages\ti\boot\sbl\binary\idkAM572x\example\m4\ipu2\bin\sbl_app.xem4
</pre></div>
</div>
<p>3. If it is not required to load an application on specific core leave
the variable blank.</p>
<ol class="arabic simple" start="4">
<li><p>Run the batch file AM57xImageGen found under the path $(TI_PDK_INSTALL_DIR)/packages/ti/boot/sbl/tools/scripts</p></li>
</ol>
<p>5. Follow the steps 4 to 6 listed above for Linux environment.
|
Setup Requirements
“”””””””””””””””””””
For information on board specific requirements like power supply, UART
console port connections refer the Hardware User guide of the respective
boards.</p>
<p>The configurations needed to setup UART console through a serial
terminal application on host PC are listed in the next section.</p>
<div class="section" id="uart-console-setup">
<h6>4.6.3.2.6.3.1. UART Console Setup<a class="headerlink" href="#uart-console-setup" title="Permalink to this headline">¶</a></h6>
<p>PDK SBL prints messages on the UART Serial Console running on the host.
Hence, a serial terminal application (like Tera
Term/HyperTerminal/minicom) should be running on the host.</p>
<p>The host serial port must be configured at 115200 baud, no parity, 1
stop bit and no flow control.
Please ensure that the local echo setting for the terminal is turned off.</p>
</div>
<div class="section" id="loading-the-test-application">
<h6>4.6.3.2.6.3.2. Loading the test application<a class="headerlink" href="#loading-the-test-application" title="Permalink to this headline">¶</a></h6>
<p>Follow these steps to load the test application using a SD card on the
target</p>
<p>copy the MLO to your SD card (located
at %TI_PDK_INSTALL_DIR%packagestibootsblbinary[BOARD]mmcsd)</p>
<ol class="arabic simple">
<li><p>copy the example app located at path pointed to by BIN_PATH to your
SD card</p></li>
<li><p>insert your SD card into your board and power on your board</p></li>
<li><p>open teraterm to connect to the board’s UART console</p></li>
<li><p>press the “Hard Reset” button on your board</p></li>
</ol>
<p>On Successful bootup you should see the following logs on the UART
console for a AM572x based board.</p>
<img alt="../_images/Sbl_example.jpg" src="../_images/Sbl_example.jpg" />
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>MPU Core 0 example does a sequential check of mailbox messages sent from
the other cores. On rare occasions, the check happens before the message
is sent - the “&lt;core&gt; boot-up Successful” message might not be displayed
even though the core(s) were booted successfully.</p>
</div>
</div>
</div>
</div>
<div class="section" id="application-integration">
<h4>4.6.3.2.7. Application Integration<a class="headerlink" href="#application-integration" title="Permalink to this headline">¶</a></h4>
<div class="section" id="memory-map">
<h5>4.6.3.2.7.1. Memory Map<a class="headerlink" href="#memory-map" title="Permalink to this headline">¶</a></h5>
<p>Table indicated below provides memory map details for SBL image in
OCMC_RAM1.  For more details on pinmux and IO delay requirements refer
this link <a class="reference external" href="index_board.html#board-support">Processor SDK Board
Support</a></p>
<p>We recommend that users should refer to the linker command file and the
map file for the boot loader to check for latest information on the
memory utilization in the boot loader.</p>
<p><strong>Location of linker command file</strong>:
&lt;PDK_INSTALL_PATH&gt;packagestibootsblboard&lt;BOARD&gt;build</p>
<p>The SBL memory map is shown below</p>
<img alt="../_images/SBL_memory_map.png" src="../_images/SBL_memory_map.png" />
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>After the application boots and is running on the SOC, it is free to
use the SBL_MEM region.</p></li>
<li><p>The pinmux data from the board library and MMU Table are part of the
SBL_MEM region indicated in the figure above. If pinmux data needs to
be placed at a specific location then users can update the SBL linker
command file to add the BOARD_IO_DELAY_CODE and BOARD_IO_DELAY_DATA
as described in <a class="reference external" href="index_board.html#application-integration-for-am5x-dra7xx">Application Integration of board library for
AM5x</a></p></li>
</ul>
</div>
</div>
</div>
<div class="section" id="sbl-customization">
<h4>4.6.3.2.8. SBL Customization<a class="headerlink" href="#sbl-customization" title="Permalink to this headline">¶</a></h4>
<div class="section" id="changing-boot-media-offsets">
<h5>4.6.3.2.8.1. Changing boot media offsets<a class="headerlink" href="#changing-boot-media-offsets" title="Permalink to this headline">¶</a></h5>
<p>The location at which SBL resides on the flash is predefined by the ROM
bootloader spec and so these defaults can`t be changed. However the SBL
is a user defined bootloader so many of the defaults can easily be
modified to meet application requirements. For example the flash offset
location from which the bootloader reads the application is configured
in the source files located under
PDK_INSTALL_PATHpackagestibootsblsrc&lt;BOOT_MEDIA&gt;</p>
<p>Examples of customization that can be changed:
-  QSPI/SPI flash offsets: These offsets are configured in sbl_qspi.c</p>
<blockquote>
<div><p>and sbl_spi.c</p>
</div></blockquote>
<ul class="simple">
<li><p>MMCSD: The name of the application is hard coded as app in function
SBL_MMCBootImage in the sbl_mmcsd.c</p></li>
</ul>
</div>
<div class="section" id="speeding-up-boot-by-increasing-speed-of-the-boot-interface">
<h5>4.6.3.2.8.2. Speeding up boot by increasing speed of the boot interface<a class="headerlink" href="#speeding-up-boot-by-increasing-speed-of-the-boot-interface" title="Permalink to this headline">¶</a></h5>
<p>The SBL for AM57xx devices uses LLD drivers to read and write from boot
media supported. The SBL uses the default SOC configuration of the
drivers and the speeds setup. For example, the SPI driver default SPI
bitrate is 1 MHz (Refer
PDK_INSTALL_PATHpackagestidrvspisrcSPI_drv.c) so if you wish to
speed up boot you can update the SPI parameter in the SBL as shown
below:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">SPI_Params_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spiParams</span><span class="p">);</span>
<span class="n">spiParams</span><span class="p">.</span><span class="n">bitRate</span> <span class="o">=</span> <span class="mi">24000000U</span><span class="p">;</span>
</pre></div>
</div>
<p>The configuration of the driver is usually done in the
boot/sbl/soc/&lt;device&gt;/sbl_soc.c file.</p>
<ul class="simple">
<li><p><strong>For SD/MMC</strong>: You can configure higher speed and change bus width
using MMCSD_v1_HwAttrs_s or MMCSD_v0_HwAttrs_s</p></li>
<li><p><strong>For QSPI</strong>: 2 pin and 4 pin mode, and input frequency is configured
using QSPI_HwAttrs in the QSPI driver. Check driver for defaults.</p></li>
</ul>
<p>Also, check to see if the CACHE and MMU settings for the ARM core are
setup to enable fast boot.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>SYSBOOT settings for AM57xx</strong></p>
<p>The SYSBOOT configuration in your hardware using Sitara devices
(AM3/AM4/AM5) can play a big role in the time required to boot
successfully. On these devices the boot pins configure a boot sequence
for the ROM bootloader to check for valid boot image so if you have a
preferred boot mode designers are required to use SYSBOOT setup such
that the preferred boot media is first in the boot sequence. If the
preferred boot media occurs later boot sequence, the boot is likely to
add the time required by RBL to check other boot media for an valid
image. For example if QSPI is the preferred boot media on your AM57xx
hardware then you should have system configure SYSBOOT to boot of QSPI
first using SYSBOOT setting for QSPI_1 or QSPI4 for Memory preferred
booting or Production booting (Refer: Initialization chapter in
TRM).Incorrect SYSBOOT configuration can causes long delays especially
if peripheral boot is configured to be one of the preferred boot modes
in the boot order</p>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="reducing-size-of-sbl-and-application">
<h5>4.6.3.2.8.3. Reducing size of SBL and application<a class="headerlink" href="#reducing-size-of-sbl-and-application" title="Permalink to this headline">¶</a></h5>
<p>Another way to optimize boot times is to reduce the size of the binary
that needs to be loaded by the bootloader by building the app with
optimization for code size using -Os (GNU GCC) and for -O&lt;level&gt; when
using TI compilers.</p>
<p>Other than compiler based optimizations developers can actively shutdown
non-essential modules and features to reduce code size. For example if
UART logging is not required or DDR memory is not connected in the
system, the initialization functions can be removed to reduce code size.</p>
</div>
</div>
<div class="section" id="id100">
<h4>4.6.3.2.9. Usage Notes<a class="headerlink" href="#id100" title="Permalink to this headline">¶</a></h4>
<div class="section" id="sbl-avs-and-abb-setup">
<h5>4.6.3.2.9.1. SBL AVS and ABB setup<a class="headerlink" href="#sbl-avs-and-abb-setup" title="Permalink to this headline">¶</a></h5>
<p>AVS and ABB configuration is mandated for normal operation of AM57xx
devices. All Processor SDK RTOS releases v3.3 and later contain SBL that
sets up AVS and ABB configuration features using PM LLD APIs The
complete details of PMIC configuration and AVS and ABB configuration
required by the chip for different OPP has been implemented in the file:</p>
<p>PDK_INSTALL_PATHpackagestibootsblboardsrcsbl_avs_config.c If you
are using the same PMIC as GP EVM or IDK platform then you can reuse the
settings as is in SBL for your custom platform</p>
</div>
<div class="section" id="configuring-entry-point-for-sbl">
<h5>4.6.3.2.9.2. Configuring entry point for SBL<a class="headerlink" href="#configuring-entry-point-for-sbl" title="Permalink to this headline">¶</a></h5>
<p>The two key files that help setup the entry point in the SBL build are
“sbl/soc/&lt;SOC_NAME&gt;/sbl_init.S” and the linker command file
“sbl/soc/&lt;SOC_NAME&gt;/linker.cmd”. The global symbol Entry is used to
provide the entry point to the SBL. The Base address of the memory
section SBL_MEM is then used by the tiimage and GP Header tool to
provide RBL the guidance to find the entry point to pass control. After
MLO is created check the TI image format file(MLO or _ti.bin) or the GP
Header file to confirm that the entry point matches the location of
Entry symbol in the sbl.map</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The object file created by sbl_init.S should always be the first object
file in the link order for the symbol Entry to be placed at the BASE
address of the memory section SBL_MEM</p>
</div>
</div>
<div class="section" id="id101">
<h5>4.6.3.2.9.3. Debugging application boot<a class="headerlink" href="#id101" title="Permalink to this headline">¶</a></h5>
<p>Steps to debug application boot using Processor SDK RTOS bootloader are
discussed in the article <a class="reference external" href="index_Foundational_Components.html#common-steps-to-debug-application-boot">Common steps to debug application
boot</a></p>
</div>
</div>
</div>
<div class="section" id="am65x-j721e">
<h3>4.6.3.3. AM65x/J721E<a class="headerlink" href="#am65x-j721e" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id102">
<h4>4.6.3.3.1. Overview<a class="headerlink" href="#id102" title="Permalink to this headline">¶</a></h4>
<p>The Secondary Bootloader (SBL) for AM65xx/J721E device initializes the execution
environment for multi-core applications and this can be used to demonstrate
a real world product experience. This section covers additional details
including execution sequence, tools and additional flashing instructions.</p>
<p>The SBL is essentially a baremetal application, and it uses many components
from the Processor SDK</p>
<ul class="simple">
<li><p>&lt;PDK&gt;/packages/ti/build : For  build infrastructure</p></li>
<li><p>&lt;PDK&gt;/packages/ti/csl : For initialization and SoC addresses</p></li>
<li><p>&lt;PDK&gt;/packages/ti/board : For board and usecase specific initialization</p></li>
<li><p>&lt;PDK&gt;/packages/ti/drv/spi :  For reading applications from OSPI flashes</p></li>
<li><p>&lt;PDK&gt;/packages/ti/drv/udma :  For reading data from boot media using DMA</p></li>
<li><p>&lt;PDK&gt;/packages/ti/drv/mmcsd : For reading applications from MMC/SD/eMMC</p></li>
<li><p>&lt;PDK&gt;/packages/ti/fs/fatfs : For reading files from MMC/SD/eMMC</p></li>
<li><p>&lt;PDK&gt;/packages/ti/drv/sciclient : For communicating with DMSC sub-system</p></li>
<li><p>&lt;PDK&gt;/packages/ti/drv/uart : For log messages</p></li>
<li><p>&lt;PDK&gt;/packages/ti/osal : Primitives required by ti/drv components</p></li>
</ul>
<p>The SBL is in turn used by the board framework to load and start diagnostics</p>
<p class="rubric" id="id103">Bootloader Execution Sequence</p>
<ul class="simple">
<li><p><strong>Power On Reset</strong></p></li>
<li><p><strong>ROM Bootloader (RBL)</strong></p>
<ul>
<li><p>Software pre-programmed in AM65xx/J721E ROM memory starts executing</p></li>
<li><p>The RBL performs platform configuration and initialization.</p></li>
<li><p>It then checks sysboot pins and chooses booting device</p></li>
<li><p>The RBL then configures PLL and clock settings for R5, and
boot media like eMMC, SD/MMC, OSPI, UART, PCIe, Ethernet etc for reliable
boot.</p></li>
<li><p>If no valid bootloader found on booting device, the RBL checks for next
booting device, based on sysboot pins</p></li>
<li><p>It then gets image size and load address by checking the X.509 certificate that
is part of the bootloader image.</p></li>
<li><p>The RBL then verifies, optionally decrypts and loads the binary to internal
memory at the load address specified in the X.509 certificate.</p></li>
<li><p>Finally it resets the R5 and passes control to Secondary Bootloader(SBL) running on the R5.</p></li>
</ul>
</li>
<li><p><strong>Secondary bootloader(SBL)</strong></p>
<ul>
<li><p>User level secondary bootloader(SBL) begins execution from internal memory.
It enables ATCM, starts PMU timers for profiling, initializes the MCU,
and sets up the stack, heap and globals. It then jumps to main().</p></li>
<li><p>Board Initialization is done by calls to <strong>Board_init()</strong> API.For additional
details refer <a class="reference external" href="http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/Board_EVM_Abstration.html">Processor SDK Board Support</a>.</p></li>
<li><p>The RAT is setup. Pin MUX and UART console are setup by calling <strong>Board_init()</strong> API. The
system firmware (SYSFW) is then loaded from the boot media into the DMSC subsystem.</p></li>
<li><p>Once the SYSFW is up and running, the rest of the initialization can be done.</p></li>
<li><p>This includes optionally using <strong>Board_init()</strong> to configure PLLs, LPSCs and DDR.</p></li>
<li><p>The SBL then loads the application from the boot media. If the image is signed, the
application will be copied into a user specified reserved memory, and the SBL will attempt
to verify the image by calling system firmware APIs. On HS devices, the boot proceeds
only if image verification passes.</p></li>
<li><p>The SBL parses application image(s) for each of the core(s) from boot
media and scatter loads it to memory.</p></li>
<li><p>Once the application is loaded, the SBL communicates with the system firmware
to setup the clocks for the core(s) and release it from reset.</p></li>
<li><p>The core then starts executing from application entry point.</p></li>
</ul>
</li>
</ul>
<div
style="margin: 5px; padding: 2px 10px; background-color: #ecffff; border-left: 5px solid #3399ff;"><p><strong>NOTE</strong></p>
<ul class="simple">
<li><p>RBL requires boot loader (SBL) to be in a special format with the binary image
appended to a X.509 certificate. The certificate contains the load address, size
and SHA of the bootloader image.</p></li>
<li><p>For a detailed description of ROM bootloader and more information on the image
format expected by the RBL refer the initialization chapter in the <a class="reference external" href="http://www.ti.com/lit/pdf/spruid7">AM65xx Technical
Reference Manual</a> and the <a class="reference external" href="http://www.ti.com/lit/pdf/spruil1">J721E Technical
Reference Manual</a></p></li>
<li><p>In addition to the bootloader and application, the DMSC firmware binary is also needed
for the SoC to complete the system boot flow.</p></li>
<li><p>The first 256 bytes of the ATCM are reserved by SBL for its use. The SBL initializes
the ATCM with 0xFF before it uses it.</p></li>
<li><p>If the multicore application image is also signed with a X.509 certificate, the same
binary can be used on GP and HS devices. For information on the application’s X.509
certificate format, please refer <a class="reference external" href="http://downloads.ti.com/tisci/esd/latest/2_tisci_msgs/security/sec_cert_format.html#security-x509-certificate-documentation">Security X509 Certificate Documentation</a></p></li>
<li><p>When the R5 is released from reset, it will always fetch and execute the first
intruction from address 0x0.</p></li>
</ul>
</div></div>
<div class="section" id="block-diagram">
<span id="am655x-sbl-high-level-arch"></span><h4>4.6.3.3.2. Block Diagram<a class="headerlink" href="#block-diagram" title="Permalink to this headline">¶</a></h4>
<img alt="../_images/k3_sbl_arch_block_diag.png" src="../_images/k3_sbl_arch_block_diag.png" />
</div>
<div class="section" id="am655x-sbl-memory-usage">
<span id="id104"></span><h4>4.6.3.3.3. Memory Map<a class="headerlink" href="#am655x-sbl-memory-usage" title="Permalink to this headline">¶</a></h4>
<img alt="../_images/k3_sbl_mem_usage.png" src="../_images/k3_sbl_mem_usage.png" />
</div>
<div class="section" id="am655x-sbl-directory-structure">
<span id="id105"></span><h4>4.6.3.3.4. Directory structure<a class="headerlink" href="#am655x-sbl-directory-structure" title="Permalink to this headline">¶</a></h4>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>sbl
│
├── board
│   └── k3
│       └── sbl_main.c                                      &lt;= define main() for SBL, board specific init
│
├── build
│   ├── makefile                                            &lt;= makefile for the SBL component
│   ├── sbl_am65xx.sh                                       &lt;= For legacy, called by Yocto build
│   ├── sbl_boot_test.mk                                    &lt;= Builds SBL single core tests
│   ├── sbl_smp_test.mk                                     &lt;= Builds example app for using SBL lib
│   ├── sbl_mcu0_boot_perf_test.mk                          &lt;= Builds example app for SBL performance tuning
│   ├── sbl_mcu0_boot_xip_entry.mk                          &lt;= Builds example trampoline app to demonstrate transitioning to a XIP app from SBL
│   ├── sbl_mcu0_boot_xip_test.mk                           &lt;= Builds example app to demonstrate XIP execution from XIP capable boot media
│   ├── sbl_img.mk                                          &lt;= builds SBL image that is loaded and executed by ROM code
│   ├── sbl_lib.mk                                          &lt;= Builds sbl library that other apps can link into
│   ├── sbl_multicore_smp.mk                                &lt;= Builds multi-core image from SBL lib eg. test to demonstrate symmetric multiprocessor boot (SMP)
│   └── sbl_multicore_amp.mk                                &lt;= Builds multi-core image from single core tests to demonstrate asymmetric multiprocessor boot (AMP)
│
├── example
│   └── k3MulticoreApp
│       ├── binary
│       │   └── [soc]
│       │       ├── sbl_baremetal_*.appimage                &lt;= SBL loadable board specific sample apps for testing SBL boot flow on GP devices
│       │       ├── sbl_baremetal_*.appimage.signed         &lt;= SBL loadable board specific signed sample apps for testing SBL boot flow on HS devices
│       │       └── sbl_baremetal_*_release.x*.bin          &lt;= Binary image that can be eXecuted In Place on XIP capable boot media
│       ├── mcuAmplinker.lds                                &lt;= Linker comamnd file when TI CGT is used for Asym. Multiproc. boot
│       ├── mpuAmplinker.lds                                &lt;= GCC linker command file (for Cortex Axx cores) for Asym. Multiproc. boot
│       ├── mcuBootPerfLinker.lds                           &lt;= TI CGT Linker comamnd file for SBL performance tuning example.
│       ├── mcuLockStepLinker.lds                           &lt;= Linker comamnd file when TI CGT is used for R5 lock-step boot
│       ├── mpuSmplinker.lds                                &lt;= GCC linker command file (for Cortex Axx cores) for SMP boot
│       ├── mcuXiplinker.lds                                &lt;= Linker command file for XIP trampoline app
│       ├── xip_entry.lds                                   &lt;= Linker comamnd file for XIP test case
│       ├── xip_entry.asm                                   &lt;= Entry point of XIP trampoline app
│       ├── xip_stub.c                                      &lt;= Simple SBL test app that demonstrates transitioning to a XIP app
│       ├── sbl_amp_multicore.c                             &lt;= Simple SBL test that displays UART message
│       ├── sbl_amp_multicore_sections.h                    &lt;= Allows same source to be loaded to different sections for different cores.
│       ├── sbl_mcu_0_boot_perf_benchmark.c                 &lt;= SBL Test to tune boot performance.
│       ├── sbl_multicore_a53.asm                           &lt;= Test case entry point  for Cortex-Axx cores
│       ├── sbl_multicore_r5.asm                            &lt;= Test case entry point for Cortex-R5 cores
│       ├── sbl_multicore_r5_sections.inc                   &lt;= Allows same source to be loaded to different sections for different MCUs.
│       ├── sbl_printf.c                                    &lt;= Lightweight UART printf function for SBL testing
│       ├── sbl_smp_multicore.c                             &lt;= Simple SBL SMP test that uses SBL lib to reset MPUs
│       └── sbl_smp_r5.asm                                  &lt;= Provides dummy override function for __mpu_init for SMP testcase.
│
├── binary                                                  &lt;= ROM bootable SBL images for each board/boot media
│   ├── [board]
│       └── [bootmedia]
│           └── bin
│               └── sbl_[bootmedia]_img_mcu1_0_release.tiimage
│
├── lib                                                     &lt;= SBL lib for each boot media/board supported
│   ├── [bootmedia]
│   │   └── [board]
│   │       └── r5f
│   │           └── release
│   │               └── sbl_lib_[bootmedia].aer5f
│   └── cust
│       └── [board]
│           └── r5f
│               └── release
│                   └── sbl_lib_cust.aer5f
│
├── soc                                                     &lt;= SOC specific SBL code
│   └── k3
│       ├── linker.cmd                                      &lt;= Linker file used for generating ROM loadable SBL image.
│       ├── sbl_err_trap.h                                  &lt;= Error loops for SBL
│       ├── sbl_init.asm                                    &lt;= SBL Entry point
│       ├── sbl_misc.asm                                    &lt;= SBL Assembly utility functions
│       ├── sbl_log.h                                       &lt;= SBL logging framework
│       ├── sbl_sci_client.c                                &lt;= Calls SYSFW on DMSC
│       ├── sbl_sci_client.h
│       ├── sbl_slave_core_boot.c                           &lt;= Code that contains the sequence to release a core from reset
│       ├── sbl_slave_core_boot.h
│       ├── sbl_soc.c                                       &lt;= Cache Ops, PMU init, image verfication, etc &amp; SoC specific code like RAT Init..
│       ├── sbl_soc_cfg.h                                   &lt;= Abstraction layer for hiding SoC level changes from SBL
│       └── sbl_profile.h                                   &lt;= SBL profiling framework
│
├── src                                                     &lt;= Common drivers used across SOCs
│   ├── mmcsd
│   ├── hyperflash
│   ├── ospi
│   ├── qspi
│   ├── uart
│   ├── rprc                                                &lt;= RPRC image parser used by SBL
│   └── spi
│
└── tools
    ├── btoccs
    ├── byteswap
    ├── ccsutil
    ├── flashWriter                                         &lt;= Unused for AM65xx/J721E. AM65xx/J721E uses Uniflash to program flashes.
    ├── multicoreImageGen                                   &lt;= Stitches multiple RPRC images for different cores into a single image
    ├── omapl13x_boot_utils                                 &lt;= Unused for AM65xx/J721E
    ├── omapl13x_sd_card_format                             &lt;= Unused for AM65xx/J721E
    ├── out2rprc                                            &lt;= Converts .out into .rprc files, so that SBL can load non-continuous memory sections
    ├── scripts                                             &lt;= Scripts used by .out  generated by CCS projects into SBL loadable images
    │   ├── K3ImageGen.bat
    │   └── K3ImageGen.sh
    └── tiImageGen                                          &lt;= Unused for AM65xx/J721E. Image generation is handled by PDK build framework (&lt;prsdk_install_path&gt;/pdk_*/packages/ti/build/)
</pre></div>
</div>
</div>
<div class="section" id="image-formats">
<span id="am655x-image-formats"></span><h4>4.6.3.3.5. Image Formats<a class="headerlink" href="#image-formats" title="Permalink to this headline">¶</a></h4>
<p><strong>SBL format:</strong></p>
<p>To generate the a bootable image, the SBL build uses the x509CertificateGen script to
sign the sbl binary with so that the ROM Boot Loader (RBL) can parse it. The image
format expected by the RBL has been described in detail in the Image Format Section
of the <a class="reference external" href="http://www.ti.com/lit/pdf/spruid7">AM65xx Technical Reference Manual</a> and
the <a class="reference external" href="http://www.ti.com/lit/pdf/spruil1">J721E Technical Reference Manual</a></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For HS devices, the SBL and system firmware have to be signed with the MPK.
For an easy out-of-box experience, the Processor SDK for HS devices signs the
SBL and system firmware with a TI Dummy Key. Images signed with a TI dummy
key will boot on both GP and HS boards from TI.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The TI Dummy Key(s) <em>MUST</em> be replaced by customers during production
with their own Private Keys. If the TI Dummy Keys are used in a production
system, the system will be open to security attacks.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>While SBL and system firmware images signed with the TI Dummy Keys will work
on both GP and HS devices, the boot time will be significantly impacted on GP
devices. Using SBL signed by TI Dummy Keys on GP devices is only recommended
during the prototyping phase - when porting code developed on GP to HS devices.</p>
</div>
<p><strong>Application image format:</strong></p>
<p>Two utilities - out2rprc and multicoreImageGen are used to convert an application elf
image(s) into an image loadable by the SBL. The structure of a multicore application
image is provided below:</p>
<img alt="../_images/Multicore_app_image.png" src="../_images/Multicore_app_image.png" />
<p><strong>RPRC File Header Format</strong></p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Binary value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x00000000</p></td>
<td><p><strong>Magic Word(43525052)</strong></p></td>
</tr>
<tr class="row-odd"><td><p>0x00000004</p></td>
<td><p><strong>Entry Point (Location)</strong></p></td>
</tr>
<tr class="row-even"><td><p>0x00000008</p></td>
<td><p><strong>Reserved Addr</strong></p></td>
</tr>
<tr class="row-odd"><td><p>0x0000000C</p></td>
<td><p><strong>Section Count</strong></p></td>
</tr>
<tr class="row-even"><td><p>0x00000010</p></td>
<td><p><strong>Version</strong></p></td>
</tr>
</tbody>
</table>
<p><strong>RPRC Section Header Format</strong></p>
<table class="docutils align-default">
<colgroup>
<col style="width: 31%" />
<col style="width: 69%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Binary value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x00000000</p></td>
<td><p><strong>Section start Address</strong></p></td>
</tr>
<tr class="row-odd"><td><p>0x00000004</p></td>
<td><p><strong>Reserved Addr</strong></p></td>
</tr>
<tr class="row-even"><td><p>0x00000008</p></td>
<td><p><strong>Size</strong></p></td>
</tr>
<tr class="row-odd"><td><p>0x0000000C</p></td>
<td><p><strong>Reserved CRC</strong></p></td>
</tr>
<tr class="row-even"><td><p>0x00000010</p></td>
<td><p><strong>Reserved</strong></p></td>
</tr>
</tbody>
</table>
<p><strong>Multicore boot image format</strong></p>
<p><strong>Meta Header Start</strong></p>
<table class="docutils align-default">
<colgroup>
<col style="width: 28%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Binary value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x00000000</p></td>
<td><p><strong>Magic String (0x5254534D)</strong></p></td>
</tr>
<tr class="row-odd"><td><p>0x00000004</p></td>
<td><p><strong>Number of Files</strong></p></td>
</tr>
<tr class="row-even"><td><p>0x00000008</p></td>
<td><p><strong>Device ID</strong></p></td>
</tr>
<tr class="row-odd"><td><p>0x0000000C</p></td>
<td><p><strong>Reserved</strong></p></td>
</tr>
</tbody>
</table>
<p><strong>Meta Header per Core</strong></p>
<table class="docutils align-default">
<colgroup>
<col style="width: 40%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Binary value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x00000000</p></td>
<td><p><strong>Core ID</strong></p></td>
</tr>
<tr class="row-odd"><td><p>0x00000004</p></td>
<td><p><strong>Image Offset</strong></p></td>
</tr>
</tbody>
</table>
<p><strong>Signed application image format:</strong></p>
<p>To convert the multicore application image into a format that can be verified,  the build flow uses
the x509CertificateGen script to create a x509 certificate for the app image. Images that have a
x509 certificate are called signed images. Signed applications images are mandatory for HS devices,
but will work also work on GP devices.</p>
<p>Signed images are automatically detected by the SBL and loaded into a scratch memory area specified during
SBL build. The scratch memory area used by default is specified in <a class="reference external" href="https://git.ti.com/keystone-rtos/sbl/blobs/master/build/sbl_lib.mk">sbl_lib.mk</a> via the flags SBL_SCRATCH_MEM_START and
SBL_SCRATCH_MEM_SIZE. The SBL_SCRATCH_MEM* options can also be specified for custom builds to override
the defaults.</p>
<p>The SBL scratch memory is unavailable to applications during app load time, as the SBL is
still active. Once the SBL transfers control to the application, this memory is available for app
use - in other words SBL_SCRATCH_MEM* is available during app runtime.</p>
<p>For information on the application’s X.509 certificate format, please refer
<a class="reference external" href="http://downloads.ti.com/tisci/esd/latest/2_tisci_msgs/security/sec_cert_format.html#security-x509-certificate-documentation">Security X509 Certificate Documentation</a></p>
</div>
<div class="section" id="building-the-sbl-and-its-components">
<h4>4.6.3.3.6. Building the SBL and its components<a class="headerlink" href="#building-the-sbl-and-its-components" title="Permalink to this headline">¶</a></h4>
<p><strong>Pre-requisites to Building</strong></p>
<ul class="simple">
<li><p>Set your environment using pdksetupenv.bat or pdksetupenv.sh. Refer to
<a class="reference external" href="http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/index_overview.html#setup-environment">Processor SDK RTOS Building</a> for information on setting up your build environment</p></li>
</ul>
<div
style="margin: 5px; padding: 2px 10px; background-color: #ecffff; border-left: 5px solid #3399ff;"><p><strong>NOTE</strong></p>
<ul class="simple">
<li><p>SBL needs openssl to build. To check if openssl is present, type the
following at the linux or windows prompt.</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">openssl</span> <span class="n">version</span>
</pre></div>
</div>
<ul class="simple">
<li><p>To build on Linux, you need to have <a class="reference external" href="http://www.mono-project.com">mono</a> installed.</p></li>
<li><p>Refer <a class="reference external" href="http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/Overview.html#command">Build Dependencies</a> for instructions on how to install these tools,
if they are not already present on your system.</p></li>
</ul>
</div><p><strong>Compiling the SBL</strong></p>
<p>To build all the SBL components:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="o">&lt;</span><span class="n">PDK</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">sbl</span><span class="o">/</span><span class="n">build</span>
<span class="n">gmake</span> <span class="n">clean</span> <span class="n">all</span> <span class="p">(</span><span class="k">for</span> <span class="n">windows</span><span class="p">)</span>
<span class="n">make</span> <span class="n">clean</span> <span class="n">all</span>  <span class="p">(</span><span class="k">for</span> <span class="n">Linux</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>SBL image files are be located at: <strong>&lt;PDK&gt;/packages/ti/boot/sbl/binary/</strong></p></li>
<li><p>SBL examples are located at <strong>&lt;PDK&gt;/packages/ti/boot/sbl/examples/k3MulticoreApp/binary</strong></p></li>
<li><p>SBL lib are located at <strong>&lt;PDK&gt;/packages/ti/boot/sbl/lib/</strong></p></li>
</ul>
<p><strong>Compile time options for the SBL</strong></p>
<p>The SBL supports several compile time options to tweak the SBL to satisfy requirements of
ease of use, boot time and size. These can be enabled or disabled by editing <a class="reference external" href="http://git.ti.com/keystone-rtos/sbl/blobs/master/sbl_component.mk">sbl/sbl_component.mk</a></p>
<ul class="simple">
<li><p>SBL_LOG_LEVEL : Controls amount of SBL logs (on the MCU UART) and system firmware logs(on WAKEUP UART).
Varies from 0(no logs) to  3 (all logs)</p></li>
<li><p>SBL_USE_DMA : Valid values are 0 (use CPU to access boot media) or 1 (use DMA to
access boot media).</p></li>
<li><p>SBL_DISPLAY_PROFILE_INFO : At the end of the boot process, displays a log of timestamps
at which different SBL profile points are hit. This is useful to see how much
time the SBL spends in different functions. SBL_LOG_LEVEL can significantly
affect performance numbers.</p></li>
<li><p>SBL_ENABLE_PLL : Dials up all the PLLs calling Board_init(). Makes it easier for
applications as they no longer have to initialize the PLLs. However, enabling this
significantly increases boot time and power consumption. Requires system firmware to
be loaded.</p></li>
<li><p>SBL_ENABLE_CLOCKS : Enables all the module clocks by calling Board_init(). Makes
it easier for applications as they no longer have to enable clocks.</p></li>
<li><p>SBL_ENABLE_DDR : Initializes the DDR. At the cost of boot time, this enables
applications to run from and use DDR. SBL_ENABLE_CLOCKS and SBL_ENABLE_PLL must
also be enabed for this to work. Enabling this option increases the boot time.</p></li>
<li><p>SBL_SKIP_MCU_RESET : Jumps to the MCU0 application entry point
without resetting the core. Enables faster boot time. Will not change the MCU’s
mode (lock-step/split). Application also inherits the MCU state as the SBL
left it in.</p></li>
</ul>
<p>The SBL also supports a “custom” build, in addition to standard out-of-box builds.
A custom build is a useful way of testing out the effect of different build options -
like when optimizing for boot time, or enabling custom usecases like eXecute In Place (XIP)
to reduce memory usage.</p>
<p>For an example of how to use such custom builds, please refer to <a class="reference external" href="https://git.ti.com/keystone-rtos/sbl/blobs/master/sbl_component.mk#line426">sbl/sbl_component.mk</a>. It shows
how to specify a select list of build options while building SBL images and libs.</p>
</div><p id="am655x-compiling-apps-for-sbl"><strong>Compiling apps that can be loaded by SBL:</strong></p>
<p><strong>Memory Map Considerations</strong></p>
<p>Applications that the SBL loads must comply with the <a class="reference internal" href="#am655x-sbl-memory-usage">am655x-sbl-memory-usage</a>.
In the application’s linker command file, care must be taken to not use the first
0x100 bytes of any R5 MCU’s ATCM memory and SBL reserved memory from 0x41C00100
to 0x41C3E000. If the applications are signed, no loadable sections must be placed
in the SBL scratch memory area. The scratch memory can be used at application runtime
for stacks, heaps, etc.</p>
<div
style="margin: 5px; padding: 2px 10px; background-color: #ecffff; border-left: 5px solid #3399ff;"><p><strong>NOTE</strong></p>
<ul class="simple">
<li><p>The local address 0x0 of the MPU is not accessible from the MCU, so any MPU linker
command file must not specify any loadable sections in that memory region. The SBL
will not be able to access that memory to load code or data.</p></li>
</ul>
</div><p><strong>Converting ELF executables to SBL loadable image</strong></p>
<p>Depending on the usecase, an ELF application executable can be converted into an
image that can be loaded by SBL in many ways.</p>
<ul class="simple">
<li><p><strong>Using CCS</strong>: Any project created using the pdkProjectCreate scripts will
automatically generate a SBL loadable app, as part of a post-build step.</p></li>
<li><p><strong>Using makefiles</strong>: Add the following lines to the component’s .mk file</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">app_name_SBL_APPIMAGEGEN</span> <span class="o">=</span> <span class="n">yes</span>
<span class="k">export</span> <span class="n">app_name_SBL_APPIMAGEGEN</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Existing ELF executable</strong>: By calling the K3ImageGen script.</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>Linux Syntax: K3ImageGen.sh &lt;CoreID&gt; &lt;.out&gt;

Example:
cd  &lt;prsdk_install_path&gt;/pdk_*/packages/ti/boot/sbl/example/ampMulticoreApp/binary/am65xx_evm/
K3ImageGen.sh 4 sbl_baremetal_boot_test_am65xx_evm_mcu1_0TestApp_release.xer5f
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>Windows Syntax: K3ImageGen.bat &quot;&lt;CoreID&gt; &lt;.out&gt;&quot;

Example:
cd  &lt;prsdk_install_path&gt;\pdk_*\packages\ti\boot\sbl\example\ampMulticoreApp\binary\am65xx_evm\
K3ImageGen.bat &quot;4 sbl_baremetal_boot_test_am65xx_evm_mcu1_0TestApp_release.xer5f&quot;
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Multicore Images</strong>: Multicore images, as the name suggests, allows the SBL
to load applications for multiple cores from a single image. Creating such images
invloves three steps.</p></li>
</ul>
<ol class="arabic simple">
<li><p>Generate the ELF application executables for individual cores</p></li>
<li><p>Convert the ELF executables into intermediate .rprc images</p></li>
<li><p>Combine the .rprc images of individual cores to create a single multicore image</p></li>
</ol>
<p>To covert any .out into the intermediate .rprc format, execute the following commands</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">For</span> <span class="nl">Linux</span><span class="p">:</span>
<span class="n">mono</span> <span class="o">&lt;</span><span class="n">PDK</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">sbl</span><span class="o">/</span><span class="n">tools</span><span class="o">/</span><span class="n">out2rprc</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">out2rprc</span><span class="p">.</span><span class="n">exe</span> <span class="n">input</span><span class="p">.</span><span class="n">out</span> <span class="n">output</span><span class="p">.</span><span class="n">rprc</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>For Windows:
&lt;PDK&gt;\packages\ti\boot\sbl\tools\out2rprc\bin\out2rprc.exe input.out output.rprc
</pre></div>
</div>
<p>To stitch multiple .rprc images into a multicore image, execute the following command</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">For</span> <span class="nl">Linux</span><span class="p">:</span>
<span class="o">&lt;</span><span class="n">PDK</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">sbl</span><span class="o">/</span><span class="n">tools</span><span class="o">/</span><span class="n">multicoreImageGen</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">MulticoreImageGen</span> <span class="n">LE</span> <span class="mi">55</span> <span class="n">output</span><span class="p">.</span><span class="n">appimage</span>  <span class="o">&lt;</span><span class="n">core_id_1</span><span class="o">&gt;</span> <span class="n">core_1</span><span class="p">.</span><span class="n">rprc</span> <span class="o">&lt;</span><span class="n">core_id_2</span><span class="o">&gt;</span> <span class="n">core_2</span><span class="p">.</span><span class="n">rprc</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">For</span> <span class="nl">Windows</span><span class="p">:</span>
<span class="o">&lt;</span><span class="n">PDK</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">sbl</span><span class="o">/</span><span class="n">tools</span><span class="o">/</span><span class="n">multicoreImageGen</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">MulticoreImageGen</span><span class="p">.</span><span class="n">exe</span> <span class="n">LE</span> <span class="mi">55</span> <span class="n">output</span><span class="p">.</span><span class="n">appimage</span>  <span class="o">&lt;</span><span class="n">core_id_1</span><span class="o">&gt;</span> <span class="n">core_1</span><span class="p">.</span><span class="n">rprc</span> <span class="o">&lt;</span><span class="n">core_id_2</span><span class="o">&gt;</span> <span class="n">core_2</span><span class="p">.</span><span class="n">rprc</span>
</pre></div>
</div>
<div
style="margin: 5px; padding: 2px 10px; background-color: #ecffff; border-left: 5px solid #3399ff;"><p><strong>NOTE</strong></p>
<ul class="simple">
<li><p>The linux host environment needs to have <a class="reference external" href="http://www.mono-project.com">mono</a> installed.</p></li>
<li><p>The values used for the Core ID and Device ID can be found in <a class="reference external" href="http://git.ti.com/keystone-rtos/sbl/blobs/master/soc/k3/sbl_slave_core_boot.h#line51">sbl/soc/k3/
sbl_slave_core_boot.h</a></p></li>
<li><p>To simply load an ELF without executing it, use CoreID value ONLY_LOAD_ID</p></li>
<li><p>If an image for MCU_1 core is provided, the SBL will attempt to switch to
split mode.</p></li>
<li><p>If only an image for MCU_0 is provided, the SBL will not change the mode of the
MCU subsystem.</p></li>
<li><p>To enable SMP on the MPU, ie, to get multiple MPUs execute from a single binary
from the same address, use one of the following core_ids</p>
<ul>
<li><p>MPU1_SMP_ID: The same app binary runs on both cores in MPU cluster 1</p></li>
<li><p>MPU2_SMP_ID: The same app binary runs on both cores in MPU cluster 2</p></li>
<li><p>MPU_SMP_ID:  The same app binary runs all the MPUs</p></li>
</ul>
</li>
</ul>
</div><p><strong>Converting ELF executables to executable binary images</strong></p>
<p>Sometimes, for exteremely constrained and specialized usecases like ultra-low-latency boot
or DDR-less systems, an ELF application executable can be converted into a binary
image that can executed directly from the boot media, without loading into internal
memory.</p>
<p>As internal memory is always accessible, this mode of execution allows some otherwise
mandatory steps steps like DDR initlization or clock initialization  to be done
later or skipped altogether.</p>
<p>Working with such highly contrained systems require some special steps..</p>
<ul class="simple">
<li><p>Make sure that the boot media supports eXecuting In Place (XIP).</p></li>
<li><p>Use the custom SBL build to select the build options to build a SBL
that meets the usecase requirements.</p></li>
<li><p>In the linker command file for the application, make sure that all the data
sections, stacks, heaps and globals are in internal read/write memory</p></li>
<li><p>In the linker command file for the application, make sure that there are no
holes in the loadable sections. Such non-contiguous sections can drastically
blow up the binary image size, when comapred to the ELF executable size.</p></li>
<li><p>To generate an executable binary image from the applications ELF file,
add the following lines to the component’s .mk file</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">app_name_SBL_APP_BINIMAGEGEN</span> <span class="o">=</span> <span class="n">yes</span>
<span class="k">export</span> <span class="n">app_name_SBL_APP_BINIMAGEGEN</span>
</pre></div>
</div>
</div>
<div class="section" id="testing-the-sbl">
<h4>4.6.3.3.7. Testing the SBL<a class="headerlink" href="#testing-the-sbl" title="Permalink to this headline">¶</a></h4>
<p>SBL provides test applications to demonstrate booting the A53 and R5 cores in
both symmetric/lock step &amp; asymmetric/split-mode and other features. The multicore
sample application prints a message on the UART for each core. The functionality
the different tests exercises are listed below.</p>
<ul class="simple">
<li><p>sbl_*_boot_test_*_all_coresTestApp_release: A single multicore boot test case
that boots each core in the SoC with a separate app. Also tests DDR loading</p></li>
<li><p>sbl_*_boot_test_*_xxxx_xTestApp_release.appimage: A simple testcase for booting
core xxxx_x (eg. MCU1_0, MPU2_0 etc.)</p></li>
<li><p>sbl_*_smp_test_*_all_coresTestApp_release.appimage: A single SMP boot test case
that boots MCUs in lock step. The MCU app then uses the SBL lib to boot all the
MPUs in SMP mode, ie, all the MPUs execute a single binary from the same address.</p></li>
<li><p>sbl_baremetal_boot_perf_*_mcu1_0TestApp_release.appimage: A single MCU1_0 test
case that can be used to measure the effect of enabling/disabling the perf.
tuning knobs in the SBL for OSPI boot. The size of the test case can be easily
modified by changing the value of SIZE_OF_PAD in <a class="reference external" href="http://git.ti.com/keystone-rtos/sbl/blobs/master/example/k3MulticoreApp/sbl_mcu_0_boot_perf_benchmark.c#line90">sbl/example/k3MulticoreApp/
sbl_mcu_0_boot_perf_benchmark.c</a>
to profile for different app image sizes.</p></li>
<li><p>sbl_baremetal_boot_xip_test_*_mcu1_0TestApp_release.xer5f.bin: A testcase
demonstrating booting an XIP application from OSPI flash. Please refer <a class="reference external" href="https://git.ti.com/keystone-rtos/sbl/blobs/master/build/sbl_mcu0_boot_xip_test.mk">sbl/build/
sbl_mcu0_boot_xip_test.mk</a> and <a class="reference external" href="https://git.ti.com/keystone-rtos/sbl/blobs/master/example/k3MulticoreApp/mcuXiplinker.lds">sbl/example/k3MulticoreApp/mcuXiplinker.lds</a>
to see how to convert an existing application into an XIP application. The
sbl_*_xip_entry_*.appimage works in tandem with sbl_*xip_test_*.xer5f.bin to transition
the system from non-xip to xip boot, as the ROM, by default, does not support XIP from
boot media. After programming the sbl and syfw, to program  both sbl_*_xip_entry_*.appimage
and  sbl_*xip_test_*.xer5f.bin into OSPI flash, use the following uniflash commands</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>For Windows:
.\dslite.bat --mode processors -c COM9 -f &lt;PDK&gt;\packages\ti\boot\sbl\example\k3MulticoreApp\binary\am65xx\sbl_baremetal_boot_xip_entry_am65xx_evm_mcu1_0TestApp_release.appimage -d 3 -o A0000
.\dslite.bat --mode processors -c COM9 -f &lt;PDK&gt;\packages\ti\boot\sbl\example\k3MulticoreApp\binary\am65xx\sbl_baremetal_boot_xip_test_am65xx_evm_mcu1_0TestApp_release.xer5f.bin -d 3 -o E0000
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">For</span> <span class="nl">Linux</span><span class="p">:</span>
<span class="n">sudo</span> <span class="p">.</span><span class="o">/</span><span class="n">dslite</span><span class="p">.</span><span class="n">sh</span> <span class="o">--</span><span class="n">mode</span> <span class="n">processors</span> <span class="o">-</span><span class="n">c</span> <span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">ttyUSB1</span> <span class="o">-</span><span class="n">f</span> <span class="o">&lt;</span><span class="n">PDK</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">sbl</span><span class="o">/</span><span class="n">example</span><span class="o">/</span><span class="n">k3MulticoreApp</span><span class="o">/</span><span class="n">binary</span><span class="o">/</span><span class="n">am65xx</span><span class="o">/</span><span class="n">sbl_baremetal_boot_xip_entry_am65xx_evm_mcu1_0TestApp_release</span><span class="p">.</span><span class="n">appimage</span> <span class="o">-</span><span class="n">d</span> <span class="mi">3</span> <span class="o">-</span><span class="n">o</span> <span class="n">A0000</span>
<span class="n">sudo</span> <span class="p">.</span><span class="o">/</span><span class="n">dslite</span><span class="p">.</span><span class="n">sh</span> <span class="o">--</span><span class="n">mode</span> <span class="n">processors</span> <span class="o">-</span><span class="n">c</span> <span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">ttyUSB1</span> <span class="o">-</span><span class="n">f</span> <span class="o">&lt;</span><span class="n">PDK</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">sbl</span><span class="o">/</span><span class="n">example</span><span class="o">/</span><span class="n">k3MulticoreApp</span><span class="o">/</span><span class="n">binary</span><span class="o">/</span><span class="n">am65xx</span><span class="o">/</span><span class="n">sbl_baremetal_boot_xip_test_am65xx_evm_mcu1_0TestApp_release</span><span class="p">.</span><span class="n">xer5f</span><span class="p">.</span><span class="n">bin</span> <span class="o">-</span><span class="n">d</span> <span class="mi">3</span> <span class="o">-</span><span class="n">o</span> <span class="n">E0000</span>
</pre></div>
</div>
<p>An example test log for sbl_*_boot_test_*_all_coresTestApp_release is</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">SYSFW</span>  <span class="n">ver</span> <span class="n">xx</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="n">x</span><span class="o">-</span><span class="n">v20xx</span><span class="p">.</span><span class="n">xx</span> <span class="p">(</span><span class="n">xxx</span> <span class="n">xxx</span><span class="p">)</span> <span class="n">running</span>
<span class="n">SBL</span> <span class="nl">Revision</span><span class="p">:</span> <span class="n">xx</span><span class="p">.</span><span class="n">xx</span><span class="p">.</span><span class="n">xx</span><span class="p">.</span><span class="n">xx</span> <span class="p">(</span><span class="n">MMM</span>  <span class="n">DD</span> <span class="n">YYYY</span> <span class="o">-</span> <span class="nl">HH</span><span class="p">:</span><span class="nl">MM</span><span class="p">:</span><span class="n">SS</span><span class="p">)</span>
<span class="n">MPU1_0</span> <span class="n">running</span>
<span class="n">MPU1_1</span> <span class="n">running</span>
<span class="n">MPU2_0</span> <span class="n">running</span>
<span class="n">MPU2_1</span> <span class="n">running</span>
<span class="n">MCU1_1</span> <span class="n">running</span>
<span class="n">MCU1_0</span> <span class="n">running</span>
<span class="n">MCU1_0</span> <span class="nl">reports</span><span class="p">:</span> <span class="n">All</span> <span class="n">tests</span> <span class="n">have</span> <span class="n">passed</span>
</pre></div>
</div>
<p>An example log for sbl_*_smp_test_*_all_coresTestApp_release.appimage is</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">SYSFW</span>  <span class="n">ver</span> <span class="n">xx</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="n">x</span><span class="o">-</span><span class="n">v20xx</span><span class="p">.</span><span class="n">xx</span> <span class="p">(</span><span class="n">xxx</span> <span class="n">xxx</span><span class="p">)</span> <span class="n">running</span>
<span class="n">SBL</span> <span class="nl">Revision</span><span class="p">:</span> <span class="n">xx</span><span class="p">.</span><span class="n">xx</span><span class="p">.</span><span class="n">xx</span><span class="p">.</span><span class="n">xx</span> <span class="p">(</span><span class="n">MMM</span>  <span class="n">DD</span> <span class="n">YYYY</span> <span class="o">-</span> <span class="nl">HH</span><span class="p">:</span><span class="nl">MM</span><span class="p">:</span><span class="n">SS</span><span class="p">)</span>
<span class="n">MPU</span> <span class="n">SMP</span> <span class="n">boot</span> <span class="n">test</span>
<span class="n">Cores</span> <span class="mi">0</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="n">will</span> <span class="n">boot</span> <span class="n">from</span> <span class="mh">0x801007a0</span>
<span class="n">Cores</span> <span class="mi">2</span> <span class="o">&amp;</span> <span class="mi">3</span> <span class="n">will</span> <span class="n">boot</span> <span class="n">from</span> <span class="mh">0x803007a0</span>
<span class="n">Resetting</span> <span class="n">all</span> <span class="n">ARM</span> <span class="n">cores</span> <span class="n">now</span><span class="p">...</span>
<span class="n">No</span> <span class="n">of</span> <span class="n">Cortex</span><span class="o">-</span><span class="n">A</span> <span class="n">core</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="nl">running</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">No</span> <span class="n">of</span> <span class="n">Cortex</span><span class="o">-</span><span class="n">A</span> <span class="n">core</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="nl">running</span><span class="p">:</span> <span class="mi">2</span>
<span class="n">No</span> <span class="n">of</span> <span class="n">Cortex</span><span class="o">-</span><span class="n">A</span> <span class="n">core</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="nl">running</span><span class="p">:</span> <span class="mi">3</span>
<span class="n">No</span> <span class="n">of</span> <span class="n">Cortex</span><span class="o">-</span><span class="n">A</span> <span class="n">core</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="nl">running</span><span class="p">:</span> <span class="mi">4</span>
<span class="n">All</span> <span class="n">tests</span> <span class="n">have</span> <span class="n">passed</span>
</pre></div>
</div>
<p>An example log for sbl_baremetal_boot_perf_*_mcu1_0TestApp_release.appimage, when the best boot time is reached is</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>Time elapsed since start of SBL:     36665us
fxn:boot_perf_test_main     cycles:  14666041

Attempting board config ...BOARD_INIT_PLL ...passed
BOARD_INIT_MODULE_CLOCK...passed
BOARD_INIT_DDR...passed

Analyzing run results ....
Boot time is now optimized....
All tests have passed

Profiling info ....
MCU @ 400000000Hz.
cycles per usec  = 400
  fxn:                            main      line:  75       cycle:  xxx     timestamp:       432us
                                    .
                                    .
                                    .
  fxn:               SBL_SlaveCoreBoot      line: 231       cycle:  xxx     timestamp:     36149us
</pre></div>
</div>
<p>The test log for sbl_*_xip_test_*.xer5f.bin is</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MCU1_0</span> <span class="n">running</span>
</pre></div>
</div>
</div>
<div class="section" id="id106">
<h4>4.6.3.3.8. Boot Modes<a class="headerlink" href="#id106" title="Permalink to this headline">¶</a></h4>
<p>The SBL supports MMCSD, OSPI, UART and Hyperflash Boot modes. The different boot modes
supported for all the boards is tabulated below.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 34%" />
<col style="width: 12%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 18%" />
</colgroup>
<tbody>
<tr class="row-odd"><td></td>
<td><p>MMCSD</p></td>
<td><p>OSPI</p></td>
<td><p>UART</p></td>
<td><p>PCIe</p></td>
<td><p>ETH</p></td>
<td><p>HYPERFLASH</p></td>
</tr>
<tr class="row-even"><td><p>AM65xx EVM</p></td>
<td><p>YES</p></td>
<td><p>YES</p></td>
<td><p>YES</p></td>
<td><p>NO</p></td>
<td><p>NO</p></td>
<td><p>NO</p></td>
</tr>
<tr class="row-odd"><td><p>AM65xx IDK</p></td>
<td><p>YES</p></td>
<td><p>YES</p></td>
<td><p>YES</p></td>
<td><p>NO</p></td>
<td><p>NO</p></td>
<td><p>NO</p></td>
</tr>
<tr class="row-even"><td><p>J721E EVM</p></td>
<td><p>YES</p></td>
<td><p>YES</p></td>
<td><p>YES</p></td>
<td><p>NO</p></td>
<td><p>NO</p></td>
<td><p>YES</p></td>
</tr>
</tbody>
</table>
<p><strong>Booting Via SD Card</strong></p>
<ol class="arabic simple">
<li><p>Preparing the SD card.</p></li>
<li><p>Booting the testcase from SD card.</p></li>
</ol>
<p><strong>Preparing the SD card</strong></p>
<ol class="arabic simple">
<li><p>To boot the target the SD card should be bootable. Follow the steps
at <a class="reference external" href="http://processors.wiki.ti.com/index.php/Processor_SDK_RTOS_Creating_a_SD_Card_with_Windows">Creating bootable SD card in
windows</a>
or <a class="reference external" href="http://processors.wiki.ti.com/index.php/Processor_SDK_RTOS_create_SD_card_script">Creating bootable SD card in
Linux</a>.</p></li>
<li><p>To update the SBL with a newer version, copy the sbl image (sbl_mmcsd_img_mcu1_0_release.tiimage) to the SD card.
Rename it to <strong>tiboot3.bin</strong></p></li>
<li><p>To update the SYSFW with a newer version, copy the system firmware image (sysfw.bin) to the SD card.</p></li>
<li><p>Copy the generated application image(*.appimage) to the SD card. Rename it to
<strong>app</strong></p></li>
</ol>
<p><strong>Booting the testcase  from SD card</strong></p>
<ol class="arabic simple">
<li><p>Insert SD card into the SD card slot of the board.</p></li>
<li><p>Refer Boot Modes section in the <a class="reference external" href="http://www.ti.com/lit/pdf/spruim7">AM6x EVM Hardware Users Guide</a>  to setup EVM to boot from MMCSD.</p></li>
<li><p>Open a serial communication terminal like TeraTerm, MiniCom on host
PC and connect to the MCU UART console port</p></li>
<li><p>Power cycle the board to boot the application from the SD card.</p></li>
<li><p>The test logs will be displayed on the MCU UART</p></li>
</ol>
<p><strong>Booting Via OSPI flash</strong></p>
<ol class="arabic simple">
<li><p><a class="reference external" href="http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/index_board.html#uniflash">Programming the OSPI flash</a></p></li>
<li><p>Booting the testcase from OSPI flash</p></li>
</ol>
<p><strong>Booting the testcase from OSPI flash</strong></p>
<ol class="arabic simple">
<li><p>Refer Boot Modes section in the <a class="reference external" href="http://www.ti.com/lit/pdf/spruim7">AM6x EVM Hardware Users Guide</a>  to setup EVM to boot from OSPI.</p></li>
<li><p>Open a serial communication terminal like TeraTerm, MiniCom on host
PC and connect to the MCU UART console port</p></li>
<li><p>Power cycle  the board to boot the application from the OSPI flash.</p></li>
<li><p>The test logs will be displayed on the MCU UART</p></li>
</ol>
<p><strong>Booting the testcase from UART</strong></p>
<ol class="arabic simple">
<li><p>Refer Boot Modes section in the <a class="reference external" href="http://www.ti.com/lit/pdf/spruim7">AM6x EVM Hardware Users Guide</a>  to setup EVM to boot from UART.</p></li>
<li><p>Open a serial communication terminal like TeraTerm, MiniCom on host
PC and connect to the MCU UART console port</p></li>
<li><p>Power cycle the board, the console should show a sequence of CCC being printed</p></li>
<li><p>Choose the X-Modem interface and send the SBL that was built for UART. After the transfer is completed,
repeat the same step for sysfw.bin and the application. You will see notifications to perform these
actions.</p></li>
</ol>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If sysfw.bin is not present in the boot media, the boot will fail without displaying any
logs on the MCU UART. SBL enables UART logging only after successfully starting the system
firmware image. If the system firmware load fails, the RBL will eventually reset the system.</p>
</div>
<p><strong>Booting Via Hyperflash</strong></p>
<ol class="arabic simple">
<li><p><a class="reference external" href="http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/index_board.html#uniflash">Programming the Hyperflash</a></p></li>
<li><p>Booting the testcase from Hyperflashflash</p></li>
</ol>
<p><strong>Booting the testcase from Hyperflash</strong></p>
<ol class="arabic simple">
<li><p>Refer Boot Modes section in the <a class="reference external" href="https://cdds.ext.ti.com/ematrix/common/emxNavigator.jsp?objectId=28670.42872.4850.38306">J721E EVM Hardware Users Guide</a>
to setup EVM to boot from Hyperflash.</p></li>
<li><p>Open a serial communication terminal like TeraTerm, MiniCom on host
PC and connect to the MCU UART console port</p></li>
<li><p>Power cycle  the board to boot the application from the Hyperflash.</p></li>
<li><p>The test logs will be displayed on the MCU UART</p></li>
</ol>
</div>
<div class="section" id="evm-setup-for-testing-sbl">
<h4>4.6.3.3.9. EVM Setup for testing SBL<a class="headerlink" href="#evm-setup-for-testing-sbl" title="Permalink to this headline">¶</a></h4>
<p>For information on board specific requirements like power supply, UART console port
connections refer the Hardware User guide of the respective boards.</p>
<p>The configurations needed to setup UART console through a serial terminal
application on host PC are listed in the next section.</p>
<p><strong>UART Console Setup</strong></p>
<p>PDK SBL prints messages on the UART Serial Console running on the host. Hence, a
serial terminal application (like Tera Term/HyperTerminal/minicom) should be
running on the host.</p>
<ul class="simple">
<li><p>The host serial port must be configured at 115200 baud, no parity, 1  stop bit
and no flow control.</p></li>
<li><p>Please ensure that the local echo setting for the terminal is turned  off.</p></li>
<li><p>All SBL prints are routed to the <a class="reference external" href="http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/index_how_to_guides.html#uart-connection">MCU UART</a></p></li>
<li><p>To verify setup is correct, setup the EVM to boot from UART  as the Primary Boot
Device(refer <a class="reference external" href="http://www.ti.com/lit/pdf/spruim7">AM6x EVM Hardware Users Guide</a>.
Power cycle the EVM, and look for the string CCCCCCC on the UART.</p></li>
</ul>
</div>
</div>
<div class="section" id="c66x">
<h3>4.6.3.4. C66x<a class="headerlink" href="#c66x" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id107">
<h4>4.6.3.4.1. Overview<a class="headerlink" href="#id107" title="Permalink to this headline">¶</a></h4>
<p>C66x SOCs use the Intermediate Boot-Loader (IBL) to initialize and setup
the SOC for specific boot modes. The table below illustrates the
supported bootmodes:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 59%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Boot Mode</p></th>
<th class="head"><p>TMDSEVM6678</p></th>
<th class="head"><p>TMDXEVM6657</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NOR boot via IBL over I2C<sup>1</sup></p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>NAND boot via IBL over I2C<sup>1</sup></p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>TFTP boot via IBL over I2C<sup>1</sup></p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>I2C POST boot<sup>2</sup></p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>Ethernet boot</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>SRIO boot</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>PCIe boot</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ol class="arabic simple">
<li><p>Support boot over I2C bus address 0x51</p></li>
<li><p>Support POST boot over I2C bus address 0x50</p></li>
<li><p>Only ELF and BBLOB images are supported for booting</p></li>
<li><p>IBL is using the first 128KB L2 local memory, any application booting
from IBL should NOT use the first 128KB L2 memory, OR should only use
the first 128KB L2 memory for uninitialized data section</p></li>
</ol>
</div>
<p>Please refer to the boot mode dip switch settings for different boot
modes on
<a class="reference external" href="http://processors.wiki.ti.com/index.php/TMDXEVM6678L_EVM_Hardware_Setup#Boot_Mode_Dip_Switch_Settings">TMDSEVM6678L_EVM</a>,
and
<a class="reference external" href="http://processors.wiki.ti.com/index.php/TMDSEVM6657L_EVM_Hardware_Setup#Boot_Mode_Dip_Switch_Settings">TMDSEVM6657L_EVM</a>
that IBL supports.</p>
</div>
<div class="section" id="flashing-the-bootloader">
<h4>4.6.3.4.2. Flashing the Bootloader<a class="headerlink" href="#flashing-the-bootloader" title="Permalink to this headline">¶</a></h4>
<p>IBL needs to be flashed into EEPROM address 0x51.</p>
<p>Refer to <a class="reference external" href="http://processors.wiki.ti.com/index.php/Program_EVM_UG">Processor SDK RTOS Flashing Bootable
Images</a>] for
instructions on using the script, program_evm.js, to automatically flash
your device.</p>
</div>
<div class="section" id="id108">
<h4>4.6.3.4.3. Bootloader Execution Sequence<a class="headerlink" href="#id108" title="Permalink to this headline">¶</a></h4>
<p>IBL is flashed into I2C EEPROM bus address 0x51. IBL provides a
workaround for the PLL lockup issue (please refer to C6678 errata
document, February 2011, advisory 8 for details on the PLL lockup
issue). For ROM boot modes (EMAC,SRIO,PCIe,Hyperlink etc) and I2C boot
mode with bus address 0x50, DSP will initially boot from I2C EEPROM bus
address 0x51 which does the PLL reset workaround, updates the DEVSTAT
for appropriate values based on the DIP switch settings (SW3 through SW6
settings) and then re enters the ROM to accomplish the desired boot
mode. Please note that the re entry is done for all boot modes except
for PCIe boot mode and I2C boot mode with bus address 0x51.</p>
<p>Below are the steps done in the IBL:</p>
<ol class="arabic simple">
<li><p>FPGA samples the bootmode pins</p></li>
<li><p>FPGA forces the DSP to boot via I2C bus address 0x51</p></li>
<li><p>PLL is initialized correctly by the IBL on the I2C.</p></li>
<li><p>IBL reads the sampled bootmode from an FPGA register.</p></li>
<li><p>IBL checks the bootmode, if it is not I2C boot or it is I2C boot but
with bus address 0x50, IBL writes bootmode into the DEVSTAT register</p></li>
<li><p>IBL then checks if the bootmode is PCIE boot or not. If it is, it
executes some PCIE workaround to configure the PCIE registers (mainly
to accept spread spectrum clock) and stays inside IBL waiting for
PCIe boot.</p></li>
<li><p>If it is not PCIE boot mode, IBL writes the Boot ROM entry address
into the DSP Program Counter, DSP executes the desired internal ROM
boot mode or boot from I2C bus address 0x50 as normal.</p></li>
</ol>
</div>
<div class="section" id="compilation">
<h4>4.6.3.4.4. Compilation<a class="headerlink" href="#compilation" title="Permalink to this headline">¶</a></h4>
<p>The recommended rule-of-thumb to compiling projects in the Processor SDK
RTOS package is to use the makefiles provided. The makefiles are usable
after setting up your shell/terminal/command prompt environment with the
setupenv.bat or setupenv.sh script located in</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">processor_sdk_rtos_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Refer to <a class="reference external" href="index_overview.html#building-the-sdk">Processor SDK RTOS Building the SDK</a>
guide on how to setup your environment for building within any of the
Processor SDK RTOS packages.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>C66x projects are supported by C6000 Code Generation
Tools 7.4.x. Make sure your environment variable, C6X_GEN_INSTALL_PATH,
is pointing to a valid C6000 compiler. Compiling IBL invokes the C6000
compiler, cl6x, directly. Your PATH variable will need to have
$C6X_GEN_INSTALL_PATH/bin.</p>
</div>
<p>The IBL package can be found in:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">ibl</span>
</pre></div>
</div>
<p>To build:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">ibl</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">make</span>
<span class="n">make</span> <span class="o">&lt;</span><span class="n">IBL_BINARY_NAME</span><span class="o">&gt;</span> <span class="n">ENDIAN</span><span class="o">=&lt;</span><span class="n">BINARY_ENDIANNESS</span><span class="o">&gt;</span> <span class="n">I2C_BUS_ADDR</span><span class="o">=</span><span class="mh">0x51</span>
</pre></div>
</div>
<p><em>&lt;IBL_BINARY_NAME&gt;</em> can be of values: <strong>evm_c6657_i2c</strong> or
<strong>evm_c6678_i2c</strong>. (For C6657 or C6678 platforms, respectively)</p>
<p><em>&lt;BINARY_ENDIANNESS&gt;</em> can be of values: <strong>little</strong> or <strong>big</strong></p>
<p><em>I2C_BUS_ADDR</em> specifies the I2C bus address to use, and has to be 0x51
for C66x SOCs to access the EEPROM.</p>
<p>The resulting output will be in [SDK Install
Path]/pdk_&lt;platform&gt;_&lt;version&gt;/packages/ti/boot/ibl/src/make/bin
directory.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For developers, who want to build IBL in Windows environment. Please
build this using MinGW environment using the instructions provided in
the build_instructions.txt that can be found under
pdk_c66xx_xx_xxpackagestibootibldocibldoc</p>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="flash-writers">
<h4>4.6.3.4.5. Flash Writers<a class="headerlink" href="#flash-writers" title="Permalink to this headline">¶</a></h4>
<p>There are three types of flash memory provided with the C66x SOCs:
EEPROM, NOR, and NAND. Each of these flash memory can hold bootable
application binaries. As such, respective flash writers are provided in:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">writer</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please set your EVM to <strong>NO BOOT</strong> mode before loading
and running any of the flash writers. Flashing in NO BOOT mode is the
safest way since it eliminates any unwarranted interactions with booted
applications.</p>
</div>
<div class="section" id="eeprom-writer">
<h5>4.6.3.4.5.1. EEPROM Writer<a class="headerlink" href="#eeprom-writer" title="Permalink to this headline">¶</a></h5>
<p>The EEPROM Writer is used to write a binary into the EEPROM memory.</p>
<div class="section" id="id109">
<h6>4.6.3.4.5.1.1. Compilation<a class="headerlink" href="#id109" title="Permalink to this headline">¶</a></h6>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">writer</span><span class="o">/</span><span class="n">eeprom</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">build</span>
<span class="n">make</span> <span class="n">all</span>
</pre></div>
</div>
</div>
<div class="section" id="usage">
<h6>4.6.3.4.5.1.2. Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li><p>Set your EVM to <strong>NO BOOT</strong>. Power on, launch target configuration in
CCS, and connect to Core 0. Be sure the GEL file is used and DDR is
initialized.</p></li>
<li><p>Copy the desired binary you want to flash to [SDK Install
Path]/pdk_&lt;platform&gt;_&lt;version&gt;/packages/ti/boot/writer/eeprom/&lt;platform&gt;/bin
directory.</p></li>
<li><p>Rename the binary you copied in the previous step to “app.bin”.</p></li>
<li><p>In CCS, select Core 0 and open the Memory Browser</p></li>
<li><p>In the Memory Browser window, right click and select “Load Memory”</p></li>
<li><p>Load your app.bin to 0x0C000000. Do so by selecting app.bin for the
file, click Next, and input 0x0C000000 for Start Address (Type-size
selected should be 32-bit)</p></li>
<li><p>Load [SDK Install
Path]/pdk_&lt;platform&gt;_&lt;version&gt;/packages/ti/boot/writer/eeprom/&lt;SOC&gt;/bin/eepromwriter_&lt;platform&gt;.out</p></li>
<li><p>Run Core 0. This will program the flash memory.</p></li>
</ol>
<p>If it succeeds, the console will print “EEPROM programming completed
successfully”</p>
</div>
</div>
<div class="section" id="nor-writer">
<h5>4.6.3.4.5.2. NOR Writer<a class="headerlink" href="#nor-writer" title="Permalink to this headline">¶</a></h5>
<p>The NOR Writer is used to write a binary into the NOR memory.</p>
<div class="section" id="id110">
<h6>4.6.3.4.5.2.1. Compilation<a class="headerlink" href="#id110" title="Permalink to this headline">¶</a></h6>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">writer</span><span class="o">/</span><span class="n">nor</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">build</span>
<span class="n">make</span> <span class="n">all</span>
</pre></div>
</div>
</div>
<div class="section" id="id111">
<h6>4.6.3.4.5.2.2. Usage<a class="headerlink" href="#id111" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li><p>Set your EVM to <strong>NO BOOT</strong>. Power on, launch target configuration in
CCS, and connect to Core 0. Be sure the GEL file is used and DDR is
initialized.</p></li>
<li><p>Copy the desired binary you want to flash to [SDK Install
Path]/pdk_&lt;platform&gt;_&lt;version&gt;/packages/ti/boot/writer/nor/&lt;platform&gt;/bin
directory.</p></li>
<li><p>Rename the binary you copied in the previous step to “app.bin”.</p></li>
<li><p>In CCS, select Core 0 and open the Memory Browser</p></li>
<li><p>In the Memory Browser window, right click and select “Load Memory”</p></li>
<li><p>Load your app.bin to 0x80000000. Do so by selecting app.bin for the
file, click Next, and input 0x80000000 for Start Address (Type-size
selected should be 32-bit)</p></li>
<li><p>Load [SDK Install
Path]/pdk_&lt;platform&gt;_&lt;version&gt;/packages/ti/boot/writer/nor/&lt;SOC&gt;/bin/norwriter_&lt;platform&gt;.out</p></li>
<li><p>Run Core 0. This will program the flash memory.</p></li>
</ol>
<p>If it succeeds, the console will print “NOR programming completed
successfully”</p>
</div>
</div>
<div class="section" id="nand-writer">
<h5>4.6.3.4.5.3. NAND Writer<a class="headerlink" href="#nand-writer" title="Permalink to this headline">¶</a></h5>
<p>The NAND Writer is used to write a binary into the NAND memory.</p>
<div class="section" id="id112">
<h6>4.6.3.4.5.3.1. Compilation<a class="headerlink" href="#id112" title="Permalink to this headline">¶</a></h6>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">writer</span><span class="o">/</span><span class="n">nand</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">build</span>
<span class="n">make</span> <span class="n">all</span>
</pre></div>
</div>
</div>
<div class="section" id="id113">
<h6>4.6.3.4.5.3.2. Usage<a class="headerlink" href="#id113" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li><p>Set your EVM to <strong>NO BOOT</strong>. Power on, launch target configuration in
CCS, and connect to Core 0. Be sure the GEL file is used and DDR is
initialized.</p></li>
<li><p>Copy the desired binary you want to flash to [SDK Install
Path]/pdk_&lt;platform&gt;_&lt;version&gt;/packages/ti/boot/writer/nand/&lt;platform&gt;/bin
directory.</p></li>
<li><p>Rename the binary you copied in the previous step to “app.bin”.</p></li>
<li><p>In CCS, select Core 0 and open the Memory Browser</p></li>
<li><p>In the Memory Browser window, right click and select “Load Memory”</p></li>
<li><p>Load your app.bin to 0x80000000. Do so by selecting app.bin for the
file, click Next, and input 0x80000000 for Start Address (Type-size
selected should be 32-bit)</p></li>
<li><p>Load [SDK Install
Path]/pdk_&lt;platform&gt;_&lt;version&gt;/packages/ti/boot/writer/nand/&lt;SOC&gt;/bin/nandwriter_&lt;platform&gt;.out</p></li>
<li><p>Run Core 0. This will program the flash memory.</p></li>
</ol>
<p>If it succeeds, the console will print “NAND programming completed
successfully”</p>
</div>
</div>
</div>
<div class="section" id="id114">
<h4>4.6.3.4.6. Boot Modes<a class="headerlink" href="#id114" title="Permalink to this headline">¶</a></h4>
<div class="section" id="nand-boot">
<h5>4.6.3.4.6.1. NAND Boot<a class="headerlink" href="#nand-boot" title="Permalink to this headline">¶</a></h5>
<img alt="../_images/Nandboot.jpg" src="../_images/Nandboot.jpg" />
<p>NAND boot is a multi-stage process which is designed to boot an
application from NAND flash after reset. Figure below illustrates the
elements of the NAND boot process.</p>
<p>On reset the DSP starts execution with the bootrom which transfers
execution to the secondary bootloader from EEPROM using the I2C slave
bus address 0x51. The secondary bootloader loads the application program
from NAND flash then transfers control to the application. To execute
the NAND bootloader you must ensure the DIP switches for your platform
are properly configured for I2C Master Boot and address 0x51, AND
the boot parameter index dip switch should be set to 2 or 3.</p>
<p>NAND boot supports multiple images booting. Depending on the boot
parameter index dip switch, maximum 2 boot images can be supported. By
default NAND boot only supports a BBLOB image format, if the customer
wants to boot an ELF image,  the IBL configuration table needs to be
modified and re-programmed to EEPROM.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="nor-boot">
<h5>4.6.3.4.6.2. NOR Boot<a class="headerlink" href="#nor-boot" title="Permalink to this headline">¶</a></h5>
<img alt="../_images/Norboot.jpg" src="../_images/Norboot.jpg" />
<p>NOR boot is a multi-stage process which is designed to boot an
application from NOR flash after reset. Figure below illustrates the
elements of the NOR boot process.</p>
<p>On reset the DSP starts execution with the bootrom which transfers
execution to the secondary bootloader from EEPROM using the I2C slave
address 0x51. The secondary bootloader loads the application program
from NOR flash then transfers control to the application. To execute the
NOR bootloader you must ensure the DIP switches for your platform are
properly configured for I2C Master Boot and address 0x51, AND the boot
parameter index switch should be set to 0 or 1.</p>
<p>NOR boot supports multiple images booting. Depending on the boot
parameter index dip switch, maximum 2 boot images can be supported.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="tftp-boot">
<h5>4.6.3.4.6.3. TFTP Boot<a class="headerlink" href="#tftp-boot" title="Permalink to this headline">¶</a></h5>
<img alt="../_images/Emacboot.jpg" src="../_images/Emacboot.jpg" />
<p>EMAC boot is a multi-stage process which is designed to boot an
application from TFTP server after reset. Figure below illustrates the
elements of the EMAC boot process.</p>
<p>On reset the DSP starts execution with the bootrom which transfers
execution to the secondary bootloader from EEPROM using the I2C slave
address 0x51. The secondary bootloader loads the application program
from a remote TFTP server then transfers control to the application. To
execute the EMAC bootloader you must ensure the DIP switches for your
platform are properly configured for I2C Master Boot and address 0x51,
AND the boot parameter index switch should be set to 4. By default EMAC
boot only supports a BBLOB image format, if the customer wants to boot
an ELF image, the IBL configuration table needs to be modified and
re-programmed to EEPROM.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="section" id="updating-the-ibl-ethernet-configurations">
<h6>4.6.3.4.6.3.1. Updating the IBL Ethernet Configurations<a class="headerlink" href="#updating-the-ibl-ethernet-configurations" title="Permalink to this headline">¶</a></h6>
<p>There are two ways to update the IBL ethernet configurations for
ethernet boot.</p>
<p><strong>Using CCS</strong></p>
<ol class="arabic simple">
<li><p>Turn on and connect to your EVM with the appropriate Target
Configuration file.</p></li>
<li><p>Connect to Core 0.</p></li>
<li><p>Go to Run -&gt; Load Program and select i2cparam_0x51_c667#_le_0x500.out
located in [SDK Install
Path]/pdk_&lt;platform&gt;_&lt;version&gt;/packages/ti/boot/ibl/src/make/bin</p></li>
<li><p>Go to Tools -&gt; GEL Files and then right click on GEL Files window and
Load the i2cConfig.gel GEL file, located in [SDK Install
Path]/pdk_&lt;platform&gt;_&lt;version&gt;/packages/ti/boot/ibl/src/make/bin</p></li>
<li><p>Run the program. The following message will be printed on the CCS
console: <em>Run the GEL for the SOC to be configured, press return to
program the I2C.</em> <strong>DO NOT PRESS ENTER UNTIL STEP 6 IS DONE</strong></p></li>
<li><p>Run the GEL script”Scripts -&gt; EVM c6678 IBL” -&gt; setConfig_c6678_main.</p></li>
<li><p>Now press “Enter” in the CCS console window, and the program will
write the boot parameter table to the EEPROM. On success the message
“I2c table write complete” will be printed on the CCS console.</p></li>
</ol>
<p>Please note that the i2cConfig.gel file can be modified via a text
editor before loading and running the script in CCS. Please note that
this gel file contains configuration settings for multiple SOCs and
multiple boot modes.</p>
<p><strong>Using iblConfig Utility Program</strong></p>
<p>The second way to update the IBL ethernet configurations is to use
<strong>iblConfig.out</strong>. This utility program is located under:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">ibl</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">util</span><span class="o">/</span><span class="n">iblConfig</span><span class="o">/</span><span class="n">build</span>
</pre></div>
</div>
<p>In command line, use “make” with the given Makefile to generate
iblConfig.out and input.txt. Please be sure to fill in the parameters
for input.txt before running iblConfig.out; below is an example of
input.txt:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">file_name</span> <span class="o">=</span> <span class="n">ibl</span><span class="p">.</span><span class="n">bin</span>
<span class="n">SOC</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">offset</span> <span class="o">=</span> <span class="mh">0x500</span>
<span class="n">ethBoot</span><span class="o">-</span><span class="n">doBootp</span> <span class="o">=</span> <span class="n">TRUE</span>
<span class="n">ethBoot</span><span class="o">-</span><span class="n">bootFormat</span> <span class="o">=</span> <span class="n">ibl_BOOT_FORMAT_ELF</span>
<span class="n">ethBoot</span><span class="o">-</span><span class="n">ipAddr</span> <span class="o">=</span> <span class="mf">192.168.1.3</span>
<span class="n">ethBoot</span><span class="o">-</span><span class="n">serverIp</span> <span class="o">=</span> <span class="mf">192.168.1.2</span>
<span class="n">ethBoot</span><span class="o">-</span><span class="n">gatewayIp</span> <span class="o">=</span> <span class="mf">192.168.1.1</span>
<span class="n">ethBoot</span><span class="o">-</span><span class="n">netmask</span> <span class="o">=</span> <span class="mf">255.255.255.0</span>
<span class="n">ethBoot</span><span class="o">-</span><span class="n">fileName</span> <span class="o">=</span>
</pre></div>
</div>
<p>The first 3 parameters must be filled in for iblConfig.out to work:</p>
<ul class="simple">
<li><p>file_name refers to the IBL binary file to update. This file must be
in the same directory as iblConfig.out.</p></li>
<li><p>SOC refers to the SOC being used. Please enter <strong>6 for C6678, and 8
for C6657</strong>.</p></li>
<li><p>offset refers to an offset space in the IBL. The value is 0x500 for
C6678, and C6657</p></li>
</ul>
<p>The ethernet parameters (the entries beginning with ethBoot) refer to
specific ethernet configurations. If they are not specified, they will
be defaulted to the values in the [SDK Install
Path]/pdk_&lt;platform&gt;_&lt;version&gt;/packages/ti/boot/ibl/src/util/iblConfig/src/SOC.h
file. In the example above, the ethernet boot file name will be
defaulted to c6678-le.bin when iblConfig.out is run.</p>
<p>After running iblConfig.out and updating the IBL binary, you must
flash the modified IBL binary to your EVM. You can do this as part of
program_evm (refer to <a class="reference external" href="http://processors.wiki.ti.com/index.php/Program_EVM_UG">Processor SDK Flashing Bootable
Images</a>) or
you can flash it individually using eepromwriter (refer to “Flash
Writers” section above).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you updated the IBL with iblConfig and flashed it
with eepromwriter, you should <strong>NOT</strong> use
i2cparam_0x51_c667#_le_0x500.out and iblConfig.gel - this would
overwrite the changes you made to the IBL.</p>
</div>
</div>
<div class="section" id="id115">
<h6>4.6.3.4.6.3.2. Compilation<a class="headerlink" href="#id115" title="Permalink to this headline">¶</a></h6>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">i2c</span><span class="o">/</span><span class="n">tftp</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">build</span>
<span class="n">make</span> <span class="n">all</span>
</pre></div>
</div>
</div>
<div class="section" id="id116">
<h6>4.6.3.4.6.3.3. Usage<a class="headerlink" href="#id116" title="Permalink to this headline">¶</a></h6>
<p>After your IBL ethernet settings are configured correctly and flashed
into EEPROM memory, follow these steps to continue the TFTP booting
process:</p>
<ol class="arabic simple">
<li><p>Start a TFTP server on your local PC. Your local PC will be the one
sending the image to be booted, so make sure your PC and EVM are
connected to the same subnet via ethernet</p></li>
<li><p>Copy i2ctftpboot_&lt;platform&gt;.out (refer to compilation step above) to
your base TFTP directory</p></li>
<li><p>Rename i2ctftpboot_&lt;platform&gt;.out to app.out</p></li>
<li><p>Set the IP address of the PC that is running the TFTP server to
192.168.2.101, since by default IBL will set the EVM IP address to
192.168.2.100 and the TFTP server IP address to 192.168.2.101</p></li>
<li><p>Set EVM to TFTP boot mode and power on the EVM</p></li>
</ol>
<p>Your PC will send the application image to the EVM to boot. Open an UART
terminal to view the output.</p>
</div>
</div>
<div class="section" id="post-boot">
<h5>4.6.3.4.6.4. POST Boot<a class="headerlink" href="#post-boot" title="Permalink to this headline">¶</a></h5>
<p>POST (Power On Self Test) Boot is designed to do a quick self-diagnostic
upon boot. The POST application itself is located in</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">post</span>
</pre></div>
</div>
<p>This application should already be compiled and flashed into EEPROM
out-of-box. Below instructions are for re-compilation or re-flashing
only.</p>
<div class="section" id="id117">
<h6>4.6.3.4.6.4.1. Compilation<a class="headerlink" href="#id117" title="Permalink to this headline">¶</a></h6>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">post</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">build</span>
<span class="n">make</span> <span class="n">all</span>
<span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">post</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">bin</span>
<span class="p">.</span><span class="o">/</span><span class="n">post_romparse</span><span class="p">.</span><span class="n">sh</span>
</pre></div>
</div>
<p>Note: You would need to use post_romparse.bat instead of the *.sh
version if your host system is running on Windows.</p>
</div>
<div class="section" id="id118">
<h6>4.6.3.4.6.4.2. Usage<a class="headerlink" href="#id118" title="Permalink to this headline">¶</a></h6>
<p>To flash the POST binary into EEPROM:</p>
<ol class="arabic simple">
<li><p>Refer to above Flash Writers section on flashing EEPROM memory. The
binary you are flashing is “post_i2crom.bin”.</p></li>
<li><p>Before running the last step of the EEPROM flashing instruction to
run the DSP core, modify the <strong>eepromwriter_input.txt</strong> to use
<strong>0x50</strong> for the bus_addr field. The <strong>eepromwriter_input.txt</strong> file
is located in:</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">writers</span><span class="o">/</span><span class="n">eeprom</span><span class="o">/&lt;</span><span class="n">SOC</span><span class="o">&gt;/</span><span class="n">bin</span>
</pre></div>
</div>
<p>Configure your EVM’s DIP Switches accordingly to I2C POST BOOT mode. The
POST application will be loaded from EEPROM 0x50 and output will be
available over the UART serial console.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="ethernet-boot">
<h5>4.6.3.4.6.5. ETHERNET Boot<a class="headerlink" href="#ethernet-boot" title="Permalink to this headline">¶</a></h5>
<p>ETHERNET Boot uses Ethernet sockets to transfer a bootable image from a
host to the EVM. After powering on in Ethernet boot mode, the EVM will
send BOOTP packets at regular interval - this gives visibility of the
MAC ID of the EVM to the network.</p>
<p>Below are instructions on compiling and running an example to send a
simple program to the EVM while in Ethernet boot mode.</p>
<div class="section" id="id119">
<h6>4.6.3.4.6.5.1. Compilation<a class="headerlink" href="#id119" title="Permalink to this headline">¶</a></h6>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">ethernet</span><span class="o">/</span><span class="n">Utilities</span>
<span class="n">make</span> <span class="n">all</span>
<span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">ethernet</span><span class="o">/</span><span class="n">simple</span>
<span class="n">make</span> <span class="n">all</span>
</pre></div>
</div>
</div>
<div class="section" id="id120">
<h6>4.6.3.4.6.5.2. Usage<a class="headerlink" href="#id120" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li><p>Set the EVM’s DIP switches to Ethernet boot mode. Connect Ethernet
cables such that the EVM and your Host PC are on the same network.</p></li>
<li><p>Power on the EVM. The EVM will start sending BOOTP packets. Read the
packets for the EVM’s MAC ID. You can read the packet by using a
network tool such as Wireshark.</p></li>
<li><p>On your Host PC, add an ARP entry to associate the EVM’s MAC ID with
an IP address on your network.</p></li>
<li><p>Use the pcsendpkt utility provided to send the simple.eth program
compiled in the compilation step to the EVM.</p></li>
</ol>
<p>To use pcsendpkt:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">ethernet</span><span class="o">/</span><span class="n">Utilities</span>
<span class="n">pcsendpkt</span> <span class="n">simple</span><span class="p">.</span><span class="n">eth</span> <span class="o">&lt;</span><span class="n">EVM</span> <span class="n">IP</span> <span class="n">ADDRESS</span><span class="o">&gt;</span>
</pre></div>
</div>
<p><em>&lt;EVM IP ADDRESS&gt;</em> is the IP address you assigned the EVM in step 3</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<blockquote>
<div><p>If you are on a Linux Host PC, you may need to recompile pcsendpkt locally with GCC</p>
</div></blockquote>
<p>To verify, connect to the EVM’s Core 0 via CCS and check that the A1
register is set to 0x11223344</p>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="srio-boot">
<h5>4.6.3.4.6.6. SRIO Boot<a class="headerlink" href="#srio-boot" title="Permalink to this headline">¶</a></h5>
<p>SRIO boot will attempt to load and run a binary image received via SRIO.
An example can be found in:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">srio</span>
</pre></div>
</div>
<p>Below are instructions on compiling and running the SRIO boot example.</p>
<div class="section" id="id121">
<h6>4.6.3.4.6.6.1. Compilation<a class="headerlink" href="#id121" title="Permalink to this headline">¶</a></h6>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">srio</span><span class="o">/</span><span class="n">srioboot_ddrinit</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">build</span>
<span class="n">make</span> <span class="n">all</span>
<span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">srio</span><span class="o">/</span><span class="n">srioboot_ddrinit</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">bin</span>
<span class="p">.</span><span class="o">/</span><span class="n">srioboot_ddrinit_elf2HBin</span><span class="p">.</span><span class="n">sh</span>
<span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">srio</span><span class="o">/</span><span class="n">srioboot_helloworld</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">build</span>
<span class="n">make</span> <span class="n">all</span>
<span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">srio</span><span class="o">/</span><span class="n">srioboot_helloworld</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">bin</span>
<span class="p">.</span><span class="o">/</span><span class="n">helloworld_elf2HBin</span><span class="p">.</span><span class="n">sh</span>
<span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">srio</span><span class="o">/</span><span class="n">srioboot_example</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">build</span>
<span class="n">make</span> <span class="n">all</span>
</pre></div>
</div>
<p>Note: You would need to use srioboot_ddrinit_elf2HBin.bat and
helloworld_elf2HBin.bat instead of their *.sh version respectively if
your host system is running on Windows. Compilation of the projects
should be done in the order stated above.</p>
</div>
<div class="section" id="id122">
<h6>4.6.3.4.6.6.2. Usage<a class="headerlink" href="#id122" title="Permalink to this headline">¶</a></h6>
<p>You will need to have 2 EVMs - both should be set to SRIO boot mode. The
two EVMs will be connected through the AMC breakout board (lane x of one
slot should be connected to lane x of the other breakout slot). One EVM
will be acting as the host (referred to as the HOST EVM) and the other
EVM will be doing the booting (referred to as the BOOTING EVM).</p>
<ol class="arabic simple">
<li><p>Compile srioboot_example_evm66XXl.out</p></li>
<li><p>Connect the BOOTING EVM’s UART serial port to your PC using the
RS-232 cable</p></li>
<li><p>Connect a JTAG emulator on the HOST EVM</p></li>
<li><p>Power on both EVMs</p></li>
<li><p>Open an UART terminal to view the BOOTING EVM’s output. (Remember to
set the baud rate to 115.2k bps, 8-bit data, no parity, 1-bit stop,
and no flow control)</p></li>
<li><p>Connect to the HOST EVM via Code Composer Studio (CCS is recommended
to be version 6 or higher). Launch target configuration for your HOST
EVM and connect to DSP0.</p></li>
<li><p>Load and run srioboot_example_evm66xxl.out on your HOST EVM</p></li>
</ol>
<p>CCS console for your HOST EVM should display:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span> <span class="n">SRIO</span> <span class="n">Boot</span> <span class="n">Host</span> <span class="n">Example</span> <span class="n">Version</span> <span class="mf">01.00.00.01</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span> <span class="n">Transfer</span> <span class="n">DDR</span> <span class="n">init</span> <span class="n">code</span> <span class="n">via</span> <span class="n">SRIO</span> <span class="n">successfully</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span> <span class="n">Transfer</span> <span class="n">boot</span> <span class="n">code</span> <span class="n">via</span> <span class="n">SRIO</span> <span class="n">successfully</span>
</pre></div>
</div>
<p>Terminal for your BOOTING EVM should display:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">SRIO</span> <span class="n">Boot</span> <span class="n">Hello</span> <span class="n">World</span> <span class="n">Example</span> <span class="n">Version</span> <span class="mf">01.00.00.01</span>
<span class="n">Booting</span> <span class="n">Hello</span> <span class="n">World</span> <span class="n">image</span> <span class="n">on</span> <span class="n">Core</span> <span class="mi">0</span> <span class="n">from</span> <span class="n">SRIO</span> <span class="p">...</span>
<span class="n">Booting</span> <span class="n">Hello</span> <span class="n">World</span> <span class="n">image</span> <span class="n">on</span> <span class="n">Core</span> <span class="mi">1</span> <span class="n">from</span> <span class="n">Core</span> <span class="mi">0</span> <span class="p">...</span>
<span class="n">Booting</span> <span class="n">Hello</span> <span class="n">World</span> <span class="n">image</span> <span class="n">on</span> <span class="n">Core</span> <span class="mi">2</span> <span class="n">from</span> <span class="n">Core</span> <span class="mi">0</span> <span class="p">...</span>
<span class="n">Booting</span> <span class="n">Hello</span> <span class="n">World</span> <span class="n">image</span> <span class="n">on</span> <span class="n">Core</span> <span class="mi">3</span> <span class="n">from</span> <span class="n">Core</span> <span class="mi">0</span> <span class="p">...</span>
<span class="n">Booting</span> <span class="n">Hello</span> <span class="n">World</span> <span class="n">image</span> <span class="n">on</span> <span class="n">Core</span> <span class="mi">4</span> <span class="n">from</span> <span class="n">Core</span> <span class="mi">0</span> <span class="p">...</span>
<span class="n">Booting</span> <span class="n">Hello</span> <span class="n">World</span> <span class="n">image</span> <span class="n">on</span> <span class="n">Core</span> <span class="mi">5</span> <span class="n">from</span> <span class="n">Core</span> <span class="mi">0</span> <span class="p">...</span>
<span class="n">Booting</span> <span class="n">Hello</span> <span class="n">World</span> <span class="n">image</span> <span class="n">on</span> <span class="n">Core</span> <span class="mi">6</span> <span class="n">from</span> <span class="n">Core</span> <span class="mi">0</span> <span class="p">...</span>
<span class="n">Booting</span> <span class="n">Hello</span> <span class="n">World</span> <span class="n">image</span> <span class="n">on</span> <span class="n">Core</span> <span class="mi">7</span> <span class="n">from</span> <span class="n">Core</span> <span class="mi">0</span> <span class="p">...</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="pcie-boot">
<h5>4.6.3.4.6.7. PCIE Boot<a class="headerlink" href="#pcie-boot" title="Permalink to this headline">¶</a></h5>
<p>PCIE boot will attempt to load and run a binary image upon enumeration.
Example is located:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">pcie</span>
</pre></div>
</div>
<p>Below are instructions on compiling and running the PCIE boot example.</p>
<div class="section" id="id123">
<h6>4.6.3.4.6.7.1. Compilation<a class="headerlink" href="#id123" title="Permalink to this headline">¶</a></h6>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">pcie</span><span class="o">/</span><span class="n">pcieboot_ddrinit</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">build</span>
<span class="n">make</span> <span class="n">all</span>
<span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">pcie</span><span class="o">/</span><span class="n">pcieboot_helloworld</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">build</span>
<span class="n">make</span> <span class="n">all</span>
</pre></div>
</div>
<p>Additionally for C6678 EVM:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">pcie</span><span class="o">/</span><span class="n">pcieboot_interrupt</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">build</span>
<span class="n">make</span> <span class="n">all</span>
<span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">pcie</span><span class="o">/</span><span class="n">pcieboot_localreset</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;/</span><span class="n">build</span>
<span class="n">make</span> <span class="n">all</span>
</pre></div>
</div>
<p>The POST application can also be used as a PCIE Boot example. Run the
corresponding *_elf2HBin.bat (or .sh) to convert the .out files into
PCIE bootable binaries.</p>
</div>
<div class="section" id="id124">
<h6>4.6.3.4.6.7.2. Usage<a class="headerlink" href="#id124" title="Permalink to this headline">¶</a></h6>
<p>An AMC to PCIE adaptor card, a TMS320C66xxL EVM card and a Linux PC are
required to do the test. The test is verified on both TMS320C6670L and
TMS320C6678L cards, with both 32-bit and 64-Linux PCs running Ubuntu
10.04. Other Linux OS are expected to work as well.</p>
<ul class="simple">
<li><p>Before connect the system, please update IBL with the latest from
Processor SDK</p></li>
<li><p>Set EVM card to PCIE boot (refer to hardware page)</p></li>
<li><p>Assemble the EVM card into the adaptor card</p></li>
<li><p>Connect the URAT cable from EVM card to a Linux PC’s USB port or
serial port</p></li>
<li><p>Completely shut off the PC power supply (by disconnecting the power
cord), insert the AMC adaptor card (with EVM mounted) into an open
PCIE slot in PC’s motherboard</p></li>
<li><p>Supply the power to PC, wait for a few seconds and power on the PC.</p></li>
<li><p>Make sure the PCIE device is correctly enumerated by PC by checking
below, note DEVICE_ID field is changed from 0x8888 to 0xb005 which is
programmed in IBL.</p></li>
<li><p>Either enter PC’s BIOS setting when PC is booting up, a new PCIE
device should be populated in the PCIE slot where card is inserted,
shown as a “Multimedia device”.</p></li>
<li><p>Or, type “lspci –n” under Linux command shell after Linux OS is
loaded, a TI device (VENDOR_ID: 0x104c) should be in the list:</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>local-ubuntu:~$ lspci -n
00:00.0 0600: 8086:2774
00:1b.0 0403: 8086:27d8 (rev 01)
….
00:1f.3 0c05: 8086:27da (rev 01)
01:00.0 0480: 104c:b005 (rev 01)
03:00.0 0200: 14e4:1677 (rev 01)
Similarly, one can type “lspci”,
local-ubuntu:~$ lspci
….
00:1f.3 SMBus: Intel Corporation N10/ICH 7 Family SMBus Controller (rev
01)
01:00.0 Multimedia controller: Texas Instruments Device b005 (rev 01)
....
</pre></div>
</div>
<ul class="simple">
<li><p>The PCIE BARn (n = 0, 1, 2, … , 5) registers are written by Linux PC
after enumeration, they should be non-zero. Optionally, if a JTAG
emulator is available, one can verify this by looking at address
starting from 0x21801010 for 6 32-bit word.</p></li>
<li><p>Prepare pciedemo.ko in the Linux PC</p></li>
<li><p>On the Linux PC open a new terminal window to run minicom. First run
“sudo minicom –s” to set the correct configuration: 115200bps, 8-N-1,
Hardware flow control: OFF, Software flow control: OFF, and select
the correct Serial Device. Save then run “sudo minicom” to monitor
the port.</p></li>
<li><p>Type “sudo insmod pciedemo.ko”</p></li>
<li><p>If a JTAG emulator is available, one can verify that the PC registers
for cores other than core 0 should be inside DDR; and magic address
for cores other than core 0 should be written with 0xBABEFACE.</p></li>
</ul>
</div>
<div class="section" id="procedure-to-build-and-run-linux-host-loader">
<h6>4.6.3.4.6.7.3. Procedure to build and run Linux host loader<a class="headerlink" href="#procedure-to-build-and-run-linux-host-loader" title="Permalink to this headline">¶</a></h6>
<ul class="simple">
<li><p>Create a folder (e.g. pcie_test) in a Linux machine. Copy pciedemo.c,
Makefile, pcieDdrInit_66xx.h, pcieBootCode_66xx.h,
pcieInterrupt_66xx.h and post_66xx.h from
toolsboot_loaderexamplespcielinux_host_loader to the folder.</p></li>
<li><p>Type “make”, a pciedemo.ko file should be created</p></li>
<li><p>By default, this will build the “HelloWorld” demo on little endian
6678, which is controlled by the following Marcos in pciedemo.c:</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#define BIG_ENDIAN 0</span>
<span class="cp">#define HELLO_WORLD_DEMO 1</span>
<span class="cp">#define POST_DEMO 0</span>
<span class="cp">#define EDMA_INTC_DEMO 0</span>
<span class="cp">#define EVMC6678L 1</span>
<span class="cp">#define EVMC6670L 0</span>
</pre></div>
</div>
<p>One must select the endianness, demo program and target type by toggling
between 0 and 1 accordingly. Then, type “make clean” and type “make” to
rebuild the pciedemo.ko.</p>
<p>Note: “HelloWorld” and EDMA_INTC demos can be run on both endianness.
POST demo can be run on little endian only.</p>
<ul class="simple">
<li><p>To insert the module into kernel, type “sudo insmod pciedemo.ko”; to
view the kernel message, type “dmesg”; to remove the module from
kernel, type “sudo rmmod</p></li>
</ul>
<p>pciedemo.ko”</p>
</div>
<div class="section" id="the-role-of-ibl-in-pcie-boot-mode">
<h6>4.6.3.4.6.7.4. The role of IBL in PCIE boot mode<a class="headerlink" href="#the-role-of-ibl-in-pcie-boot-mode" title="Permalink to this headline">¶</a></h6>
<p>The Intermediate Boot Loader (IBL) is flashed into I2C EEPROM bus
address 0x51. IBL provides a workaround for the PLL lockup issue (please
refer to C6678 errata document, February 2011, advisory 8 for details on
the PLL lockup issue). For ROM boot modes (EMAC, SRIO, PCIE, Hyperlink,
etc) and I2C boot mode with bus address 0x50, DSP will initially boot
from I2C EEPROM bus address 0x51 which does the PLL reset workaround,
updates the DEVSTAT for appropriate values based on the DIP switch
settings (SW3 through SW6 settings) and then re-enters the ROM to
accomplish the desired boot mode. Please note that the re-entry is done
for all boot modes except for PCIE boot mode and I2C boot mode with bus
address 0x51.</p>
<p>Below are the steps done in the IBL in PCIE boot mode:</p>
<ul class="simple">
<li><p>FPGA samples the boot mode pins</p></li>
<li><p>FPGA forces the DSP to boot via I2C bus address 0x51</p></li>
<li><p>PLL is initialized correctly by the IBL on the I2C.</p></li>
<li><p>IBL reads the sampled boot mode from an FPGA register.</p></li>
<li><p>IBL checks the boot mode, if it is not I2C boot or it is I2C boot but
with bus address 0x50, IBL writes boot mode into the DEVSTAT register</p></li>
<li><p>IBL then checks if the boot mode is PCIE boot or not. If it is, it
executes some PCIE workaround to configure the PCIE registers (mainly
to accept spread spectrum clock) and stays inside IBL by first
clearing the magic address and then monitoring it for PCIE boot.</p></li>
</ul>
<p>For PCIE demos with DDR memory is used, proper DDR configuration is
required, this doesn’t need the full IBL functionality. Typically DDR
can be initialized in two ways:</p>
<ul class="simple">
<li><p>The Linux host initializes the DDR registers directly through PCIE
link.</p></li>
<li><p>A DDR initialization image is downloaded in the L2 first to
initialize the DDR and then reset the magic address with value 0. And
then the application image is downloaded in</p></li>
</ul>
<p>the DDR. In Processor SDK, the second approach is used.</p>
</div>
<div class="section" id="how-helloworld-boot-example-works">
<h6>4.6.3.4.6.7.5. How HelloWorld boot example works<a class="headerlink" href="#how-helloworld-boot-example-works" title="Permalink to this headline">¶</a></h6>
<p>The Linux host first pushes the DDR init boot image data to L2 memory of
core 0, then writes the boot entry address of the DDR init boot image to
the magic address on core 0, both via PCIE. When the EVM is in PCIE boot
mode, the IBL code running on the DSP core 0 polls the entry address and
jumps to that address and starts to boot (initialize the DDR). After DDR
is properly initialized, the DDR init code clears the magic address and
keeps on polling it.</p>
<p>Linux host then pushes the HelloWorld boot image data to DDR memory,
then writes the boot entry address of the HelloWorld boot image to the
magic address on core 0 to boot core 0. Core 0 starts to boot and print
the “Hello World” booting information, and then boot all the other cores
by writing the address of _c_int00 to the magic address on other cores
and sending an IPC interrupt to other cores. The RBL running on other
cores will jump to _c_int00 and start to boot, each core will write
0xBABEFACE to its magic address by running a function
write_boot_magic_number().</p>
<p>Note that host boot application needs to wait for some time after
pushing the DDR init boot image and before pushing the HelloWorld boot
image to the DDR, this will ensure DDR is properly initialized.</p>
</div>
<div class="section" id="how-post-boot-example-works">
<h6>4.6.3.4.6.7.6. How POST boot example works<a class="headerlink" href="#how-post-boot-example-works" title="Permalink to this headline">¶</a></h6>
<p>The POST example uses L2 only. The Linux host first pushes the POST boot
image data to L2 memory of core 0, then writes the boot entry address of
the POST to the magic address on core 0, both via PCIE. The IBL code
running on the DSP core 0 polls the entry address and jumps to that
address and starts to boot.</p>
</div>
<div class="section" id="how-dsp-local-reset-example-works">
<h6>4.6.3.4.6.7.7. How DSP local reset example works<a class="headerlink" href="#how-dsp-local-reset-example-works" title="Permalink to this headline">¶</a></h6>
<p>A user may want to re-run a PCIE demo without power cycle the Linux PC.
There is a need to reset the DSP chip from host software. There are
several types of resets: hard reset, soft reset and CPU local reset.
Hard reset will reset everything on the device except the PLLs, test,
emulation logic, and reset isolation modules. Since PCIE doesn’t support
reset isolation, a hard reset will reset PCIE module as well and all the
configured PCIE registers (PCIE MMRs) will be lost. Soft reset will
behave like a hard reset except that the stick bits of PCIE MMRs are
retained. The PC can’t communicate with PCIE card anymore in both hard
reset and soft reset cases.</p>
<p>To reset the DSP while keeping the PCIE untouched, the local reset
example does the following:</p>
<ul class="simple">
<li><p>Put all cores in reset via PSC</p></li>
<li><p>Disable all modules except PCIE and cores via PSC</p></li>
<li><p>Configure chip level registers DSP_BOOT_ADDRn and IPCGRn: Here the
header array converted from DSP local reset example is loaded into
each core via PCIE; the _c_int00 is then written to each
DSP_BOOT_ADDRn; finally IPCGRn is written to jump start the DSP local
reset example program, which simply polls magic address for a
secondary boot.</p></li>
<li><p>Enable all modules previous disabled via PSC</p></li>
<li><p>Pull all cores out of reset via PSC</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is IBL (in local L2) that monitors magic address
and boots the DDR init (in local L2) or POST (in local L2) or
EDMA-interrupt (in local L2) in those demos. If one wants to load
his/her own boot demo code, then it shouldn’t overlap with the IBL
code. As a guideline, the IBL uses memory from 0x00800000 to
0x0081BDFF. To check the exact memory usage, you can re-build the IBL
by following the instructions in
toolsboot_loaderibldocbuild_instructions.txt and check the
resulting ibl_c66x_init.map file. In addition, following local L2 is
reserved by RBL and shouldn’t be used: for 6678 ROM PG 1.0, 0x00872DC0
– 0x0087FFFF; for 6670 ROM PG 1.0, 0x008F2DC0 – 0x008FFFFF.</p>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="k2g">
<h3>4.6.3.5. K2G<a class="headerlink" href="#k2g" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id125">
<h4>4.6.3.5.1. Overview<a class="headerlink" href="#id125" title="Permalink to this headline">¶</a></h4>
<p>The Secondary Bootloader (SBL) for K2G does basic hardware
initialization for the board to load and run applications.</p>
</div>
<div class="section" id="id126">
<h4>4.6.3.5.2. Bootloader Execution Sequence<a class="headerlink" href="#id126" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>Power On Reset occurs</p></li>
<li><p>ROM Bootloader (RBL) executes. It checks for bootmode and attempts to
load+run the SBL from that bootmode.</p></li>
<li><p>SBL begins execution from internal memory (MSMC RAM)</p>
<ul>
<li><p>Board Initialization is done by a call to <strong>Board_init()</strong> API.
For additional details refer to <a class="reference external" href="index_board.html#board-support">Processor SDK Board
Support</a>.</p></li>
<li><p>SBL setup includes configuring Pinmux, enable peripheral clocks,
set up PLLs, and configure EMIF for DDR.</p></li>
</ul>
</li>
<li><p>SBL finishes setup and looks for “app” to execute next. This
user-modifiable application may reside in SD card or QSPI memory
depending on the bootmode chosen.</p></li>
<li><p>Once located, app will be loaded into memory and execution will be
branched to the application’s entry address</p></li>
</ul>
</div>
<div class="section" id="id127">
<h4>4.6.3.5.3. Tools and Binary Formats<a class="headerlink" href="#id127" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="making-bootable-sbl-image-mlo">
<h4>4.6.3.5.4. Making Bootable SBL image (MLO)<a class="headerlink" href="#making-bootable-sbl-image-mlo" title="Permalink to this headline">¶</a></h4>
<p>RBL loads and runs “MLO”, which is a .out executable formatted by TI
tools. To make a .out, such as SBL, bootable by ROM, you must follow
these steps:</p>
<ol class="arabic simple">
<li><p><strong>armhex [.out file] [.rmd file]</strong></p>
<ul class="simple">
<li><p>.out file is the file you want to boot, such as sbl.out</p></li>
<li><p>.rmd file is an input file to specify sections information. An
example can be found in:
&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/board/evmK2G/build/sbl.rmd</p></li>
<li><p>armhex is a tool in TI ARM CGT compiler. This generates a [hex
file], name of which is specified by the .rmd file</p></li>
</ul>
</li>
<li><p><strong>b2ccs [hex file] [ccs file]</strong></p>
<ul class="simple">
<li><p>hex file is the output from the previous step</p></li>
<li><p>ccs file can be name of your choosing</p></li>
</ul>
</li>
<li><p><strong>ccsAddGphdr -infile [ccs file] -outfile [gphdr file] -headerEndian
BE</strong></p>
<ul class="simple">
<li><p>gphdr file can be the name of your choosing</p></li>
</ul>
</li>
<li><p><strong>ccsAddGptlr -infile [gphdr file] -outfile [gptlr file]</strong></p>
<ul class="simple">
<li><p>gptlr file can be the name of your choosing</p></li>
</ul>
</li>
<li><p><strong>byteswapccs [gptlr file] [MLO ccs file]</strong></p>
<ul class="simple">
<li><p>MLO ccs file can be the name of your choosing</p></li>
</ul>
</li>
<li><p><strong>ccs2bin -swap [MLO ccs file] MLO</strong></p>
<ul class="simple">
<li><p>MLO will be created after this step</p></li>
</ul>
</li>
</ol>
<p>Armhex is part of TI ARM CGT, in
<strong>&lt;CCS_INSTALL_DIR&gt;/tools/compiler/ti-cgt-arm_x.x.x/bin</strong>. The rest of
the tools can be found in:
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools</strong></p>
</div>
<div class="section" id="making-loadable-user-application-image-app">
<h4>4.6.3.5.5. Making Loadable User Application image (app)<a class="headerlink" href="#making-loadable-user-application-image-app" title="Permalink to this headline">¶</a></h4>
<p>For converting the compiled .out files to a format loadable by TI’s
Secondary Boot Loader (SBL), <strong>you must follow these two steps:</strong></p>
<ol class="arabic simple">
<li><p><strong>out2rprc.exe [.out file] [rprc output]</strong></p></li>
<li><p><strong>MulticoreImageGen.exe LE 55 [output name] 0 [rprc output]</strong></p></li>
</ol>
<p>Out2rprc.exe and MulticoreImageGen.exe are tools supplied by TI and can
be located in the <strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools</strong>
folder. “rprc output” can be any spare name of your choosing. “output
name” can also be any name of your choosing.</p>
<p>The ‘0’ used in step 2 refers to the Core ID to boot. By default, ‘0’ is
MPU (Cortex A15) core 0. You can input a different value to boot to
other cores. Valid values are:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 63%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Core</p></th>
<th class="head"><p>Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>MPU Core 0</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>DSP Core 0</p></td>
<td><p>5</p></td>
</tr>
</tbody>
</table>
<p>If MPU SMP is chosen, the same boot image and entry will be used for all
MPU cores. SBL can also parse multiple boot images that are concatenated
together. Simply use MulticoreImageGen as such:</p>
<p><strong>MulticoreImageGen.exe LE 55 [output name] [Core ID a] [rprc output a]
[Core ID b] [rprc output b] [Core ID c] [rprc output c] …</strong></p>
</div>
<div class="section" id="id128">
<h4>4.6.3.5.6. Boot Modes<a class="headerlink" href="#id128" title="Permalink to this headline">¶</a></h4>
<p>This release of SBL supports MMCSD and QSPI boot modes.</p>
<div class="section" id="mmcsd-boot-mode">
<h5>4.6.3.5.6.1. MMCSD Boot Mode<a class="headerlink" href="#mmcsd-boot-mode" title="Permalink to this headline">¶</a></h5>
<div class="section" id="id129">
<h6>4.6.3.5.6.1.1. Preparing the SD card<a class="headerlink" href="#id129" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li><p>To boot the target, the SD card needs to be bootable. Follow the
steps at <a class="reference external" href="index_overview.html#windows-sd-card-creation-guide">Creating bootable SD card in windows</a>
or <a class="reference external" href="index_overview.html#linux-sd-card-creation-guide">Creating bootable SD card in Linux</a>.</p></li>
<li><p>Copy “MLO” and “app” to your SD card.</p>
<ul class="simple">
<li><p>MLO is the SBL formatted by the aforementioned tools. A pre-built
MLO can be found at:
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/binary/evmK2G/mmcsd/bin</strong></p></li>
<li><p>app is the target application to be booted and also formatted by
the aforementioned tools. (Note that the tools for making the
bootable MLO and the loadable app are different).</p></li>
</ul>
</li>
</ol>
</div>
<div class="section" id="id130">
<h6>4.6.3.5.6.1.2. Booting via SD Card<a class="headerlink" href="#id130" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li><p>Insert micro SD card into the SD card slot of the board</p></li>
<li><p>Set the board to MMC/SD bootmode by configuring the DIP switches to
‘0111’. Verify the bootmode on the LCD display on your board</p></li>
<li><p>Open a serial communication terminal (such as TeraTerm, MiniCom,
etc.) on host PC and connect to the UART console port</p></li>
<li><p>Power on the board</p></li>
</ol>
<div class="line-block">
<div class="line">Below is an example of K2G SBL successfully booting the diagnostic
application:</div>
</div>
<img alt="../_images/K2g_boot_diag.jpg" src="../_images/K2g_boot_diag.jpg" />
</div>
</div>
<div class="section" id="qspi-boot-mode">
<h5>4.6.3.5.6.2. QSPI Boot Mode<a class="headerlink" href="#qspi-boot-mode" title="Permalink to this headline">¶</a></h5>
<div class="section" id="preparing-qspi-flash">
<h6>4.6.3.5.6.2.1. Preparing QSPI Flash<a class="headerlink" href="#preparing-qspi-flash" title="Permalink to this headline">¶</a></h6>
<p>MLO and app needs to be flashed into QSPI memory so that they can be
booted. MLO will reside at offset 0 and app will reside at offset
0x80000. QSPI flash memory map:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 76%" />
<col style="width: 24%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Offset 0x0</p></td>
<td><p>MLO</p></td>
</tr>
<tr class="row-even"><td><p>Offset 0x80000</p></td>
<td><p>app</p></td>
</tr>
</tbody>
</table>
<p>The images can be flashed into QSPI flash by following steps given
below:</p>
<ol class="arabic simple">
<li><p>Copy MLO, app, and config to SD card</p>
<ul class="simple">
<li><p>MLO is the SBL formatted by the aforementioned tools. A pre-built
MLO can be found at:
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/binary/evmK2G/qspi/bin</strong></p></li>
<li><p>app is the target application to be booted and also formatted by
the aforementioned tools. (Note that the tools for making the
bootable MLO and the loadable app are different).</p></li>
<li><p>config helps specify the memory map. The default config file can
be found at:
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools/flashWriter/qspi</strong>.
This config file may be altered to custom user settings if needed.</p></li>
</ul>
</li>
<li><p>In the SD card, rename MLO to “boot”. This is the default name
specified by the config file.</p></li>
<li><p>Insert the SD card into the SD card slot on the board</p></li>
<li><p>Connect to the board with CCS. Launch target configuration and
connect to the ARM A15 core. GEL file will run on-connect and do
basic board-level initialization</p></li>
<li><p>Load the flash writer, qspi_flash_writer.out, to the connected core</p>
<ul class="simple">
<li><p>A pre-built qspi_flash_writer.out can be found at:
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools/flashWriter/qspi/bin/evmK2G</strong></p></li>
</ul>
</li>
<li><p>Run the QSPI flash writer application. You will see the following
logs on the EVM’s UART console:</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>*** PDK QSPI Flash Writer ***
Copying &#39;boot&#39; to local memory
Begin flashing &#39;boot&#39; into QSPI
Finished flashing &#39;boot&#39; with size 20010 at offset 0
Copying &#39;app&#39; to local memory
Begin flashing &#39;app&#39; into QSPI
Finished flashing &#39;app&#39; with size 19398 at offset 80000
Flashing completed!
</pre></div>
</div>
<p>This application will flash the image at required offset without taking
into consideration any overwriting to previously flashed image.</p>
</div>
<div class="section" id="id131">
<h6>4.6.3.5.6.2.2. Booting via QSPI<a class="headerlink" href="#id131" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li><p>Set the board to QSPI-48 bootmode by configuring the DIP switches to
‘1111’. Verify the bootmode on the LCD display on your board</p></li>
<li><p>Open a serial communication terminal (such as TeraTerm, MiniCom,
etc.) on host PC and connect to the UART console port</p></li>
<li><p>Power on the board</p></li>
</ol>
</div>
</div>
</div>
<div class="section" id="memory-usage">
<h4>4.6.3.5.7. Memory Usage<a class="headerlink" href="#memory-usage" title="Permalink to this headline">¶</a></h4>
<p>SBL uses the last 0x40000 memory from MSMC RAM memory.</p>
<p>The SBL memory map is shown below:</p>
<img alt="../_images/SBL_mem_k2g.jpg" src="../_images/SBL_mem_k2g.jpg" />
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>app should not have loadable sections residing in SBL memory region to
prevent overwriting SBL during load time. It is, however, free to use
SBL memory after it is loaded and running.</p>
</div>
</div>
</div>
<div class="section" id="k2h-k2e-k2l">
<h3>4.6.3.6. K2H/K2E/K2L<a class="headerlink" href="#k2h-k2e-k2l" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id132">
<h4>4.6.3.6.1. Overview<a class="headerlink" href="#id132" title="Permalink to this headline">¶</a></h4>
<p>K2H/K2E/K2L EVMs uses the Secondary Boot Loader (SBL) to configure
board-related settings and execute a user application. The user
application can be single core or multicore, and execute on either DSP
cores or ARM cores. The only restriction is that the load sections must
not overlap the memory space that SBL uses.</p>
<p>The K2H/K2E/K2L SBL supports ARM master boot using SPI NOR. Please refer
to the boot mode dip switch settings in the respective EVM hardware page
(<a class="reference external" href="index_release_specific.html#supported-platforms-and-versions">link</a>)
to configure your EVM for NOR boot.</p>
</div>
<div class="section" id="id133">
<h4>4.6.3.6.2. Flashing the Bootloader<a class="headerlink" href="#id133" title="Permalink to this headline">¶</a></h4>
<p>SBL and user application needs to be flashed into SPI NOR.</p>
<p>Refer to <a class="reference external" href="http://processors.wiki.ti.com/index.php/Program_EVM_UG">Program EVM Guide</a> for
instructions on using the script, program_evm.js, to automatically flash
your device.</p>
</div>
<div class="section" id="id134">
<h4>4.6.3.6.3. Usage<a class="headerlink" href="#id134" title="Permalink to this headline">¶</a></h4>
<ol class="arabic simple">
<li><p>Flash the bootloader and user application. This can be done
automatically with default files by using program_evm.js</p></li>
<li><p>Set the EVM to ARM SPI boot mode</p></li>
<li><p>Connect UART serial debug cable from EVM to your computer. Open a
terminal such as HyperTerminal or TeraTerm to see console output</p></li>
<li><p>Power on the EVM</p></li>
</ol>
</div>
<div class="section" id="id135">
<h4>4.6.3.6.4. Compilation<a class="headerlink" href="#id135" title="Permalink to this headline">¶</a></h4>
<p>The recommended rule-of-thumb to compiling projects in the Processor SDK
RTOS package is to use the makefiles provided. The makefiles are usable
after setting up your shell/terminal/command prompt environment with the
setupenv.bat or setupenv.sh script located in</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">processor_sdk_rtos_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Refer to <a class="reference external" href="index_overview.html#building-the-sdk">Building RTOS SDK</a> page on how to
setup your environment for building within any of the Processor SDK RTOS
packages.</p>
<p>The SBL package can be found in:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">sbl</span>
</pre></div>
</div>
<p>To build:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">sbl</span>
<span class="n">make</span> <span class="n">all</span> <span class="n">BOOTMODE</span><span class="o">=</span><span class="n">spi</span> <span class="n">BOARD</span><span class="o">=&lt;</span><span class="n">EVM</span><span class="o">&gt;</span> <span class="n">SOC</span><span class="o">=&lt;</span><span class="n">platform</span><span class="o">&gt;</span>
</pre></div>
</div>
<p><em>&lt;EVM&gt;</em> can be of values: <strong>evmK2H</strong>, <strong>evmK2E</strong>, <strong>evmK2L</strong>, or
<strong>evmK2K</strong></p>
<p><em>&lt;platform&gt;</em> can be of values: <strong>K2H</strong>, <strong>K2E</strong>, <strong>K2L</strong>, or <strong>K2K</strong></p>
<p>The resulting output will be in [SDK Install
Path]/pdk_&lt;platform&gt;_&lt;version&gt;/packages/ti/boot/sbl/binary/&lt;platform&gt;/spi/bin
directory.</p>
</div>
<div class="section" id="id136">
<h4>4.6.3.6.5. Making Loadable User Application image (app)<a class="headerlink" href="#id136" title="Permalink to this headline">¶</a></h4>
<p>For converting the compiled .out files to a format loadable by TI’s
Secondary Boot Loader (SBL), you must follow these two steps:</p>
<ol class="arabic simple">
<li><p><strong>out2rprc.exe [.out file] [rprc output]</strong></p></li>
<li><p><strong>MulticoreImageGen.exe LE 55 [output name] 0 [rprc output]</strong></p></li>
</ol>
<p>Out2rprc.exe and MulticoreImageGen.exe are tools supplied by TI and can
be located in the <strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools</strong>
folder. “rprc output” can be any spare name of your choosing. “output
name” can also be any name of your choosing.</p>
<p>The ‘0’ used in step 2 refers to the Core ID to boot. By default, ‘0’ is
MPU (Cortex A15) core 0. You can input a different value to boot to
other cores. Valid values are:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 18%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 15%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" colspan="2"><p>K2H</p></th>
<th class="head" colspan="2"><p>K2E</p></th>
<th class="head" colspan="2"><p>K2L</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Core</strong></p></td>
<td><p><strong>Value</strong></p></td>
<td><p><strong>Core</strong></p></td>
<td><p><strong>Value</strong></p></td>
<td><p><strong>Core</strong></p></td>
<td><p><strong>Value</strong></p></td>
</tr>
<tr class="row-odd"><td><p>MPU Core 0</p></td>
<td><p>0</p></td>
<td><p>MPU Core 0</p></td>
<td><p>0</p></td>
<td><p>MPU Core 0</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>MPU Core 1</p></td>
<td><p>1</p></td>
<td><p>MPU Core 1</p></td>
<td><p>1</p></td>
<td><p>MPU Core 1</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>MPU Core 2</p></td>
<td><p>2</p></td>
<td><p>MPU Core 2</p></td>
<td><p>2</p></td>
<td><p>MPU SMP</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>MPU Core 3</p></td>
<td><p>3</p></td>
<td><p>MPU Core 3</p></td>
<td><p>3</p></td>
<td><p>DSP Core 0</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-odd"><td><p>MPU SMP</p></td>
<td><p>4</p></td>
<td><p>MPU SMP</p></td>
<td><p>4</p></td>
<td><p>DSP Core 1</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-even"><td><p>DSP Core 0</p></td>
<td><p>5</p></td>
<td><p>DSP Core 0</p></td>
<td><p>5</p></td>
<td><p>DSP Core 2</p></td>
<td><p>7</p></td>
</tr>
<tr class="row-odd"><td><p>DSP Core 1</p></td>
<td><p>6</p></td>
<td></td>
<td></td>
<td><p>DSP Core 3</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-even"><td><p>DSP Core 2</p></td>
<td><p>7</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>DSP Core 3</p></td>
<td><p>8</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>DSP Core 4</p></td>
<td><p>9</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>DSP Core 5</p></td>
<td><p>10</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>DSP Core 6</p></td>
<td><p>11</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>DSP Core 7</p></td>
<td><p>12</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>If MPU SMP is chosen, the same boot image and entry will be used for all
MPU cores. SBL can also parse multiple boot images that are concatenated
together. Simply use MulticoreImageGen as such:</p>
<p><strong>MulticoreImageGen.exe LE 55 [output name] [Core ID a] [rprc output a]
[Core ID b] [rprc output b] [Core ID c] [rprc output c] …</strong></p>
</div>
<div class="section" id="id137">
<h4>4.6.3.6.6. Flash Writers<a class="headerlink" href="#id137" title="Permalink to this headline">¶</a></h4>
<div class="section" id="spi-writer">
<h5>4.6.3.6.6.1. SPI Writer<a class="headerlink" href="#spi-writer" title="Permalink to this headline">¶</a></h5>
<p>The SPI flash writer, spi_flash_writer.out, is a part of the SBL package
and allows users to flash multiple images at different offsets into the
board’s SPI NOR flash memory.</p>
<div class="section" id="id138">
<h6>4.6.3.6.6.1.1. Compilation<a class="headerlink" href="#id138" title="Permalink to this headline">¶</a></h6>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">sbl</span><span class="o">/</span>
<span class="n">make</span> <span class="n">spi_flashwriter</span> <span class="n">BOARD</span><span class="o">=&lt;</span><span class="n">EVM</span><span class="o">&gt;</span> <span class="n">SOC</span><span class="o">=&lt;</span><span class="n">platform</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The binary output will be at:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">SDK</span> <span class="n">Install</span> <span class="n">Path</span><span class="p">]</span><span class="o">/</span><span class="n">pdk_</span><span class="o">&lt;</span><span class="n">platform</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">sbl</span><span class="o">/</span><span class="n">tools</span><span class="o">/</span><span class="n">flashWriter</span><span class="o">/</span><span class="n">spi</span><span class="o">/</span><span class="n">bin</span><span class="o">/&lt;</span><span class="n">platform</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id139">
<h6>4.6.3.6.6.1.2. Usage<a class="headerlink" href="#id139" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li><p>Copy the binaries that you want to flash to: [SDK Install
Path]/pdk_&lt;platform&gt;_&lt;version&gt;/packages/ti/boot/sbl/tools/flashWriter/spi/bin/&lt;platform&gt;</p></li>
<li><p>In that same directory, there is a file named <strong>config</strong>. Edit that
file such that each line has 2 parameters: [name of binary to flash]
[SPI NOR offset to flash to]</p></li>
<li><p>Set your EVM to NO BOOT. Power on, launch target configuration in
CCS, and connect to DSP Core 0</p></li>
<li><p>Load and run [SDK Install
Path]/pdk_&lt;platform&gt;_&lt;version&gt;/packages/ti/boot/sbl/tools/flashWriter/spi/bin/&lt;platform&gt;/spi_flash_writer.out</p></li>
<li><p>You should see the flash progress output on UART terminal</p></li>
</ol>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
</div>
<div class="section" id="boot-example">
<h4>4.6.3.6.7. Boot Example<a class="headerlink" href="#boot-example" title="Permalink to this headline">¶</a></h4>
<p>Below is an example output of evmK2H booting after having images flashed
in by program_evm.js:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">****</span> <span class="n">PDK</span> <span class="n">SBL</span> <span class="o">****</span>
<span class="n">Boot</span> <span class="n">succesful</span><span class="o">!</span>
<span class="n">Begin</span> <span class="n">parsing</span> <span class="n">user</span> <span class="n">application</span>
<span class="n">Jumping</span> <span class="n">to</span> <span class="n">user</span> <span class="n">application</span><span class="p">...</span>


<span class="n">TMDXEVM6636K2H</span> <span class="n">POST</span> <span class="n">Version</span> <span class="mf">01.00.00.08</span>
<span class="o">------------------------------------------</span>
<span class="n">SOC</span> <span class="n">Information</span>

<span class="n">BMC</span> <span class="nl">Version</span><span class="p">:</span> <span class="mo">0000</span>
<span class="n">EFUSE</span> <span class="n">MAC</span> <span class="n">ID</span> <span class="nl">is</span><span class="p">:</span> <span class="n">B4</span> <span class="mi">99</span> <span class="mi">4</span><span class="n">C</span> <span class="n">B6</span> <span class="n">E2</span> <span class="mi">5</span><span class="n">B</span>
<span class="n">SA</span> <span class="n">is</span> <span class="n">enabled</span> <span class="n">on</span> <span class="k">this</span> <span class="n">board</span><span class="p">.</span>
<span class="n">PLL</span> <span class="n">Reset</span> <span class="n">Type</span> <span class="n">Status</span> <span class="nl">Register</span><span class="p">:</span> <span class="mh">0x00000001</span>
<span class="n">Platform</span> <span class="n">init</span> <span class="k">return</span> <span class="nl">code</span><span class="p">:</span> <span class="mh">0x00000000</span>

<span class="n">Power</span> <span class="n">On</span> <span class="n">Self</span> <span class="n">Test</span>

<span class="n">POST</span> <span class="n">running</span> <span class="n">in</span> <span class="n">progress</span> <span class="p">...</span>
<span class="n">POST</span> <span class="n">I2C</span> <span class="n">EEPROM</span> <span class="n">read</span> <span class="n">test</span> <span class="n">started</span><span class="o">!</span>
<span class="n">POST</span> <span class="n">I2C</span> <span class="n">EEPROM</span> <span class="n">read</span> <span class="n">test</span> <span class="n">passed</span><span class="o">!</span>
<span class="n">POST</span> <span class="n">SPI</span> <span class="n">NOR</span> <span class="n">read</span> <span class="n">test</span> <span class="n">started</span><span class="o">!</span>
<span class="n">POST</span> <span class="n">SPI</span> <span class="n">NOR</span> <span class="n">read</span> <span class="n">test</span> <span class="n">passed</span><span class="o">!</span>
<span class="n">POST</span> <span class="n">EMIF16</span> <span class="n">NAND</span> <span class="n">read</span> <span class="n">test</span> <span class="n">started</span><span class="o">!</span>
<span class="n">POST</span> <span class="n">EMIF16</span> <span class="n">NAND</span> <span class="n">read</span> <span class="n">test</span> <span class="n">passed</span><span class="o">!</span>
<span class="n">POST</span> <span class="n">external</span> <span class="n">memory</span> <span class="n">test</span> <span class="n">started</span><span class="o">!</span>
<span class="n">POST</span> <span class="n">external</span> <span class="n">memory</span> <span class="n">test</span> <span class="n">passed</span><span class="o">!</span>
<span class="n">POST</span> <span class="n">done</span> <span class="n">successfully</span><span class="o">!</span>

<span class="n">POST</span> <span class="nl">result</span><span class="p">:</span> <span class="n">PASS</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="omapl137-omapl138-c6748">
<h3>4.6.3.7. OMAPL137/OMAPL138/C6748<a class="headerlink" href="#omapl137-omapl138-c6748" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id140">
<h4>4.6.3.7.1. Overview<a class="headerlink" href="#id140" title="Permalink to this headline">¶</a></h4>
<p>The Secondary Bootloader (SBL) for OMAPL137/OMAPL138/C6748 does basic
hardware initialization for the board to load and run applications.
Processor SDK boot support for each of these SoC is shown below</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Device</p></th>
<th class="head"><p>Cores</p></th>
<th class="head"><p>Boot Master</p></th>
<th class="head"><p>Supported
Boot
modes in
SBL</p></th>
<th class="head"><p>HW
Platforms</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>OMAPL137</p></td>
<td><p>ARM (ARM9)
DSP (C674x)</p></td>
<td><p>DSP</p></td>
<td><p>SPI</p></td>
<td><p>OMAPL137
EVM</p></td>
</tr>
<tr class="row-odd"><td><p>OMAPL138</p></td>
<td><p>ARM (ARM9)
DSP (C674x)</p></td>
<td><p>ARM</p></td>
<td><p>MMCSD</p></td>
<td><p>OMAPL138
LCDK</p></td>
</tr>
<tr class="row-even"><td><p>C6748</p></td>
<td><p>DSP (C674x)</p></td>
<td><p>DSP</p></td>
<td><p>MMCSD</p></td>
<td><p>C6748 LCDK</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id141">
<h4>4.6.3.7.2. Bootloader Execution Sequence<a class="headerlink" href="#id141" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>Power On Reset occurs</p></li>
<li><p>ROM Bootloader (RBL) executes. It checks for bootmode and attempts to
load+run the SBL from that bootmode.</p></li>
<li><p>SBL begins execution from internal memory (Shared RAM)</p>
<ul>
<li><p>Board Initialization is done by a call to <strong>Board_init()</strong> API.
For additional details refer to <a class="reference external" href="index_board.html#board-support">Processor SDK Board
Support</a>.</p></li>
<li><p>SBL setup includes configuring Pinmux, enable peripheral clocks,
set up PLLs, and configure EMIF for SDRAM/DDR.</p></li>
</ul>
</li>
<li><p>SBL finishes setup and looks for “app” to execute next. This
user-modifiable application shall reside on the boot media.</p></li>
<li><p>Once located, app will be loaded into memory and execution will be
branched to the application’s entry address</p></li>
</ul>
</div>
<div class="section" id="id142">
<h4>4.6.3.7.3. Tools and Binary Formats<a class="headerlink" href="#id142" title="Permalink to this headline">¶</a></h4>
<div class="section" id="id143">
<h5>4.6.3.7.3.1. Making Bootable SBL image (MLO)<a class="headerlink" href="#id143" title="Permalink to this headline">¶</a></h5>
<p>RBL loads and runs “MLO”, which is a .out executable formatted by TI
tools. HexAIS tool should be used to convert the .out into MLO using the
below command.</p>
<p>Windows Host</p>
<p><strong>&lt;HexAIS_Tool&gt; -o &lt;output file&gt; -ini &lt;ini file&gt; &lt;input file&gt;</strong></p>
<p>Linux Host</p>
<p>HexAIS executable can be run on Linux PC by using mono tool as shown
below</p>
<p><strong>mono &lt;HexAIS_Tool&gt; -o &lt;output file&gt; -ini &lt;ini file&gt; &lt;input file&gt;</strong></p>
<ul class="simple">
<li><p>&lt;HexAIS_Tool&gt; is HexAIS_OMAP-L137.exe for OMAPL137 and
HexAIS_OMAP-L138.exe for OMAPL138/C6748</p></li>
<li><p>‘output file’ is name of the output file. MLO in this case</p></li>
<li><p>‘ini file’ is configuration file for defining the boot parameters.
This file provides option to instruct RBL to take certain actions
before loading the MLO into internal memory. Sample ini file is
available at <strong>&lt; PDK_INSTALL_DIR
&gt;/packages/ti/boot/sbl/soc/&lt;device&gt;</strong></p></li>
</ul>
<p>&lt;device&gt; can be omapl137, omapl138 or c6748</p>
<ul class="simple">
<li><p>‘input file’ is the input .out file name which needs to be converted
into MLO</p></li>
</ul>
<p>OMAPL137 HexAIS tool is available at <strong>&lt; PDK_INSTALL_DIR
&gt;/packages/ti/boot/sbl/tools/omapl13x_boot_utils/OMAP-L137/GNU/AISUtils</strong>.</p>
<p>OMAPL138/C6748 HexAIS tool is available at <strong>&lt; PDK_INSTALL_DIR
&gt;/packages/ti/boot/sbl/tools/omapl13x_boot_utils/OMAP-L138/GNU/AISUtils</strong></p>
</div>
<div class="section" id="id144">
<h5>4.6.3.7.3.2. Making Loadable User Application image (app)<a class="headerlink" href="#id144" title="Permalink to this headline">¶</a></h5>
<p>For converting the compiled .out files to a format loadable by TI’s
Secondary Boot Loader (SBL), you must follow these two steps:</p>
<ol class="arabic simple">
<li><p><strong>out2rprc.exe [.out file] [rprc output]</strong></p></li>
<li><p><strong>MulticoreImageGen.exe LE 55 [output name] &lt;Core ID&gt; [rprc output]</strong></p></li>
</ol>
<p>Out2rprc.exe and MulticoreImageGen.exe are tools supplied by TI and can
be located in the <strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools</strong>
folder. “rprc output” can be any spare name of your choosing. “output
name” can also be any name of your choosing.</p>
<p>The &lt;Core ID&gt; used in step 2 refers to the Core ID to boot. Use ‘0’ as
Core ID for ARM core and ‘1’ for DSP core. Valid values are:. You can
input a different value to boot to other cores. Valid values are:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 59%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Core</p></th>
<th class="head"><p>Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ARM Core</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>DSP Core</p></td>
<td><p>1</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Program entry point of DSP app images on OMAPL138 platform should be 1KByte aligned for loading and executing the DSP images from
ARM core. GPIO LLD LED blink example for C674x core can be used as reference for aligning the DSP entry point to run the DSP code from
SBL. Other LLD examples does not work from SBL as is.</p>
</div>
</div>
</div>
<div class="section" id="id145">
<h4>4.6.3.7.4. Boot Modes<a class="headerlink" href="#id145" title="Permalink to this headline">¶</a></h4>
<p>This release of SBL supports SPI and MMCSD boot modes.</p>
<div class="section" id="spi-boot-mode">
<h5>4.6.3.7.4.1. SPI Boot Mode<a class="headerlink" href="#spi-boot-mode" title="Permalink to this headline">¶</a></h5>
<div class="section" id="preparing-spi-flash">
<h6>4.6.3.7.4.1.1. Preparing SPI Flash<a class="headerlink" href="#preparing-spi-flash" title="Permalink to this headline">¶</a></h6>
<p>MLO and app needs to be flashed into SPI memory so that they can be
booted. MLO will reside at offset 0 and app will reside at offset
0x80000. SPI flash memory map:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 76%" />
<col style="width: 24%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Offset 0x0</p></td>
<td><p>MLO</p></td>
</tr>
<tr class="row-even"><td><p>Offset 0x80000</p></td>
<td><p>app</p></td>
</tr>
</tbody>
</table>
<p>The images can be flashed into SPI flash by following steps given below:</p>
<ol class="arabic simple">
<li><p>Copy MLO and app to SPI flash writer binary folder -
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools/flashWriter/spi/bin/evmOMAPL137</strong>.
Make sure config file also present in the SPI flash writer binary
folder.</p>
<ul class="simple">
<li><p>MLO is the SBL formatted by the aforementioned tools. A pre-built
MLO can be found at:
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/binary/evmOMAPL137/spi/bin</strong></p></li>
<li><p>app is the target application to be booted and also formatted by
the aforementioned tools. (Note that the tools for making the
bootable MLO and the loadable app are different).</p></li>
<li><p>config helps specify the memory map. The default config file can
be found at:
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools/flashWriter/spi/bin/evmOMAPL137</strong>.
This config file may be altered to custom user settings if needed.</p></li>
</ul>
</li>
<li><p>Connect the DB9 port of the EVM to host PC. Open serial communication
applications like TeraTerm, MiniCom, etc and configure for ‘115200
8N1’.</p></li>
<li><p>Connect to the board with CCS. Launch target configuration and
connect to the DSP C674x core. GEL file will run on-connect and do
basic board-level initialization</p></li>
<li><p>Load the flash writer, spi_flash_writer.out, to the connected core</p>
<ul class="simple">
<li><p>A pre-built spi_flash_writer.out can be found at:
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools/flashWriter/spi/bin/evmOMAPL137</strong></p></li>
</ul>
</li>
<li><p>Run the SPI flash writer application. You will see the following logs
on the EVM’s UART console:</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span> <span class="o">***</span> <span class="n">PDK</span> <span class="n">SPI</span> <span class="n">Flash</span> <span class="n">Writer</span> <span class="o">***</span>
<span class="n">Opening</span> <span class="n">SPI</span> <span class="n">handle</span><span class="p">...</span>
<span class="n">SPI</span> <span class="n">handle</span> <span class="n">opened</span><span class="o">!</span>
<span class="n">Parsing</span> <span class="n">config</span> <span class="n">file</span> <span class="n">and</span> <span class="n">flashing</span> <span class="n">content</span> <span class="n">to</span> <span class="n">SPI</span> <span class="n">NOR</span><span class="p">...</span>
<span class="n">Parsed</span> <span class="n">config</span> <span class="n">line</span><span class="p">,</span> <span class="n">received</span> <span class="nl">parameters</span><span class="p">:</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">MLO</span><span class="p">,</span> <span class="n">address</span> <span class="o">=</span> <span class="mh">0x0</span>
       <span class="n">Size</span> <span class="n">of</span> <span class="n">MLO</span> <span class="n">is</span> <span class="mh">0xc81c</span>
       <span class="n">Loading</span> <span class="n">binary</span> <span class="n">to</span> <span class="n">memory</span> <span class="p">...</span>
       <span class="n">Finished</span> <span class="n">loading</span> <span class="n">binary</span> <span class="n">to</span> <span class="n">memory</span><span class="o">!</span>
       <span class="n">Flashed</span> <span class="n">MLO</span> <span class="n">to</span> <span class="n">offset</span> <span class="mh">0x0</span><span class="o">!</span>
       <span class="n">Read</span> <span class="n">flash</span> <span class="n">memory</span> <span class="n">at</span> <span class="mh">0x0</span><span class="p">,</span> <span class="n">checking</span> <span class="n">flashed</span> <span class="n">content</span><span class="p">...</span>
       <span class="n">Verified</span> <span class="n">flash</span> <span class="n">data</span> <span class="n">equal</span> <span class="n">expected</span> <span class="n">data</span><span class="o">!</span>
<span class="n">Parsed</span> <span class="n">config</span> <span class="n">line</span><span class="p">,</span> <span class="n">received</span> <span class="nl">parameters</span><span class="p">:</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">app</span><span class="p">,</span> <span class="n">address</span> <span class="o">=</span> <span class="mh">0x80000</span>
       <span class="n">Size</span> <span class="n">of</span> <span class="n">app</span> <span class="n">is</span> <span class="mh">0x16144</span>
       <span class="n">Loading</span> <span class="n">binary</span> <span class="n">to</span> <span class="n">memory</span> <span class="p">...</span>
       <span class="n">Finished</span> <span class="n">loading</span> <span class="n">binary</span> <span class="n">to</span> <span class="n">memory</span><span class="o">!</span>
       <span class="n">Flashed</span> <span class="n">app</span> <span class="n">to</span> <span class="n">offset</span> <span class="mh">0x80000</span><span class="o">!</span>
       <span class="n">Read</span> <span class="n">flash</span> <span class="n">memory</span> <span class="n">at</span> <span class="mh">0x80000</span><span class="p">,</span> <span class="n">checking</span> <span class="n">flashed</span> <span class="n">content</span><span class="p">...</span>
       <span class="n">Verified</span> <span class="n">flash</span> <span class="n">data</span> <span class="n">equal</span> <span class="n">expected</span> <span class="n">data</span><span class="o">!</span>
<span class="n">Successfully</span> <span class="n">flashed</span> <span class="n">memory</span> <span class="n">content</span><span class="o">!</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This application will flash the image at required offset without taking
into consideration any overwriting to previously flashed image.</p>
</div>
</div>
<div class="section" id="booting-via-spi">
<h6>4.6.3.7.4.1.2. Booting via SPI<a class="headerlink" href="#booting-via-spi" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li><p>Set the OMAPL137 EVM to SPI bootmode by configuring the SW2 DIP
switches 1-4 to ‘OFF ON OFF ON’. Other switch positions on SW2 are
don’t care for SPI boot.</p></li>
<li><p>Connect the DB9 port of the EVM to host PC. Open serial communication
applications like TeraTerm, MiniCom, etc and configure for ‘115200
8N1’</p></li>
<li><p>Power on the board</p></li>
</ol>
<p>Below is an example of OMAPL137 SBL successfully booting the GPIO LED
blink application</p>
<img alt="../_images/Omapl137_boot_example.jpg" src="../_images/Omapl137_boot_example.jpg" />
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="id146">
<h5>4.6.3.7.4.2. MMCSD Boot Mode<a class="headerlink" href="#id146" title="Permalink to this headline">¶</a></h5>
<p>OMAPL138/C6848 RBL does not support reading the boot images as files
from SD card. Secondary Boot loader image should be written to SD card
as raw data. Special formatting is needed for SD card to create
un-formatted area at the beginning of the card to store SBL.</p>
<div class="section" id="formatting-the-sd-card">
<h6>4.6.3.7.4.2.1. Formatting the SD Card<a class="headerlink" href="#formatting-the-sd-card" title="Permalink to this headline">¶</a></h6>
<p>SD card for booting OMAPL138/C6748 needs to be formatted from Linux PC
due to un-formatted area requirement. Formatting the SD card from
Windows PC is not supported in this release.</p>
<p>Connect the SD card to Linux PC and use below command to format the SD
card</p>
<p><strong>sudo sh create-sdcard-omapl13x.sh &lt;Drive Name&gt;</strong></p>
<ul class="simple">
<li><p>&lt;Drive Name&gt; is name of the drive on which SD card is mounted. Be
cautious while selecting the drive name. Running the script with
system drive name will corrupt the file system.</p></li>
<li><p>create-sdcard-omapl13x.sh script is available at
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools/omapl13x_sd_card_format</strong></p></li>
</ul>
</div>
<div class="section" id="id147">
<h6>4.6.3.7.4.2.2. Preparing the SD Card<a class="headerlink" href="#id147" title="Permalink to this headline">¶</a></h6>
<p>For both OMAPL138 and C6748, MLO needs to be flashed onto SD card
un-formatted area and app should be copied onto SD card.</p>
<p>MLO can be flashed into SD card un-formatted area by following steps
given below:</p>
<ol class="arabic simple">
<li><p>Build the MMCSD flash writer using below commands</p>
<ul class="simple">
<li><p>cd &lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl</p></li>
<li><p>gmake mmcsd_flashwriter SOC=OMAPL138 BOARD=lcdkOMAPL138
BOOTMODE=mmcsd</p></li>
</ul>
</li>
<li><p>Copy ‘app’ to SD card and insert the card into MMCSD slot of the
board</p></li>
<li><p>Copy MLO to MMCSD flash writer binary folder -
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools/flashWriter/mmcsd/bin/lcdkOMAPL138</strong>.
Make sure config file also present in the MMCSD flash writer binary
folder.</p>
<ul class="simple">
<li><p>MLO is the SBL formatted by the aforementioned tools. A pre-built
MLO can be found at:
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/binary/lcdkOMAPL138/mmcsd/bin</strong></p></li>
<li><p>app is the target application to be booted and also formatted by
the aforementioned tools. (Note that the tools for making the
bootable MLO and the loadable app are different).</p></li>
<li><p>config helps specify the memory map. The default config file can
be found at:
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools/flashWriter/mmcsd/bin/lcdkOMAPL138</strong>.
This config file may be altered to custom user settings if needed.</p></li>
</ul>
</li>
<li><p>Connect the USB serial port of the EVM to host PC. Open serial
communication applications like TeraTerm, MiniCom, etc and configure
for ‘115200 8N1’.</p></li>
<li><p>Connect to the board with CCS. Launch target configuration, connect
to ARM core first (not needed for C6748) and then connect to the DSP
C674x core. GEL file will run on-connect and do basic board-level
initialization</p></li>
<li><p>Load the flash writer, mmcsd_flash_writer.out, to the connected core</p>
<ul class="simple">
<li><p>mmcsd_flash_writer.out can be found at:
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools/flashWriter/mmcsd/bin/lcdkOMAPL138</strong></p></li>
</ul>
</li>
<li><p>Run the MMCSD flash writer application. You will see the following
logs on the EVM’s UART console:</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Opening</span> <span class="n">MMCSD</span> <span class="n">handle</span><span class="p">...</span>
<span class="n">MMCSD</span> <span class="n">handle</span> <span class="n">opened</span><span class="o">!</span>
<span class="n">Parsing</span> <span class="n">config</span> <span class="n">file</span> <span class="n">and</span> <span class="n">flashing</span> <span class="n">content</span> <span class="n">to</span> <span class="n">MMCSD</span><span class="p">...</span>
<span class="n">Parsed</span> <span class="n">config</span> <span class="n">line</span><span class="p">,</span> <span class="n">received</span> <span class="nl">parameters</span><span class="p">:</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">MLO</span><span class="p">,</span> <span class="n">address</span> <span class="o">=</span> <span class="mh">0x200</span>
       <span class="n">Size</span> <span class="n">of</span> <span class="n">MLO</span> <span class="n">is</span> <span class="mh">0xb9b8</span>
       <span class="n">Loading</span> <span class="n">binary</span> <span class="n">to</span> <span class="n">memory</span> <span class="p">...</span>
       <span class="n">Finished</span> <span class="n">loading</span> <span class="n">binary</span> <span class="n">to</span> <span class="n">memory</span><span class="o">!</span>
       <span class="n">Flashed</span> <span class="n">MLO</span> <span class="n">to</span> <span class="n">offset</span> <span class="mh">0x200</span><span class="o">!</span>
       <span class="n">Read</span> <span class="n">flash</span> <span class="n">memory</span> <span class="n">at</span> <span class="mh">0x200</span><span class="p">,</span> <span class="n">checking</span> <span class="n">flashed</span> <span class="n">content</span><span class="p">...</span>
       <span class="n">Verified</span> <span class="n">flash</span> <span class="n">data</span> <span class="n">equal</span> <span class="n">expected</span> <span class="n">data</span><span class="o">!</span>
<span class="n">Successfully</span> <span class="n">flashed</span> <span class="n">memory</span> <span class="n">content</span><span class="o">!</span>
</pre></div>
</div>
<p>Procedure to flash the MLO described above is applicable to C6748 also.
Use C6748 for OMAPL138 and lcdkC6748 for lcdkOMAPL138 in all the paths
mentioned above.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MLO</span> <span class="n">offset</span> <span class="n">in</span> <span class="n">config</span> <span class="n">file</span> <span class="n">is</span> <span class="n">set</span> <span class="n">to</span> <span class="mi">200</span> <span class="n">by</span> <span class="k">default</span> <span class="n">which</span> <span class="n">indicates</span> <span class="n">that</span> <span class="n">MLO</span> <span class="n">will</span> <span class="n">be</span> <span class="n">written</span> <span class="n">to</span> <span class="n">second</span> <span class="n">sector</span> <span class="n">of</span> <span class="n">the</span> <span class="n">SD</span> <span class="n">card</span><span class="p">.</span> <span class="n">MLO</span> <span class="n">offset</span> <span class="n">can</span> <span class="n">be</span> <span class="n">any</span> <span class="n">non</span><span class="o">-</span>
<span class="n">zero</span> <span class="n">value</span> <span class="n">which</span> <span class="n">is</span> <span class="n">multiple</span> <span class="n">of</span> <span class="mi">512</span> <span class="n">and</span> <span class="n">should</span> <span class="n">be</span> <span class="n">within</span> <span class="n">first</span> <span class="mi">2</span><span class="n">Mbytes</span> <span class="n">of</span> <span class="n">SD</span> <span class="n">card</span> <span class="n">memory</span><span class="p">.</span> <span class="n">DO</span> <span class="n">NOT</span> <span class="n">set</span> <span class="n">the</span> <span class="n">MLO</span> <span class="n">offset</span> <span class="n">to</span> <span class="sc">&#39;0&#39;</span> <span class="n">which</span> <span class="n">will</span> <span class="n">corrupt</span> <span class="n">the</span> <span class="n">file</span>
<span class="n">system</span> <span class="n">on</span> <span class="n">the</span> <span class="n">card</span><span class="p">.</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This application will flash the image at required offset without taking
into consideration any overwriting to previously flashed image.</p>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="booting-via-mmcsd">
<h6>4.6.3.7.4.2.3. Booting via MMCSD<a class="headerlink" href="#booting-via-mmcsd" title="Permalink to this headline">¶</a></h6>
<ol class="arabic simple">
<li><p>Set the OMAPL138/C6748 LCDK to MMCSD bootmode by configuring the SW1
DIP switches 1-4 to ‘OFF OFF OFF ON’. Other switch positions on SW1
are don’t care for MMCSD boot.</p></li>
<li><p>Connect the USB serial port of the EVM to host PC. Open serial
communication applications like TeraTerm, MiniCom, etc and configure
for ‘115200 8N1’</p></li>
<li><p>Power on the board</p></li>
</ol>
<p>Below is an example of OMAPL138 SBL successfully booting the GPIO LED
blink application</p>
<img alt="../_images/Omapl138_boot_example.png" src="../_images/Omapl138_boot_example.png" />
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
</div>
<div class="section" id="id148">
<h4>4.6.3.7.5. Memory Usage<a class="headerlink" href="#id148" title="Permalink to this headline">¶</a></h4>
<p>SBL uses 0x20000 bytes from shared RAM (0x80000000 to 0x8001FFFF).</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>app should not have loadable sections residing in SBL memory region to
prevent overwriting SBL during load time. It is, however, free to use
SBL memory after it is loaded and running.</p>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="additional-details">
<h4>4.6.3.7.6. Additional Details<a class="headerlink" href="#additional-details" title="Permalink to this headline">¶</a></h4>
<p>Use below commands to clean and build the SBL and associated tools.</p>
<div class="section" id="initial-steps">
<h5>4.6.3.7.6.1. Initial Steps<a class="headerlink" href="#initial-steps" title="Permalink to this headline">¶</a></h5>
<p>Setup the environment variables to configure the build tools</p>
<p>cd &lt;PDK_INSTALL_DIR&gt;/packages</p>
<p>Run pdksetupenv script</p>
<p>cd ti/boot/sbl</p>
</div>
<div class="section" id="cleaning-sbl">
<h5>4.6.3.7.6.2. Cleaning SBL<a class="headerlink" href="#cleaning-sbl" title="Permalink to this headline">¶</a></h5>
<p>gmake clean SOC=&lt;SoC Name&gt; BOARD=&lt;Board Name&gt; BOOTMODE=&lt;Boot Mode&gt;</p>
</div>
<div class="section" id="building-sbl">
<h5>4.6.3.7.6.3. Building SBL<a class="headerlink" href="#building-sbl" title="Permalink to this headline">¶</a></h5>
<p>gmake SOC=&lt;SoC Name&gt; BOARD=&lt;Board Name&gt; BOOTMODE=&lt;Boot Mode&gt;</p>
</div>
<div class="section" id="cleaning-flash-writer">
<h5>4.6.3.7.6.4. Cleaning Flash Writer<a class="headerlink" href="#cleaning-flash-writer" title="Permalink to this headline">¶</a></h5>
<p>gmake &lt;Flash Writer&gt;_clean SOC=&lt;SoC Name&gt; BOARD=&lt;Board Name&gt;
BOOTMODE=&lt;Boot Mode&gt;</p>
</div>
<div class="section" id="building-flash-writer">
<h5>4.6.3.7.6.5. building-flash-writer<a class="headerlink" href="#building-flash-writer" title="Permalink to this headline">¶</a></h5>
<p>gmake &lt;Flash Writer&gt; SOC=&lt;SoC Name&gt; BOARD=&lt;Board Name&gt; BOOTMODE=&lt;Boot
Mode&gt;</p>
<ul class="simple">
<li><p>use ‘make’ instead of ‘gmake’ on Linux host</p></li>
<li><p>&lt;SoC Name&gt; - OMAPL137, OMAPL138 or C6748</p></li>
<li><p>&lt;Board Name&gt; - evmOMAPL137, lcdkOMAPL138 or lcdkC6748</p></li>
<li><p>&lt;Boot Mode&gt; - spi or mmcsd as supported by the device</p></li>
<li><p>&lt;Flash Writer&gt; - spi_flashwriter for spi boot mmcsd_flashwriter for
mmcsd boot</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="nl">Examples</span><span class="p">:</span>
<span class="n">Cleaning</span> <span class="o">&amp;</span> <span class="n">Building</span> <span class="n">OMAPL137</span> <span class="n">SBL</span>
<span class="n">gmake</span> <span class="n">clean</span> <span class="n">SOC</span><span class="o">=</span><span class="n">OMAPL137</span> <span class="n">BOARD</span><span class="o">=</span><span class="n">evmOMAPL137</span> <span class="n">BOOTMODE</span><span class="o">=</span><span class="n">spi</span>
<span class="n">gmake</span> <span class="n">SOC</span><span class="o">=</span><span class="n">OMAPL137</span> <span class="n">BOARD</span><span class="o">=</span><span class="n">evmOMAPL137</span> <span class="n">BOOTMODE</span><span class="o">=</span><span class="n">spi</span>

<span class="n">Cleaning</span> <span class="o">&amp;</span> <span class="n">Building</span> <span class="n">OMAPL137</span> <span class="n">flash</span> <span class="n">writer</span>
<span class="n">gmake</span> <span class="n">spi_flashwriter_clean</span> <span class="n">SOC</span><span class="o">=</span><span class="n">OMAPL137</span> <span class="n">BOARD</span><span class="o">=</span><span class="n">evmOMAPL137</span> <span class="n">BOOTMODE</span><span class="o">=</span><span class="n">spi</span>
<span class="n">gmake</span> <span class="n">spi_flashwriter</span> <span class="n">SOC</span><span class="o">=</span><span class="n">OMAPL137</span> <span class="n">BOARD</span><span class="o">=</span><span class="n">evmOMAPL137</span> <span class="n">BOOTMODE</span><span class="o">=</span><span class="n">spi</span>
</pre></div>
</div>
<p>On successful build, SBL .out and MLO will be created at
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/binary/&lt;Board Name&gt;/&lt;Boot
Mode&gt;/bin</strong> and flash writer binary will be created at
<strong>&lt;PDK_INSTALL_DIR&gt;/packages/ti/boot/sbl/tools/flashWriter/&lt;Boot
Mode&gt;/bin/&lt;Board Name&gt;</strong></p>
</div>
</div>
</div>
</div>
<div class="section" id="bootloader-debugging">
<h2>4.6.4. Bootloader Debugging<a class="headerlink" href="#bootloader-debugging" title="Permalink to this headline">¶</a></h2>
<div class="section" id="common-steps-to-debug-application-boot">
<h3>4.6.4.1. Common Steps to debug application boot<a class="headerlink" href="#common-steps-to-debug-application-boot" title="Permalink to this headline">¶</a></h3>
<p>Bootloading an application is a system level issue which is impacted by
hardware as well as software setup. There are some common steps that
users are expected to check while debugging boot related issues. This
section discusses common issues to checkout when debugging application
boot.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="section" id="hardware-debug-steps">
<h4>4.6.4.1.1. Hardware Debug Steps<a class="headerlink" href="#hardware-debug-steps" title="Permalink to this headline">¶</a></h4>
<div class="toccolours" style="width:1600px"><p><strong>Input clocks and power sequencing</strong></p>
<ul class="simple">
<li><p>Ensure that correct power sequencing is occurring on your board.
Power sequencing specifications can be found in the data manual.</p></li>
<li><p>Check the system clock and ensure this is outputting the expected
frequency and the signal is swinging rail to rail (should be a 1.8V
signal). If you have an external oscillator, it should be outputting
a square wave at the desired frequency. If you are using a crystal ,
you should have a sine wave at the desired frequency at XTALIN.
XTALOUT should be similar (may be distorted a little).</p></li>
<li><p>Check the power on reset signal PORZ. This signal should stay low
throughout the power sequencing and go high when the power AND high
frequency clock are stable.</p></li>
<li><p>If the device has an OBSCLK or CLKOUT then ensure that this pin
provides the correct output that matches your software
configurations.</p></li>
</ul>
<p><strong>Boot pins:</strong></p>
<p>Best way to confirm what the device ROM bootloader reads from the pins
is to read the register where the Boot pins are latched into the device:</p>
<ul class="simple">
<li><p>For AM335x/AM437x: Check the Control_status register</p></li>
<li><p>For AM57xs: Check CTRL_CORE_BOOTSTRAP register</p></li>
<li><p>For C66x/K2X devices: Check the DEVSTAT register</p></li>
<li><p>For OMAPL13x/C674x devices: Check BOOTCFG register</p></li>
</ul>
<p><strong>Boot media connectivity</strong></p>
<p>Users are required to test their boot interface by running boot loader
independent diagnostic tests that confirm that the SOC can read and
write from the boot interface. Processor SDK RTOS provides Diagnostic
utilities for K2G/AMXX devices and provides POST utility for keystone
devices with which the TI EVM was tested.</p>
<p>TI Technical documentation like Technical reference manual (AMXX
devices), Bootloader USer guide (for C66x/K2X devices) and Bootloader
Application notes for OMAPLxx/C674x list default behavior or the ROM
bootloader and limitations and constraints for each boot mode.
Application developers need to account for this while designing their
system to ensure smooth bring up process.</p>
<p><strong>Signalling on boot media and reset pins</strong></p>
<p>If software and other hardware debug steps have not helped identify the
issue, you may need to hook up a scope or protocol analyzer to check the
clocks and the data transfers from the boot media to check if there is
any issues that can be identified. Another commonly known issue that
impacts boot is noise on the power lines which may cause the SOC to
reset or cause a hang on the boot core. Provide these scope shots to TI
on E2E forums so TI engineers can confirm that there are no issues.</p>
</div></div>
<div class="section" id="software-debug-steps">
<h4>4.6.4.1.2. Software Debug Steps<a class="headerlink" href="#software-debug-steps" title="Permalink to this headline">¶</a></h4>
<div class="toccolours" style="width:1600px"><p class="rubric" id="sbl-and-app-entry-points">SBL and app Entry points</p>
<p>If you don`t see your bootloader executing post boot, a good sanity
check is for you to look at the map file for the bootloader and ensure
that the entry point matches with the location in the TI or GPHeader in
the boot image. this can be done by looking at the entry point in the
MLO/_ti.bin/GPheader and ensure that it matches with the location of
symbol Entry in the .out/map file for the bootloader.</p>
<p class="rubric" id="sbl-and-app-memory-map">SBL and App memory map</p>
<p>The SBL execute from device onchip memory so if your application is also
using Onchip memory in addition to DDR memory, developers need to ensure
that the code sections in the application do not overlap with memory
sections that are used by the SBL. This can cause the SBL to hang during
the application boot process and go into an abort state.</p>
<p>To check what memory region is used by the SBL please locate the map
file created from building the bootloader.</p>
<p class="rubric" id="flash-programming-verification">Flash Programming verification</p>
<p>It is essential to understand that the flash programmer that you use has
not just the ability to write the image to flash but should also be able
to verify that the image written to flash matches the image that you
have created on your host machine. you can use TI flash programming
utilities as reference and ensure that the production flashing tools use
a method to erase, write and then verify the boot image that is written
to the flash.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p class="rubric" id="ddr-timings-and-configuration-sbl">DDR timings and configuration /SBL</p>
<p>The Processor SDK bootloader ships with DDR clock and timing settings
that apply to the external memory devices that have been used in TI
evaluation platforms. When running the code on custom platforms, users
may be required to change these setting to match the timings required by
custom design. We highly recommend that users create a GEL script
similar to one provided by TI and test the memory interface with the new
settings before using them in the secondary bootloader to setup external
memory. <a class="reference external" href="index_board.html#diagnostics">**Processor SDK Diagnostics**</a>
provides a mem_test that can be used to test read and writes to the
entire DDR address space for confirming the SOC EMIF settings.</p>
<p class="rubric" id="emulator-based-debugging-of-boot">Emulator based debugging of boot</p>
<p>The processor SDK RTOS bootloader is like any other application that can
be loaded over the emulator and debugged. Steps to connect an emulator
to the EVM have been described in the <a class="reference external" href="Release_Specific.html#supported-platforms-and-versions">**Hardware Setup Guides**</a>
that is linked to the Processor SDK RTOS documentation.</p>
<p>Loading the bootloader over emulator can be very useful step in
debugging the system boot. Before generating the final binary for
bootloader, the build generates the .out file for the bootloader which
is then formatted in a boot format that the ROM bootloader(RBL) can
interpret. This .out can be loaded over the emulator similar to any
other application. If you load the debug version of the bootloader, you
can single step through the code that initializes the SOC and also part
of the SBL code that loads the app from the boot media.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>SBL runs from onchip memory so users can load the SBL.out even without
using the GEL file but using the GEL sometimes helps with putting the
core in a clean state so usage of the GEL is optional</p>
</div>
<p><strong>Alternate Approach:</strong></p>
<p><strong>Add a spinlock in SBL main</strong></p>
<p>In some occasions the RBL may load the SBL but there may be some issue
that you need to debug in the SBL. In this case you can add a spinlock
loop at the start of main in SBL and allow the first stage boot to
complete normally and then connect to the core when you connect the core
will be held in the spinlock condition waiting for you to connect.</p>
<p>Example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">volatile</span> <span class="kt">int</span> <span class="n">exitSpinLock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">Debug_spinLock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">exitSpinLock</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You will then have to “release” the core by toggling the variable which
the while loop is blocking on. You can either do this manually by
halting CCS, examining the variable in the watch window and then
changing the value before continuing execution on the core, or you can
use a GEL script.</p>
<p><strong>Use an IO input to stall the core until user input is received:</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hit enter to continue:&quot;</span><span class="p">);</span>
<span class="n">getchar</span><span class="p">();</span>
</pre></div>
</div>
<p class="rubric" id="system-state-at-boot-failure">System state at boot failure</p>
<p>A useful data point for TI to debug boot related issues is to isolate
commonly known initialization and to understand how far the bootloader
has executed correctly before it runs into any issues. Users are
required to capture ARM/DSP clocks, Program counter value, Entry points
detected, pinmux configuration and confirm DDR initialization and slave
core states. This helps minimize the number of variables in the system
boot and helps us zero in on the most likely cause for the boot failure.</p>
</div>
</div>
</div>
<div class="section" id="uart-apploader">
<h2>4.6.5. UART AppLoader<a class="headerlink" href="#uart-apploader" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id149">
<h3>4.6.5.1. Overview<a class="headerlink" href="#id149" title="Permalink to this headline">¶</a></h3>
<p>UART AppLoader is a standalone application used to download application image over UART
from the host PC. Host PC uses the serial console utility to transfer application image to apploader.</p>
<p>The Apploader application loads and executes the application binary to be tested,
over UART on the target platform.</p>
</div>
<div class="section" id="supported-platforms">
<h3>4.6.5.2. Supported Platforms<a class="headerlink" href="#supported-platforms" title="Permalink to this headline">¶</a></h3>
<table class="docutils align-default">
<colgroup>
<col style="width: 28%" />
<col style="width: 32%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>SOC</p></th>
<th class="head"><p>PLATFORM</p></th>
<th class="head"><p>Verified Boot Modes</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td rowspan="3"><p>AM335x</p></td>
<td><p>AM335x GP EVM</p></td>
<td><p>MMCSD</p></td>
</tr>
<tr class="row-odd"><td><p>AM335x ICEv2</p></td>
<td><p>MMCSD</p></td>
</tr>
<tr class="row-even"><td><p>AMIC110 ICE</p></td>
<td><p>SPI</p></td>
</tr>
<tr class="row-odd"><td rowspan="2"><p>AM437x</p></td>
<td><p>AM437x EVM</p></td>
<td><p>MMCSD</p></td>
</tr>
<tr class="row-even"><td><p>AM437x IDK</p></td>
<td><p>MMCSD</p></td>
</tr>
<tr class="row-odd"><td><p>AM571x</p></td>
<td><p>AM571x IDK</p></td>
<td><p>MMCSD</p></td>
</tr>
<tr class="row-even"><td rowspan="2"><p>AM572x</p></td>
<td><p>AM572x EVM</p></td>
<td><p>MMCSD</p></td>
</tr>
<tr class="row-odd"><td><p>AM572x IDK</p></td>
<td><p>MMCSD</p></td>
</tr>
<tr class="row-even"><td><p>AM574x</p></td>
<td><p>AM574x IDK</p></td>
<td><p>MMCSD</p></td>
</tr>
<tr class="row-odd"><td rowspan="2"><p>K2G</p></td>
<td><p>K2G GP EVM</p></td>
<td><p>MMCSD</p></td>
</tr>
<tr class="row-even"><td><p>K2G ICE</p></td>
<td><p>MMCSD</p></td>
</tr>
<tr class="row-odd"><td><p>OMAPL137</p></td>
<td><p>OMAPL137 EVM</p></td>
<td><p>SPI</p></td>
</tr>
<tr class="row-even"><td><p>OMAPL138</p></td>
<td><p>OMAPL138 LCDK</p></td>
<td><p>MMCSD</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="apploader-load-address">
<h3>4.6.5.3. Apploader Load Address<a class="headerlink" href="#apploader-load-address" title="Permalink to this headline">¶</a></h3>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 18%" />
<col style="width: 18%" />
<col style="width: 23%" />
<col style="width: 26%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>SOC</p></th>
<th class="head"><p>PLATFORM</p></th>
<th class="head"><p>DDR Size</p></th>
<th class="head"><p>DDR Start Address</p></th>
<th class="head"><p>Apploader Load Address</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td rowspan="3"><p>AM335x</p></td>
<td><p>AM335x GP EVM</p></td>
<td><p>1GB</p></td>
<td><p>0x80010000</p></td>
<td><p>0xBFE00000</p></td>
</tr>
<tr class="row-odd"><td><p>AM335x ICEv2</p></td>
<td><p>256MB</p></td>
<td><p>0x80010000</p></td>
<td><p>0x8FD00000</p></td>
</tr>
<tr class="row-even"><td><p>AMIC110 ICE</p></td>
<td><p>512MB</p></td>
<td><p>0x80010000</p></td>
<td><p>0x9FE00000</p></td>
</tr>
<tr class="row-odd"><td rowspan="2"><p>AM437x</p></td>
<td><p>AM437x EVM</p></td>
<td><p>2GB</p></td>
<td><p>0x80000000</p></td>
<td><p>0xFFE00000</p></td>
</tr>
<tr class="row-even"><td><p>AM437x IDK</p></td>
<td><p>1GB</p></td>
<td><p>0x80000000</p></td>
<td><p>0xBFE00000</p></td>
</tr>
<tr class="row-odd"><td><p>AM571x</p></td>
<td><p>AM571x IDK</p></td>
<td><p>1GB</p></td>
<td><p>0x80000000</p></td>
<td><p>0xBFDFFFFF</p></td>
</tr>
<tr class="row-even"><td rowspan="2"><p>AM572x</p></td>
<td><p>AM572x EVM</p></td>
<td><p>2GB</p></td>
<td><p>0x80000000</p></td>
<td><p>0xFFDFFFFF</p></td>
</tr>
<tr class="row-odd"><td><p>AM572x IDK</p></td>
<td><p>2GB</p></td>
<td><p>0x80000000</p></td>
<td><p>0xFFDFFFFF</p></td>
</tr>
<tr class="row-even"><td><p>AM574x</p></td>
<td><p>AM574x IDK</p></td>
<td><p>2GB</p></td>
<td><p>0x80000000</p></td>
<td><p>0xFFDFFFFF</p></td>
</tr>
<tr class="row-odd"><td rowspan="2"><p>K2G</p></td>
<td><p>K2G GP EVM</p></td>
<td><p>2GB</p></td>
<td><p>0x80000000</p></td>
<td><p>0xFFD00000</p></td>
</tr>
<tr class="row-even"><td><p>K2G ICE</p></td>
<td><p>512MB</p></td>
<td><p>0x80000000</p></td>
<td><p>0x9FE00000</p></td>
</tr>
<tr class="row-odd"><td><p>OMAPL137</p></td>
<td><p>OMAPL137 EVM</p></td>
<td><p>64MB</p></td>
<td><p>0xC3000000</p></td>
<td><p>0xC6E00000</p></td>
</tr>
<tr class="row-even"><td><p>OMAPL138</p></td>
<td><p>OMAPL138 LCDK</p></td>
<td><p>128MB</p></td>
<td><p>0xC0000000</p></td>
<td><p>0xC7E00000</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="pre-requisites">
<h3>4.6.5.4. Pre-Requisites<a class="headerlink" href="#pre-requisites" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p>Download and install the Processor-SDK RTOS package. See the software product page for your device to get the latest version of this software:</p></li>
</ol>
<ul>
<li><p><a class="reference external" href="http://www.ti.com/tool/processor-sdk-am335x">Processor SDK for
AM335x</a></p></li>
<li><p><a class="reference external" href="http://www.ti.com/tool/processor-sdk-am437x">Processor SDK for
AM437x</a></p></li>
<li><p><a class="reference external" href="http://www.ti.com/tool/processor-sdk-am57x">Processor SDK for
AM57xx</a></p></li>
<li><p><a class="reference external" href="http://www.ti.com/tool/PROCESSOR-SDK-AMIC110">Processor SDK for
AMIC110</a></p></li>
<li><p><a class="reference external" href="http://www.ti.com/tool/processor-sdk-omapl137">Processor SDK RTOS for
C6747/OMAP-L17</a></p></li>
<li><p><a class="reference external" href="http://www.ti.com/tool/processor-sdk-omapl138">Processor SDK RTOS for
C6748/OMAP-L138</a></p></li>
<li><p><a class="reference external" href="http://www.ti.com/tool/PROCESSOR-SDK-K2G">Processor SDK RTOS for
K2G</a></p>
<p>From the appropriate software product page, go to the download page by
clicking “Get Software” for the RTOS package.</p>
</li>
</ul>
<ol class="arabic simple" start="2">
<li><p>The Uart Apploader binaries are found under &lt;pdk_install_path&gt;/packages/ti/board/utils/uartAppLoader/bin/&lt;board_name&gt;/sd/apploader_Test</p></li>
</ol>
<p><strong>Serial Connection</strong></p>
<p>Launch the serial console utility with the following configurations:</p>
<ul class="simple">
<li><p>Baud Rate: 115200</p></li>
<li><p>Data : 8 bits</p></li>
<li><p>Parity : None</p></li>
<li><p>Stop : 1 bit</p></li>
<li><p>Flow Control : None</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Any Serial Console utility that supports xmodem protocol can be used.
Verified utility is Teraterm</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>TI Binaries does not work with Apploader on AM335x/AM437x platforms.
Make sure to use non TI binaries for testing on these platforms.</p>
</div>
</div>
<div class="section" id="apploader-usage">
<h3>4.6.5.5. AppLoader Usage<a class="headerlink" href="#apploader-usage" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p>Set the sysboot pins to the relevant boot mode(SPI / MMCSD).</p></li>
<li><p>Make sure UART connection is established between Target platform and Host PC.</p></li>
<li><p>Power cycle the board.</p></li>
<li><p>Check the below output on the serial console. The application starts sending character ‘C’</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">****</span> <span class="n">PDK</span> <span class="n">SBL</span> <span class="o">****</span>
<span class="n">SBL</span> <span class="nl">Revision</span><span class="p">:</span> <span class="mf">01.00.09.00</span> <span class="p">(</span><span class="n">May</span> <span class="mi">10</span> <span class="mi">2018</span> <span class="o">-</span> <span class="mi">15</span><span class="o">:</span><span class="mi">48</span><span class="o">:</span><span class="mi">57</span><span class="p">)</span>
<span class="n">Begin</span> <span class="n">parsing</span> <span class="n">user</span> <span class="n">application</span>

<span class="n">SD</span> <span class="n">Boot</span> <span class="o">-</span> <span class="n">file</span> <span class="n">open</span> <span class="n">completed</span> <span class="n">successfully</span>
<span class="n">Jumping</span> <span class="n">to</span> <span class="n">user</span> <span class="n">application</span><span class="p">...</span>
<span class="o">*********</span> <span class="n">PDK</span> <span class="n">UART</span> <span class="n">Apploader</span> <span class="o">********</span>
<span class="n">version</span> <span class="mf">0.1</span> <span class="p">(</span><span class="n">May</span> <span class="mi">14</span> <span class="mi">2018</span> <span class="o">-</span> <span class="mi">21</span><span class="o">:</span><span class="mi">40</span><span class="o">:</span><span class="mi">11</span><span class="p">)</span>

<span class="n">Please</span> <span class="n">transfer</span> <span class="n">file</span> <span class="n">with</span> <span class="n">XMODEM</span> <span class="n">protocol</span><span class="p">...</span>
<span class="n">CCCC</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The above log is for reference purpose and content might change based on latest software available in processor SDK release</p>
</div>
<ol class="arabic simple" start="5">
<li><p>Now transfer the application binary to be tested over UART using serial console utility.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For example in Teraterm, use the following option to transfer the application binary.
File -&gt; Transfer -&gt; XMODEM -&gt; Send</p>
</div>
<ol class="arabic simple" start="6">
<li><p>Upon success, the apploader loads and executes the application.</p></li>
<li><p>Following is the sample output (using UART Diagnostic application), on the serial console.</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Xmodem</span> <span class="n">received</span> <span class="mi">46848</span> <span class="n">bytes</span>

<span class="n">Copying</span> <span class="n">application</span> <span class="n">image</span> <span class="n">from</span> <span class="n">UART</span> <span class="n">to</span> <span class="n">RAM</span> <span class="n">is</span> <span class="n">done</span>
<span class="n">Begin</span> <span class="n">parsing</span> <span class="n">user</span> <span class="n">application</span>
<span class="n">Jumping</span> <span class="n">to</span> <span class="n">user</span> <span class="n">application</span><span class="p">...</span>

<span class="o">*********************************************</span>
<span class="o">*</span>                 <span class="n">UART</span> <span class="n">Test</span>                 <span class="o">*</span>
<span class="o">*********************************************</span>

<span class="n">Testing</span> <span class="n">UART</span> <span class="n">print</span> <span class="n">to</span> <span class="n">console</span> <span class="n">at</span> <span class="mf">115.2</span><span class="n">k</span> <span class="n">baud</span> <span class="n">rate</span>
<span class="n">Press</span> <span class="sc">&#39;y&#39;</span> <span class="n">to</span> <span class="n">verify</span> <span class="nl">pass</span><span class="p">:</span> <span class="n">y</span>
<span class="nl">Received</span><span class="p">:</span> <span class="n">y</span>

<span class="n">Test</span> <span class="n">PASSED</span><span class="o">!</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For SPI Boot Mode:
1. Program Apploader to SPI flash using <a class="reference external" href="index_board.html#programming-binaries-to-flash-device">Uniflash</a> and boot the device from SPI flash.
2. Set the sysboot pins to SPI Boot mode</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For MMCSD Boot Mode:
1. Copy MLO to SD card.
2. Rename apploader_Test to app and copy to SD card.
3. Set the sysboot pins to MMCSD Boot mode</p>
</div>
</div>
<div class="section" id="rebuilding-apploader">
<h3>4.6.5.6. Rebuilding AppLoader<a class="headerlink" href="#rebuilding-apploader" title="Permalink to this headline">¶</a></h3>
<p>Apploader pre-built binaries are currently not available for OMAPL137/L138 platforms.
Binaries needs to be manually built for these platforms.</p>
<p>Refer <a class="reference internal" href="index_board.html#rebuild-board-utils"><span class="std std-ref">Rebuilding Board-utils</span></a> section to build Apploader.</p>
</div>
</div>
</div>
<div class="section" id="mpm">
<h1>4.7. MPM<a class="headerlink" href="#mpm" title="Permalink to this headline">¶</a></h1>
<p class="rubric" id="id150">Introduction</p>
<div class="line-block">
<div class="line">The Multiple Proc Manager (MPM) Package distributed with Processor SDK
RTOS installer has multiple software modules.</div>
<div class="line">Broadly the modules can be grouped into two categories:</div>
</div>
<ul class="simple">
<li><p>Multi Proc Manager Linux module</p></li>
<li><p>Modules that facilitate Interprocess communication between the
multiple cores.</p></li>
</ul>
<p class="rubric" id="multi-proc-manager-linux-module">Multi Proc Manager Linux module</p>
<p>The Multi Proc Manager Linux module is used to load and run DSP images
from ARM Linux user space. The download and run operations can be
exercised by using user space API calls. MPM also provides a MPM Client
Application which can be used to load and run DSP through command line.</p>
<p class="rubric" id="interprocessor-communication-related-packages">Interprocessor Communication related packages</p>
<p>The Multi Proc Manager package also includes couple of software modules
that facilitates Inter processor communication between ARM running linux
and DSP running RTOS. These components provide APIs in both ARM linux as
well as on DSP RTOS.</p>
<p class="rubric" id="mpm-mailbox-module">MPM Mailbox module</p>
<p>Mailbox is used for exchanging control messages between the host and
individual DSP cores.</p>
<p class="rubric" id="mpm-sync-module">MPM Sync module</p>
<p>Sync Module implements support for Multicore Barriers and Locks.</p>
</div>
<div class="section" id="openmp">
<h1>4.8. OpenMP<a class="headerlink" href="#openmp" title="Permalink to this headline">¶</a></h1>
<p class="rubric" id="id151">Introduction</p>
<p>As of April 2016, this article is out of date. Please visit
<a class="reference external" href="http://downloads.ti.com/mctools/esd/docs/openmp-dsp/index.html">here</a>.</p>
<p>This page is intended to be the starting point for all information about
OpenMP on C6000. However, at this writing, that is not the case. The
information in this article is correct if you are using C667x devices
which only contain C66x CorePac DSPs, and not any ARM cores. If you are
using a 66AK2H device, then please see <a class="reference external" href="http://processors.wiki.ti.com/index.php/MCSDK_HPC_3.x_OpenMP">MCSDK HPC 3.x
OpenMP</a>. OpenMP is not supported on
any other C6000 devices.</p>
<p>Still here? After reading this article, you will be able to execute your
own OpenMP code on C6000 under control of Code Composer Studio.</p>
<p class="rubric" id="presumptions">Presumptions</p>
<ul class="simple">
<li><p>You are experienced at programming OpenMP applications on hosted
systems like Windows or Linux PC’s.</p></li>
<li><p>You have never programmed anything on an embedded system like those
that use C6000 devices.</p></li>
<li><p>You have never used any TI development tools such as Code Composer
Studio (CCS).</p></li>
</ul>
<p class="rubric" id="acronyms-used-in-this-article">Acronyms Used in This Article</p>
<ul class="simple">
<li><p>CCS - Code Composer Studio. Software development environment for
creating code to execute on TI devices.</p></li>
<li><p>SYS/BIOS - Or BIOS for short. Scalable real-time kernel which runs on
the DSP.</p></li>
<li><p>MCSDK - Multicore Software Development Kit. Bundles all the software
supplied by TI which runs on the DSP.</p></li>
</ul>
<p class="rubric" id="conceptual-overview">Conceptual Overview</p>
<p>This section discusses, at a high level, how different pieces of
software from TI work together to form the OpenMP solution.</p>
<p>The OpenMP source code, at the level of OpenMP pragmas and function
calls, is the same. Your code must be organized into a <em>project</em>, as
that term is defined by CCS. A central element of this project is the
SYS/BIOS configuration. SYS/BIOS (or BIOS for short) is a scalable
real-time kernel produced by TI. BIOS implements the multi-threading
features of OpenMP. An initial BIOS configuration (<a href="#id152"><span class="problematic" id="id153">*</span></a>.cfg) is supplied.
Changing this BIOS configuration may never be required. The build is
done within CCS. At the start, system execution is also done within CCS.
Besides BIOS, many other software components execute on the DSP to
comprise the OpenMP solution. All of these components are delivered
together under the name Multicore Software Development Kit (MCSDK).</p>
<p class="rubric" id="installation">Installation</p>
<p>Getting the MCSDK installed calls for you to install and configure
everything else, so this section focuses on the MCSDK.</p>
<p>Start with the <a class="reference external" href="http://www.ti.com/tool/bioslinuxmcsdk">general download
page</a> for all flavors of the
MCSDK. Follow the link for <em>SYS/BIOS MCSDK for C66x</em>. Get MCSDK version
2.1 or later. That page includes a link to a <em>Getting Started Guide</em>.
That is where you will find directions on hardware setup, installing
CCS, and so on. Follow all the steps in the Getting Started Guide, up to
Running the Demonstration Application. (Actually, go ahead and run the
Demo if you want. But it isn’t required.)</p>
<p class="rubric" id="confidence-test">Confidence Test</p>
<p>If you are familiar with CCS, you may skip over this section. But,
installing and configuring all that software may leave you wondering if
you did it all correctly. In this section, simplify things by pretending
your system only has one core. This allows you to check whether you have
installed most of the software correctly, while ignoring many of the
complicated details.</p>
<p>Please check out <a class="reference external" href="http://processors.wiki.ti.com/index.php/Category:Code_Composer_Studio_v5#Getting_Started">this set of Getting Started
Guides</a>
just for CCS. You only need to go through one of them. Choose the one
that seems best for you. These guides provide a gentle introduction to
those who are new to CCS.</p>
<p>When you load and run your first program, CCS needs to know which core
to run it on. You see a dialog box similar this one:</p>
<img alt="../_images/Select_core.JPG" src="../_images/Select_core.JPG" />
<p>Check the box only for core 0.</p>
<p class="rubric" id="first-openmp-project">First OpenMP Project</p>
<p>This section walks through a simple hello world example project. Four
threads run concurrently. Each thread prints hello world and the thread
ID.</p>
<p class="rubric" id="version-and-hw-information">Version and HW Information</p>
<p>This section was developed with CCS version 5.2.0.00069, MCSDK version
2.1.0.3, and executed on an C6678 EVM. If your environment differs, you
may have to make a few adjustments.</p>
<p class="rubric" id="project-setup">Project Setup</p>
<p>In this section you create a new CCS project. This project is not
written from scratch, but uses example source files that come with CCS.</p>
<p>Put CCS in the Edit Perspective. Select: <strong>Window | Open Perspective |
Other | CCS Edit</strong>. To start this new project select: <strong>Project | New
CCS Project</strong>. Enter a <strong>Project Name</strong>. For <strong>Family</strong> select
<strong>C6000</strong>. For <strong>Variant</strong>, ignore the first drop-down box, and in the
second choose <strong>Generic C66xx Device</strong>. In the box just under <strong>Project
templates and examples</strong> type in <em>hello</em>. Under <em>OMP Examples</em> you will
see some <em>Hello world example</em> projects. Select the best one for your HW
platform. In this screen shot, the selection is for C6678. Select
<strong>Next</strong>.</p>
<img alt="../_images/Omp_h1_project_setup.jpg" src="../_images/Omp_h1_project_setup.jpg" />
<p>The next dialog shows the RTSC Configuration Settings. If only one
version of the MCSDK is installed, then nothing more is required. If
more than one version of the MCSDK is installed, review the version
numbers of the selected packages and insure they are from the desired
MCSDK. Do not forget the drop-down box at the top for the version of the
XDCtools.</p>
<p>Click <strong>Finish</strong>. CCS creates the project, complete with source code,
and adds an entry to the <strong>Project Explorer</strong> window.</p>
<p class="rubric" id="project-modifications">Project Modifications</p>
<p>One modification to the example project is required.</p>
<p>In the <strong>Project Explorer</strong> window, expand the set of files available
under the new project. Open the file <em>omp_config.cfg</em> by double-clicking
on it. The edit window has two tabs on the bottom left. Select the
<strong>Source</strong> tab. Find the source line which begins <em>var OpenMP …</em>
Change the code as follows …</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>var OpenMP = xdc.useModule(&#39;ti.omp.utils.OpenMP&#39;);    // no change
OpenMP.setNumProcessors(4);                           // no change
OpenMP.autoDnldCore = false;                          // add this line
</pre></div>
</div>
<p>The new line disables the feature called auto-download. A side effect of
auto-download is that printf works only on core 0.</p>
<p>Save the change to the configuration file by entering control+S or
selecting <strong>File | Save</strong>.</p>
<p class="rubric" id="build-and-load">Build and Load</p>
<p>The target configuration that should launch when this OpenMP project is
debugged is the same one used for previous single core projects. To
check on this detail, choose <strong>View | Target Configurations</strong>. Find
that target configuration and insure it is the default.</p>
<p>In the <strong>Project Explorer</strong> window, insure the new project is selected.</p>
<p>Select the Debug icon.</p>
<img alt="../_images/Omp_h2_debug_icon.JPG" src="../_images/Omp_h2_debug_icon.JPG" />
<p>Next a dialog will come up which asks which CPU cores to load the
program on. Select cores 0-3, then click <strong>OK</strong>. It will appear similar
to this …</p>
<img alt="../_images/Omp_h3_select_cores.JPG" src="../_images/Omp_h3_select_cores.JPG" />
<p>The following actions take place automatically:</p>
<ul class="simple">
<li><p>CCS changes to the Debug perspective</p></li>
<li><p>The project is built</p></li>
<li><p>The target configuration is launched</p></li>
<li><p>The target connection is made</p></li>
<li><p>The program is loaded on cores 0-3</p></li>
<li><p>The system begins execution and runs to the start of main on core 0</p></li>
</ul>
<p class="rubric" id="execute-and-see-output">Execute and See Output</p>
<p>Now you are ready to execute. In the Debug window, click the Resume
execution icon.</p>
<img alt="../_images/Omp_h4_resume_icon.JPG" src="../_images/Omp_h4_resume_icon.JPG" />
<p>The console window will show output similar to, but not exactly the same
as, the following …</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span> <span class="n">Hello</span> <span class="n">World</span> <span class="n">from</span> <span class="kr">thread</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span> <span class="n">Number</span> <span class="n">of</span> <span class="n">threads</span> <span class="o">=</span> <span class="mi">4</span>
<span class="p">[</span><span class="n">C66xx_1</span><span class="p">]</span> <span class="n">Hello</span> <span class="n">World</span> <span class="n">from</span> <span class="kr">thread</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">[</span><span class="n">C66xx_2</span><span class="p">]</span> <span class="n">Hello</span> <span class="n">World</span> <span class="n">from</span> <span class="kr">thread</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">[</span><span class="n">C66xx_3</span><span class="p">]</span> <span class="n">Hello</span> <span class="n">World</span> <span class="n">from</span> <span class="kr">thread</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div>
</div>
<p>Because the threads are executing on the cores concurrently, there is no
control over the order in which the output appears. But you should see
all of these lines.</p>
<p class="rubric" id="tips-on-system-startup">Tips on System Startup</p>
<p>If things do not go smoothly, please see the article
<a class="reference external" href="http://processors.wiki.ti.com/index.php/SystemAnalyzerTutorial7">SystemAnalyzerTutorial7</a>. That
article is about running a tutorial for a tool named Unified
Instrumentation Architecture (UIA). UIA is for analyzing system
performance and behavior. This tutorial contains several tips on how to
use CCS to run OpenMP programs. It is relevant to the versions of the
MCSDK components listed near the beginning.</p>
<p class="rubric" id="second-openmp-project">Second OpenMP Project</p>
<p>Now try another project like hello world, but a bit more complicated. It
will serve as the basis for your future OpenMP projects.</p>
<p class="rubric" id="project-setup-1">Project Setup</p>
<p>Start it the same way as the hello world project. But give it a
different name, look for <em>matrix</em> among the examples, and choose the
<em>OpenMP matrix vector multiplication example</em> for your system.</p>
<img alt="../_images/Omp_h5_matvec_setup.JPG" src="../_images/Omp_h5_matvec_setup.JPG" />
<p class="rubric" id="build-and-execute">Build and Execute</p>
<p>All the remaining steps are the same as with the hello world project.</p>
<p>Upon executing, output in the console window should appear similar to
…</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span> <span class="n">Starting</span> <span class="n">values</span> <span class="n">of</span> <span class="n">matrix</span> <span class="n">A</span> <span class="n">and</span> <span class="n">vector</span> <span class="nl">b</span><span class="p">:</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>   <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span> <span class="mf">2.0</span> <span class="mf">3.0</span> <span class="mf">4.0</span> <span class="mf">5.0</span> <span class="mf">6.0</span> <span class="mf">7.0</span> <span class="mf">8.0</span> <span class="mf">9.0</span> <span class="mf">10.0</span>   <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>   <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span> <span class="mf">2.0</span> <span class="mf">3.0</span> <span class="mf">4.0</span> <span class="mf">5.0</span> <span class="mf">6.0</span> <span class="mf">7.0</span> <span class="mf">8.0</span> <span class="mf">9.0</span> <span class="mf">10.0</span>   <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span> <span class="mf">2.0</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>   <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span> <span class="mf">2.0</span> <span class="mf">3.0</span> <span class="mf">4.0</span> <span class="mf">5.0</span> <span class="mf">6.0</span> <span class="mf">7.0</span> <span class="mf">8.0</span> <span class="mf">9.0</span> <span class="mf">10.0</span>   <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span> <span class="mf">3.0</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>   <span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span> <span class="mf">2.0</span> <span class="mf">3.0</span> <span class="mf">4.0</span> <span class="mf">5.0</span> <span class="mf">6.0</span> <span class="mf">7.0</span> <span class="mf">8.0</span> <span class="mf">9.0</span> <span class="mf">10.0</span>   <span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span> <span class="mf">4.0</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>   <span class="n">A</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span> <span class="mf">2.0</span> <span class="mf">3.0</span> <span class="mf">4.0</span> <span class="mf">5.0</span> <span class="mf">6.0</span> <span class="mf">7.0</span> <span class="mf">8.0</span> <span class="mf">9.0</span> <span class="mf">10.0</span>   <span class="n">b</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span> <span class="mf">5.0</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>   <span class="n">A</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span> <span class="mf">2.0</span> <span class="mf">3.0</span> <span class="mf">4.0</span> <span class="mf">5.0</span> <span class="mf">6.0</span> <span class="mf">7.0</span> <span class="mf">8.0</span> <span class="mf">9.0</span> <span class="mf">10.0</span>   <span class="n">b</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">=</span> <span class="mf">6.0</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>   <span class="n">A</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span> <span class="mf">2.0</span> <span class="mf">3.0</span> <span class="mf">4.0</span> <span class="mf">5.0</span> <span class="mf">6.0</span> <span class="mf">7.0</span> <span class="mf">8.0</span> <span class="mf">9.0</span> <span class="mf">10.0</span>   <span class="n">b</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">=</span> <span class="mf">7.0</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>   <span class="n">A</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span> <span class="mf">2.0</span> <span class="mf">3.0</span> <span class="mf">4.0</span> <span class="mf">5.0</span> <span class="mf">6.0</span> <span class="mf">7.0</span> <span class="mf">8.0</span> <span class="mf">9.0</span> <span class="mf">10.0</span>   <span class="n">b</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">=</span> <span class="mf">8.0</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>   <span class="n">A</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span> <span class="mf">2.0</span> <span class="mf">3.0</span> <span class="mf">4.0</span> <span class="mf">5.0</span> <span class="mf">6.0</span> <span class="mf">7.0</span> <span class="mf">8.0</span> <span class="mf">9.0</span> <span class="mf">10.0</span>   <span class="n">b</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">=</span> <span class="mf">9.0</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>   <span class="n">A</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span> <span class="mf">2.0</span> <span class="mf">3.0</span> <span class="mf">4.0</span> <span class="mf">5.0</span> <span class="mf">6.0</span> <span class="mf">7.0</span> <span class="mf">8.0</span> <span class="mf">9.0</span> <span class="mf">10.0</span>   <span class="n">b</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="o">=</span> <span class="mf">10.0</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span> <span class="n">Results</span> <span class="n">by</span> <span class="kr">thread</span><span class="o">/</span><span class="nl">row</span><span class="p">:</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>   <span class="kr">thread</span> <span class="mi">0</span> <span class="n">did</span> <span class="n">row</span> <span class="mi">0</span>   <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mf">55.00</span> <span class="n">Running</span> <span class="n">total</span><span class="o">=</span> <span class="mf">55.00</span>
<span class="p">[</span><span class="n">C66xx_3</span><span class="p">]</span>   <span class="kr">thread</span> <span class="mi">3</span> <span class="n">did</span> <span class="n">row</span> <span class="mi">9</span>   <span class="n">c</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="o">=</span><span class="mf">550.00</span>    <span class="n">Running</span> <span class="n">total</span><span class="o">=</span> <span class="mf">605.00</span>
<span class="p">[</span><span class="n">C66xx_1</span><span class="p">]</span>   <span class="kr">thread</span> <span class="mi">1</span> <span class="n">did</span> <span class="n">row</span> <span class="mi">3</span>   <span class="n">c</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="mf">220.00</span>    <span class="n">Running</span> <span class="n">total</span><span class="o">=</span> <span class="mf">825.00</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>   <span class="kr">thread</span> <span class="mi">0</span> <span class="n">did</span> <span class="n">row</span> <span class="mi">1</span>   <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mf">110.00</span>    <span class="n">Running</span> <span class="n">total</span><span class="o">=</span> <span class="mf">935.00</span>
<span class="p">[</span><span class="n">C66xx_1</span><span class="p">]</span>   <span class="kr">thread</span> <span class="mi">1</span> <span class="n">did</span> <span class="n">row</span> <span class="mi">4</span>   <span class="n">c</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="mf">275.00</span>    <span class="n">Running</span> <span class="n">total</span><span class="o">=</span> <span class="mf">1210.00</span>
<span class="p">[</span><span class="n">C66xx_2</span><span class="p">]</span>   <span class="kr">thread</span> <span class="mi">2</span> <span class="n">did</span> <span class="n">row</span> <span class="mi">6</span>   <span class="n">c</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">=</span><span class="mf">385.00</span>    <span class="n">Running</span> <span class="n">total</span><span class="o">=</span> <span class="mf">1595.00</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>   <span class="kr">thread</span> <span class="mi">0</span> <span class="n">did</span> <span class="n">row</span> <span class="mi">2</span>   <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="mf">165.00</span>    <span class="n">Running</span> <span class="n">total</span><span class="o">=</span> <span class="mf">1760.00</span>
<span class="p">[</span><span class="n">C66xx_1</span><span class="p">]</span>   <span class="kr">thread</span> <span class="mi">1</span> <span class="n">did</span> <span class="n">row</span> <span class="mi">5</span>   <span class="n">c</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">=</span><span class="mf">330.00</span>    <span class="n">Running</span> <span class="n">total</span><span class="o">=</span> <span class="mf">2090.00</span>
<span class="p">[</span><span class="n">C66xx_2</span><span class="p">]</span>   <span class="kr">thread</span> <span class="mi">2</span> <span class="n">did</span> <span class="n">row</span> <span class="mi">7</span>   <span class="n">c</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">=</span><span class="mf">440.00</span>    <span class="n">Running</span> <span class="n">total</span><span class="o">=</span> <span class="mf">2530.00</span>
<span class="p">[</span><span class="n">C66xx_2</span><span class="p">]</span>   <span class="kr">thread</span> <span class="mi">2</span> <span class="n">did</span> <span class="n">row</span> <span class="mi">8</span>   <span class="n">c</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">=</span><span class="mf">495.00</span>    <span class="n">Running</span> <span class="n">total</span><span class="o">=</span> <span class="mf">3025.00</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span> <span class="n">Matrix</span><span class="o">-</span><span class="n">vector</span> <span class="n">total</span> <span class="o">-</span> <span class="n">sum</span> <span class="n">of</span> <span class="n">all</span> <span class="n">c</span><span class="p">[]</span> <span class="o">=</span> <span class="mf">3025.00</span>
<span class="p">[</span><span class="n">C66xx_0</span><span class="p">]</span>
</pre></div>
</div>
<p>The parts before and after <em>Results by thread/row</em> should match,
particularly the final result of 3025.00. The <em>thread N</em> lines will
vary, but there should be one line for each row 0-9.</p>
<p class="rubric" id="start-your-openmp-project">Start Your OpenMP Project</p>
<p>Build your OpenMP project out of the matrix multiply project. In the
<strong>Project Explorer</strong> window, select the matrix multiply project,
right-click and choose <strong>Copy</strong>. Right-click again and choose <strong>Paste</strong>.
Give the new project a name. It starts as a copy of the matrix multiply
project in every respect, except the name. Remove files, add files, and
make the project your own. Modifications to the omp_config.cfg file are
not required for base functionality.</p>
<p class="rubric" id="debugging-tips">Debugging Tips</p>
<p>Suppose you want to immediately execute one of those example projects
again. You need to reset the CPU cores, reload the program, and run
again. Here is a good way to do that.</p>
<p>In the <strong>Debug</strong> window, select cores 0-3, right-click and choose
<strong>Group Core(s)</strong>.</p>
<img alt="../_images/Omp_h6_group_cores.JPG" src="../_images/Omp_h6_group_cores.JPG" />
<p>Now reset the cores in the newly formed group. Select the group and
click the <strong>CPU Reset</strong> icon near the top right of the <strong>Debug</strong> window.</p>
<p>CPU Reset icon</p>
<img alt="../_images/Omp_h7_cpu_reset.JPG" src="../_images/Omp_h7_cpu_reset.JPG" />
<p>Then reload the program with the menu selection <strong>Run | Load | Reload
Program</strong>. Now you are ready to resume execution as before. Compare with
the output you got last time, and see how some lines are in a different
order.</p>
<p class="rubric" id="how-to-obtain-support">How to Obtain Support</p>
<p>Post your questions and suspected bugs to the <a class="reference external" href="http://e2e.ti.com/support/development_tools/compiler/f/343.aspx">compiler
forum</a>
with the tag <code class="docutils literal notranslate"><span class="pre">openmp</span></code>. Please use the tag. Use of the tag triggers an
e-mail to the current support team. Without the tag, the issue may go
unnoticed for some time.</p>
</div>
<div class="section" id="pktlib">
<h1>4.9. PKTLIB<a class="headerlink" href="#pktlib" title="Permalink to this headline">¶</a></h1>
<p class="rubric" id="id154">Introduction</p>
<p>The packet library (PKTLIB) provides higher layer of abstraction for
underlying CPPI hardware descriptors to application layer.
Functionalities include:</p>
<ul class="simple">
<li><p>Zero copy operation for:</p>
<ul>
<li><p>Packet split/merge operations</p></li>
<li><p>Cloning operations</p></li>
<li><p>Headroom/Tail room addition through merge operation</p></li>
</ul>
</li>
<li><p>Allocations of packet buffer and descriptors during startup time</p></li>
<li><p>Allows packet allocation by HW at Rx CPPI DMA</p></li>
<li><p>Efficient recycling of data buffers including the case of buffers
being referenced by multiple CPPI descriptors</p></li>
</ul>
<p class="rubric" id="id155">Modes of Operation</p>
<p>A pktlib heap can be created in on of the following two modes:</p>
<ul class="simple">
<li><p>Private: only visible on the core where the heap was created</p></li>
<li><p>Shared: visible across multiple cores</p></li>
</ul>
<p class="rubric" id="driver-configuration-pktlib">Driver Configuration</p>
<p>Applications can use Pktlib_createHeap() API to create heap(s) in the
system and heap properties are specified by the Pktlib_HeapCfg
configuration structure. This configuration structure should be
populated by the application and passed to the PKTLIB module when a heap
is being created via the Pktlib_createHeap() API. Multiple heaps can
exist in the system where each heaps properties are specified by the
Pktlib_HeapCfg configuration structure.</p>
<p>For details about individual fields of this structure, see the Doxygen
help by opening
PDK_INSTALL_DIRpackagestiruntimepktlibdocsdoxygenhtmlindex.html.</p>
<p class="rubric" id="id156"><strong>APIs</strong></p>
<p>API reference for application can be found in below file:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;ti/runtime/pktlib/pktlib.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p class="rubric" id="id157">Example</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Expected Results</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>pktlibUnitTest
Application</p></td>
<td><div class="line-block">
<div class="line">Unit Test
application to test
all APIs</div>
</div>
</td>
<td><div class="line-block">
<div class="line">User observes the
output printed over
the CCS console</div>
</div>
</td>
</tr>
</tbody>
</table>
<p class="rubric" id="id158">Additional References</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Document</strong></p></td>
<td><p><strong>Location</strong></p></td>
</tr>
<tr class="row-even"><td><p>API Reference Manual</p></td>
<td><p>$(TI_PDK_INSTALL_DIR)packagesti
runtimepktlibdocsdoxygenhtml
index.html</p></td>
</tr>
<tr class="row-odd"><td><p>Release Notes</p></td>
<td><p>$(TI_PDK_INSTALL_DIR)packagesti
runtimepktlibdocsReleaseNotes
_pktlib.pdf</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="network">
<h1>4.10. Network<a class="headerlink" href="#network" title="Permalink to this headline">¶</a></h1>
<div class="section" id="cclink">
<h2>4.10.1. CCLink<a class="headerlink" href="#cclink" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id159">
<h3>4.10.1.1. Introduction<a class="headerlink" href="#id159" title="Permalink to this headline">¶</a></h3>
<p>CC-Link is an open-architecture network that was originally developed
by the Mitsubishi Electric Corporation.It have been widely used in
Process control, building automation etc. CLPA (CC-Link Partner
Association) maintains the network technology and support many
manufacturer supporting the application. CC-Link is available in
multiple flavours i.e. CC-Link, CC-Link LT, CC-Link Safety, CC-Link IE
(Industrial Ethernet) - Control and CC-Link IE Field. For further
details regarding CCLink and its flavours please refer the CLPA
website.<a class="reference external" href="http://am.cc-link.org/en/index.html">[1]</a></p>
</div>
<div class="section" id="protocol-overview">
<h3>4.10.1.2. Protocol Overview<a class="headerlink" href="#protocol-overview" title="Permalink to this headline">¶</a></h3>
<p>The implementation will demonstrate how to create, run and test CC-Link
IE Field Network Basic examples on TI platforms. The following shows the
CC-Link IE Field Network Basic Overview:</p>
<ul class="simple">
<li><p>1 Gbit/s Ethernet based network</p></li>
<li><p>Ethernet physical layer (Cat5e cable &amp; RJ45 connectors)</p></li>
<li><p>254 stations per network</p></li>
<li><p>100 meters between stations</p></li>
<li><p>Completely deterministic without using switches</p></li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="code-organization">
<h3>4.10.1.3. Code Organization<a class="headerlink" href="#code-organization" title="Permalink to this headline">¶</a></h3>
<p>The Directory structure for CC-Link IE Field Network Basic source code
and examples for both NIMU and NIMU_ICSS is shown in the following
table.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 27%" />
<col style="width: 73%" />
</colgroup>
<tbody>
<tr class="row-odd"><td colspan="2"><p><strong>CCLink for CPSW i.e. NIMU</strong></p></td>
</tr>
<tr class="row-even"><td rowspan="2"><p><strong>Master Station Source code</strong></p></td>
<td rowspan="2"><p>$(TI_PDK_INSTALL_DIR)/packages/ti/transport/ndk/nimu/example/CCLink/cclink_master</p></td>
</tr>
<tr class="row-odd"></tr>
<tr class="row-even"><td rowspan="2"><p><strong>SLave Station Source code</strong></p></td>
<td rowspan="2"><p>$(TI_PDK_INSTALL_DIR)/packages/ti/transport/ndk/nimu/example/CCLink/cclink_slave</p></td>
</tr>
<tr class="row-odd"></tr>
<tr class="row-even"><td rowspan="2"><p><strong>Test Examples script</strong></p></td>
<td rowspan="2"><p>$(TI_PDK_INSTALL_DIR)/packages/ti/transport/ndk/nimu/example/CCLink/&lt;SOC&gt;</p></td>
</tr>
<tr class="row-odd"></tr>
<tr class="row-even"><td rowspan="2"><p><strong>Test Examples main code</strong></p></td>
<td rowspan="2"><p>$(TI_PDK_INSTALL_DIR)/packages/ti/transport/ndk/nimu/example/CCLink/src</p></td>
</tr>
<tr class="row-odd"></tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 26%" />
<col style="width: 74%" />
</colgroup>
<tbody>
<tr class="row-odd"><td colspan="2"><p><strong>CCLink for ICSS i.e. NIMU_ICSS</strong></p></td>
</tr>
<tr class="row-even"><td rowspan="2"><p><strong>Master Station Source code</strong></p></td>
<td rowspan="2"><p>$(TI_PDK_INSTALL_DIR)/packages/ti/transport/ndk/nimu_icss/example/CCLink/cclink_master</p></td>
</tr>
<tr class="row-odd"></tr>
<tr class="row-even"><td rowspan="2"><p><strong>Slave Station Source code</strong></p></td>
<td rowspan="2"><p>$(TI_PDK_INSTALL_DIR)/packages/ti/transport/ndk/nimu_icss/example/CCLink/cclink_slave</p></td>
</tr>
<tr class="row-odd"></tr>
<tr class="row-even"><td rowspan="2"><p><strong>Test Examples script</strong></p></td>
<td rowspan="2"><p>$(TI_PDK_INSTALL_DIR)/packages/ti/transport/ndk/nimu_icss/example/CCLink/&lt;SOC&gt;</p></td>
</tr>
<tr class="row-odd"></tr>
<tr class="row-even"><td rowspan="2"><p><strong>Test Examples main code</strong></p></td>
<td rowspan="2"><p>$(TI_PDK_INSTALL_DIR)/packages/ti/transport/ndk/nimu_icss/example/CCLink/src</p></td>
</tr>
<tr class="row-odd"></tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="building-the-examples">
<h3>4.10.1.4. Building the Examples<a class="headerlink" href="#building-the-examples" title="Permalink to this headline">¶</a></h3>
<p>Use pdkProjectCreate.sh for Linux environment or pdkProjectCreate.bat
for Windows.
This can be found under the &lt;PDK&gt;/packages folder. The only
modification to these scripts, if any, is to update the
CCS_INSTALL_PATH variable to point to CCS location if its not in the
c:ticcsv6 directory . Please refer to <a class="reference external" href="index_how_to_guides.html#rebuild-drivers-from-pdk-directory">Rebuilding
PDK</a> for details of example project
creation and how to run the example projects using CCS.</p>
<div class="section" id="cc-link-ie-field-network-basic-example-description">
<h4>4.10.1.4.1. CC-Link IE Field Network Basic Example Description<a class="headerlink" href="#cc-link-ie-field-network-basic-example-description" title="Permalink to this headline">¶</a></h4>
<p>For each EVM Type supported, there is a cclink example which demonstates
cyclic data communication between master and slave station. Once the
application is loaded via CCS and run, you will be able to see master
sending cyclic data packets and slave receiving the packet. For example,
the config file for NIMU for CPSW for idkAM572x, can be found in
ti/transport/ndk/nimu/example/CCLink/am572x/armv7/bios/cclink_idkAM572x.cfg.
The default IP address for master is 192.168.3.100 and for slave it is
192.168.3.4. If you wish to re-configure the IP address of the CPSW
interface you will need to modify the following configuration
parameters. make sure master and slave are in same network.</p>
<ul class="simple">
<li><p>Ip.address = “new ip address”</p></li>
<li><p>Ip.mask = “new ip mask”</p></li>
<li><p>Ip.gatewayIpAddr = “new gatewayIpAddr”</p></li>
</ul>
<p>If you do change these settings, you will be required to re-build the
Example Project using CCS.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>EVM Configuration</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NIMU_CCLinkMaster_&lt;ev
m/idk&gt;XXXX_&lt;arm/c66x/
m4&gt;Exampleproject.txt</p></td>
<td><div class="line-block">
<div class="line">Example
demonstrates CCLink
master station
sending cyclic
packet to slave.</div>
</div>
</td>
<td><div class="line-block">
<div class="line">icev2AM335x:
Jumpers J18 and J19
need to be set
properly to select
CPSW or ICSS mode.</div>
</div>
<div class="line-block">
<div class="line">Pin2 and Pin3 need
to be connected for
ICSS mode and Pin1
and Pin2 for CPSW
mode.</div>
</div>
<p>Update *.cfg file
with static IP to
test. NIMU for CPSW
test Tests requires
connection of
configured Ethernet
port under test to
external PC on same
subnet.</p>
</td>
</tr>
<tr class="row-odd"><td><p>NIMU_CCLinkSlave_&lt;evm
/idk&gt;XXXX_&lt;arm/c66x/m
4&gt;Exampleproject.txt</p></td>
<td><div class="line-block">
<div class="line">Example
demonstrates CCLink
slave station
receiving cyclic
packet from master
and sending a
response back.</div>
</div>
</td>
<td><div class="line-block">
<div class="line">icev2AM335x:
Jumpers J18 and J19
need to be set
properly to select
CPSW or ICSS mode.</div>
</div>
<div class="line-block">
<div class="line">Pin2 and Pin3 need
to be connected for
ICSS mode and Pin1
and Pin2 for CPSW
mode.</div>
</div>
<p>Update *.cfg file
with static IP to
test. NIMU for CPSW
test Tests requires
connection of
configured PRU-ICSS
Ethernet port under
test to external PC
on same subnet.</p>
</td>
</tr>
<tr class="row-even"><td><p>NIMU_ICSS_CCLinkMaste
r_&lt;evm/idk&gt;XXXX_&lt;arm/
c66x/m4&gt;Exampleprojec
t.txt</p></td>
<td><div class="line-block">
<div class="line">Example
demonstrates CCLink
master station
sending cyclic
packet to slave.</div>
</div>
</td>
<td><div class="line-block">
<div class="line">icev2AM335x:
Jumpers J18 and J19
need to be set
properly to select
CPSW or ICSS mode.</div>
</div>
<div class="line-block">
<div class="line">Pin2 and Pin3 need
to be connected for
ICSS mode and Pin1
and Pin2 for CPSW
mode.</div>
</div>
<p>Update *.cfg file
with static IP to
test. NIMU for CPSW
test Tests requires
connection of
configured Ethernet
port under test to
external PC on same
subnet.</p>
</td>
</tr>
<tr class="row-odd"><td><p>NIMU_ICSS_CCLinkSlave
_&lt;evm/idk&gt;XXXX_&lt;arm/c
66x/m4&gt;Exampleproject
.txt</p></td>
<td><div class="line-block">
<div class="line">Example
demonstrates CCLink
slave station
receiving cyclic
packet from master
and sending a
response back.</div>
</div>
</td>
<td><div class="line-block">
<div class="line">icev2AM335x:
Jumpers J18 and J19
need to be set
properly to select
CPSW or ICSS mode.</div>
</div>
<div class="line-block">
<div class="line">Pin2 and Pin3 need
to be connected for
ICSS mode and Pin1
and Pin2 for CPSW
mode.</div>
</div>
<p>Update *.cfg file
with static IP to
test. NIMU for CPSW
test Tests requires
connection of
configured PRU-ICSS
Ethernet port under
test to external PC
on same subnet.</p>
</td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="running-cc-link-ie-field-network-basic-example">
<h4>4.10.1.4.2. Running CC-Link IE Field Network Basic example<a class="headerlink" href="#running-cc-link-ie-field-network-basic-example" title="Permalink to this headline">¶</a></h4>
<p>The following is the test setup needed to run the example for CCLink
demonstration on TI platform. Connect the tested eth port of the evm to
a switch for master station. Do the same connection for slave station to
same switch.</p>
<img alt="../_images/Cclink_setup_pic.PNG" src="../_images/Cclink_setup_pic.PNG" />
<div class="line-block">
<div class="line"><br /></div>
<div class="line">Once the connection is done, load master and slave station code on
both evm and run them simultaneously. You would see following output
on uart port of master station.</div>
</div>
<img alt="../_images/Cclink_master_screeshot_linux.png" src="../_images/Cclink_master_screeshot_linux.png" />
<p>You would see following output on uart port of slave station.</p>
<img alt="../_images/Cclink_slave_screenshot_linux.png" src="../_images/Cclink_slave_screenshot_linux.png" />
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
</div>
<div class="section" id="ndk">
<h2>4.10.2. NDK<a class="headerlink" href="#ndk" title="Permalink to this headline">¶</a></h2>
<div class="section" id="ndk-overview">
<h3>4.10.2.1. NDK Overview<a class="headerlink" href="#ndk-overview" title="Permalink to this headline">¶</a></h3>
<p>The Network Development Kit (NDK) is a platform for development and
demonstration of network enabled RTOS applications on TI processors and
includes demonstration software showcasing capabilities across a range
of network enabled applications. The NDK serves as a rapid prototype
platform for the development of network and packet processing
applications, or to add network connectivity to existing applications
for communications, configuration, and control. Using the components
provided in the NDK, developers can quickly move from development
concepts to working implementations attached to the network.</p>
<p>The NDK provides an IPv6 and IPv4 compliant TCP/IP stack working with
the TI-RTOS Kernel real-time operating system. Its primary focus is on
providing the core Layer 3 and Layer 4 stack services along with
additional higher-level network applications such as HTTP server and
DHCP.</p>
<p>The NDK itself does not include any platform or device specific
software. The NDK interfaces through well-defined transport interface,
Network Interface Management UNIT(NIMU) to the PDK and platform
software elements needed for operation. NIMU support. NIMU provides an
interface between the stack and the device drivers through which the
stack can talk to multiple instances of a single or various device
drivers concurrently.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td colspan="2"><p><strong>Network Development Kit Summary</strong></p></td>
</tr>
<tr class="row-even"><td><p><strong>Component Type</strong></p></td>
<td><p>Library</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Install Package</strong></p></td>
<td><p>NDK</p></td>
</tr>
<tr class="row-even"><td><p><strong>Install Directory</strong></p></td>
<td><p>ndk_&lt;version&gt;packagestindk</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Project Type</strong></p></td>
<td><p><a class="reference external" href="http://www.eclipse.org/rtsc/">Eclipse RTSC</a></p></td>
</tr>
<tr class="row-even"><td><p><strong>Endian Support</strong></p></td>
<td><p>Little</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Library Name</strong></p></td>
<td><p>For details of the libraries delivered as part of the NDK component,
please refer to <a class="reference external" href="http://www-s.ti.com/sc/techlit/spru523.pdf">[1]</a></p></td>
</tr>
<tr class="row-even"><td><p><strong>Library Path</strong></p></td>
<td><p>$(NDK_INSTALL_DIR)packagestindk</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Include Paths</strong></p></td>
<td><p>NDK_INSTALL_DIR is set automatically by CCS based on the version of
NDK you have checked to build with.
${NDK_INSTALL_DIR}packagestindkinc
${NDK_INSTALL_DIR}packagestindkinctools</p></td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="nimu-transport">
<h3>4.10.2.2. NIMU Transport<a class="headerlink" href="#nimu-transport" title="Permalink to this headline">¶</a></h3>
<p>The NDK transport component of the PDK currently provided 2
implementations for the NIMU layer as described in the sections below.
The following diagram is a high level depiction of the NDK/NIMU
architecture with reference to the NIMU implementations. For details
for the NDK/NIMU architecture, please refer to NDK Programmer’s
Reference Guide <a class="reference external" href="http://www-s.ti.com/sc/techlit/spru524.pdf">[2]</a></p>
<img alt="../_images/NDK_ARCH.png" src="../_images/NDK_ARCH.png" />
</div>
<div class="section" id="nimu-for-cpsw">
<h3>4.10.2.3. NIMU for CPSW<a class="headerlink" href="#nimu-for-cpsw" title="Permalink to this headline">¶</a></h3>
<p>NIMU for CPSW provides a common CPSW interface library for NDK to
communicate with when network stack is being implemented in the TI’s
Common Platform Ethernet Switch for ethernet packet processing. The
library uses the CSL-R based API interfaces to provide NIMU interface
for NDK. This package has NDK unit test examples for all supported EVMS
as indicated in the table above.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This module is only intended to be used with NDK. As such,
users should not tie up to its API directly.</p>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td colspan="2"><p><strong>NIMU for CPSW Summary</strong></p></td>
</tr>
<tr class="row-even"><td><p><strong>Component Type</strong></p></td>
<td><p>Library</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Install Package</strong></p></td>
<td><p>PDK</p></td>
</tr>
<tr class="row-even"><td><p><strong>Install Directory</strong></p></td>
<td><p>$(TI_PDK_INSTALL_DIR)packagestitransportndknimu</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Project Type</strong></p></td>
<td><p><a class="reference external" href="http://www.eclipse.org/rtsc/">Eclipse RTSC</a></p></td>
</tr>
<tr class="row-even"><td><p><strong>Endian Support</strong></p></td>
<td><p>Little</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Library Path</strong></p></td>
<td><p>$(TI_PDK_INSTALL_DIR)packagestitransportndknimulib</p></td>
</tr>
<tr class="row-even"><td><p><strong>Reference Guides</strong></p></td>
<td><p>None</p></td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="nimu-for-icss">
<h3>4.10.2.4. NIMU for ICSS<a class="headerlink" href="#nimu-for-icss" title="Permalink to this headline">¶</a></h3>
<p>NIMU for ICSS (PRU-ICSS is Programmable Real-Time Unit Industrial
Communications Subsystem) provides a common PRU-ICSS interface library
for NDK to communicate with when network stack is being implemented in
the PRU-ICSS subsytem for ethernet packet processing (firmware based
switch running on PRU’s which are part of the ICSS). The library used
the ICSS_EMAC LLD to provide NIMU interface for NDK. This package has
NDK unit test examples for all supported Devices as indicated in the
table above. For details of the PRU-ICSS, please refer to
<a class="reference external" href="/index.php/Processor_SDK_RTOS_ICSS-EMAC">ICCS-EMAC</a>.</p>
<div class="line-block">
<div class="line"><strong>Note</strong>: This module is only intended to be used with NDK and
requires ICSS-EMAC low level driver. As such, users should not tie up
to its API directly.</div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td colspan="2"><p><strong>NIMU for ICSS Summary</strong></p></td>
</tr>
<tr class="row-even"><td><p><strong>Component Type</strong></p></td>
<td><p>Library</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Install Package</strong></p></td>
<td><p>PDK</p></td>
</tr>
<tr class="row-even"><td><p><strong>Install Directory</strong></p></td>
<td><p>$(TI_PDK_INSTALL_DIR)packagestitransportndknimu_icss</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Project Type</strong></p></td>
<td><p><a class="reference external" href="http://www.eclipse.org/rtsc/">Eclipse RTSC</a></p></td>
</tr>
<tr class="row-even"><td><p><strong>Endian Support</strong></p></td>
<td><p>Little</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Library Path</strong></p></td>
<td><p>$(TI_PDK_INSTALL_DIR)packagestitransportndknimu_icsslib</p></td>
</tr>
<tr class="row-even"><td><p><strong>Reference Guides</strong></p></td>
<td><p>None</p></td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="id160">
<h3>4.10.2.5. Examples<a class="headerlink" href="#id160" title="Permalink to this headline">¶</a></h3>
<div class="section" id="ping-example">
<h4>4.10.2.5.1. PING Example<a class="headerlink" href="#ping-example" title="Permalink to this headline">¶</a></h4>
<p>All NDK examples using CPSW interface can be found at the following
location:</p>
<ul class="simple">
<li><p>$(TI_PDK_INSTALL_DIR)/packages/ti/transport/ndk/nimu/example</p></li>
</ul>
<p>All NDK examples using PRU-ICSS interface can be found at the following
location:</p>
<ul class="simple">
<li><p>$(TI_PDK_INSTALL_DIR)/packages/ti/transport/ndk/nimu_icss/example</p></li>
</ul>
<div class="section" id="building-the-ndk-examples">
<h5>4.10.2.5.1.1. Building the NDK examples<a class="headerlink" href="#building-the-ndk-examples" title="Permalink to this headline">¶</a></h5>
<div class="line-block">
<div class="line">Use pdkProjectCreate.sh for Linux environment or pdkProjectCreate.bat
for Windows.</div>
<div class="line">This can be found under the &lt;PDK&gt;/packages folder. The only
modification to these scripts, if any, is to update the
CCS_INSTALL_PATH variable to point to CCS location if its not in the
c:ticcsv6 directory . Please refer to <a class="reference external" href="index_how_to_guides.html#rebuild-drivers-from-pdk-directory">Rebuilding
PDK</a> for details of example project
creation and how to run the example projects using CCS.</div>
</div>
</div>
<div class="section" id="ndk-example-description">
<h5>4.10.2.5.1.2. NDK Example Description<a class="headerlink" href="#ndk-example-description" title="Permalink to this headline">¶</a></h5>
<p>For each EVM Type supported, there is a example which demonstates “ping”
use case. Once the application is loaded via CCS and run, you will be
able to ping the configured IP address as specificed int he examples
config file. For example, the config file for NIMU for CPSW for
idkAM572x, can be found in
ti/transport/ndk/nimu/example/am572x/armv7/bios/nimu_idk.cfg. If you
wish to re-configure the IP address of the CPSW interface you will need
to modify the following configuration parameters</p>
<ul class="simple">
<li><p>Ip.address = “new ip address”</p></li>
<li><p>Ip.mask = “new ip mask”</p></li>
<li><p>Ip.gatewayIpAddr = “new gatewayIpAddr”</p></li>
</ul>
<div class="line-block">
<div class="line">If you you do change these settings, you will be required to re-build
the Example Project using CCS.</div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 22%" />
<col style="width: 22%" />
<col style="width: 22%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>EVM
Configuration</p></th>
<th class="head"><p>Expected
Results</p></th>
<th class="head"><p>SOC
Supported</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NIMU_BasicExamp
le_evmXXXX_&lt;cor
e&gt;exampleproject</p></td>
<td><p>Example
demonstrates
ping from
external
source to
Gigabit
Ethernet port
on EVM.</p></td>
<td><p>icev2AM335x:
Jumpers J18
and J19 need
to be set
properly to
select CPSW
or ICSS mode.
Pin2 and Pin3
need to be
connected for
ICSS mode and
Pin1 and Pin2
for CPSW
mode.
Update *.cfg
file with
static IP to
test. NIMU for
CPSW test
requires
connection of
configured
Ethernet port
under test to
external PC on
same subnet.</p></td>
<td><p>Run ping from
any other PC
in the same
subnet,</p>
<p>Ping response
from the EVM
verifies
successful
execution of
example.</p>
</td>
<td><p>AM335x
AM437x
AM57x
K2G</p></td>
</tr>
<tr class="row-odd"><td><p>NIMU_ICSS_Basic
Example_evmXXXX
_&lt;core&gt;Examplep
roject</p></td>
<td><p>Example
demonstrates
ping from
external
source to
PRU-ICSS
Ethernet port
on EVM.</p></td>
<td><p>icev2AM335x:
Jumpers J18
and J19 need
to be set
properly to
select CPSW
or ICSS mode.
Pin2 and Pin3
need to be
connected for
ICSS mode and
Pin1 and Pin2
for CPSW
mode.
Update *.cfg
file with
static IP to
test. NIMU for
CPSW test
requires
connection of
configured
Ethernet port
under test to
external PC on
same subnet.</p></td>
<td><p>Run ping from
any other PC in
the same subnet.</p>
<p>Ping response
from the EVM
verifies
successful
execution of
example.</p>
</td>
<td><p>AMIC110
AM335x
AM437x
AM57x
K2G</p></td>
</tr>
<tr class="row-even"><td><p><a href="#id171"><span class="problematic" id="id172">NIMU_Cpsw_</span></a>
ExampleApp</p></td>
<td><p>Example
demonstrates
ping from
external
source to
Gigabit
Ethernet port
on EVM.</p></td>
<td><p>Update *.cfg
file with
static IP to
test. NIMU for
CPSW test
requires
connection of
configured
Ethernet port
under test to
external PC on
same subnet.</p></td>
<td><p>Run ping from
any other PC in
the same subnet.</p>
<p>Ping response
from the EVM
verifies
successful
execution of
example.</p>
</td>
<td><p>AM65x
J721E</p></td>
</tr>
<tr class="row-odd"><td><p>NIMU_Icssg
ExampleApp</p></td>
<td><p>Example
demonstrates
ping from
external
source to
PRU-ICSS
Ethernet port
on EVM.</p></td>
<td><p>Update *.cfg
file with
static IP to
test. NIMU for
CPSW test
requires
connection of
configured
Ethernet port
under test to
external PC on
same subnet.</p></td>
<td><p>Run ping from
any other PC in
the same subnet.</p>
<p>Ping response
from the EVM
verifies
successful
execution of
example.</p>
</td>
<td><p>AM65x</p></td>
</tr>
<tr class="row-even"><td><p>NIMU_BasicClient
Example_evmXXXX
_&lt;core&gt;Example
project</p></td>
<td><p>Example
demonstrates
creating local
servers: TCP, UDP
, data, null and
OOB.</p></td>
<td><p>Same as above.
Use DHCP by
default.</p></td>
<td><p>See TI NDK user
guide, section 2
Example
Applications
for how to test.</p></td>
<td><p>AM57x</p></td>
</tr>
<tr class="row-odd"><td><p>NIMU_emacExample
Client_evmXXXX
_&lt;core&gt;Example
project</p></td>
<td><p>Example
demonstrates
creating local
servers: TCP, UDP
, data, null and
OOB.</p></td>
<td><p>Same as above.
Use DHCP by
default.</p></td>
<td><p>See TI NDK user
guide, section 2
Example
Applications
for how to test.</p></td>
<td><p>C665x
C667x
OMAP-L137/8</p></td>
</tr>
<tr class="row-even"><td><p>NIMU_BasicHello
<a href="#id173"><span class="problematic" id="id174">WorldExample_</span></a>
evmXXXX_&lt;core&gt;
Exampleproject</p></td>
<td><p>Example
demonstrates UDP
helloworld echo
test.</p></td>
<td><p>Same as above.
Use DHCP by
default.</p></td>
<td><p>See TI NDK user
guide, section 2
Example
Applications
for how to test.</p></td>
<td><p>AM57x</p></td>
</tr>
<tr class="row-odd"><td><p>NIMU_emacExample
evmXXXX_&lt;core&gt;
Exampleproject</p></td>
<td><p>Example
demonstrates UDP
helloworld echo
test.</p></td>
<td><p>Same as above.
Use DHCP by
default.</p></td>
<td><p>See TI NDK user
guide, section 2
Example
Applications
for how to test.</p></td>
<td><p>C665x
C667x
K2H/K/E/L
OMAP-L137/8</p></td>
</tr>
<tr class="row-even"><td><p>NIMU_DualMac
Example_evmXXXX
_&lt;core&gt;Example
project</p></td>
<td><p>Example
demonstrates
using two EMAC
ports with
different
subnets.</p></td>
<td><p>Same as above.
Use static IP by
default.</p></td>
<td><p>Run ping from
any other PC in
the same subnet.
Ping response
from the EVM
verifies
successful
execution of
example.</p></td>
<td><p>AM57x</p></td>
</tr>
<tr class="row-odd"><td><p><a href="#id175"><span class="problematic" id="id176">NIMU_FtpExample_</span></a>
evmXXXX_&lt;core&gt;
Exampleproject</p></td>
<td><p>Example
demonstrates
FTP server with
put and get.</p></td>
<td><p>Same as above.
Use static IP by
default.</p></td>
<td><p>From host PC make
a FTP connection
to EVM: ftp &lt;EVM
IP address&gt;.
User:user
Password:password
Test put and get
command and show
the throughput.</p></td>
<td><p>AM335x
AM437x
AM57x
K2G</p></td>
</tr>
<tr class="row-even"><td><p>NIMU_ICSS
<a href="#id177"><span class="problematic" id="id178">FtpExample_</span></a>
evmXXXX_&lt;core&gt;
Exampleproject</p></td>
<td><p>Example
demonstrates
FTP server with
put and get.</p></td>
<td><p>Same as above.
Use static IP by
default.</p></td>
<td><p>From host PC make
a FTP connection
to EVM: ftp &lt;EVM
IP address&gt;.
User:user
Password:password
Test put and get
command and show
the throughput.</p></td>
<td><p>AM335x
AM437x
AM57x
K2G</p></td>
</tr>
<tr class="row-odd"><td><p><a href="#id179"><span class="problematic" id="id180">NIMU_FtpCpsw_</span></a>
ExampleApp</p></td>
<td><p>Example
demonstrates
FTP server with
put and get.</p></td>
<td><p>Same as above.
Use static IP by
default.</p></td>
<td><p>From host PC make
a FTP connection
to EVM: ftp &lt;EVM
IP address&gt;.
User:user
Password:password
Test put and get
command and show
the throughput.</p></td>
<td><p>AM65x
J7</p></td>
</tr>
<tr class="row-even"><td><p><a href="#id181"><span class="problematic" id="id182">NIMU_FtpIcssg_</span></a>
ExampleApp</p></td>
<td><p>Example
demonstrates
FTP server with
put and get.</p></td>
<td><p>Same as above.
Use static IP by
default.</p></td>
<td><p>From host PC make
a FTP connection
to EVM: ftp &lt;EVM
IP address&gt;.
User:user
Password:password
Test put and get
command and show
the throughput.</p></td>
<td><p>AM65x</p></td>
</tr>
</tbody>
</table>
<p>Note: Not all the test examples are supported on all the platforms. The NDK code is hardware agnostic, the NIMU driver however depends on the specific SOC. The NDK code can be ported to different platforms. Some Windows host test applications are available under ndk_3_xx_xx_xxpackagestindkwinapps.</p>
</div>
<div class="section" id="running-ndk-example-on-arm-core-of-keystone-ii-devices">
<h5>4.10.2.5.1.3. Running NDK example on ARM core of Keystone II devices<a class="headerlink" href="#running-ndk-example-on-arm-core-of-keystone-ii-devices" title="Permalink to this headline">¶</a></h5>
<p>Before running the NDK example on ARM core of Keystone II
devices(K2H/L/E/G), the following steps need to be performed.</p>
<ul class="simple">
<li><p>Increase the NS_BootTask stack from 2048 to 4096 in netctrl.c:</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TaskCreate</span><span class="p">(</span> <span class="n">NS_BootTask</span><span class="p">,</span> <span class="s">&quot;ConfigBoot&quot;</span><span class="p">,</span> <span class="n">OS_TASKPRINORM</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,(</span><span class="n">UINT32</span><span class="p">)</span><span class="n">hCfg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Rebuild the NDK</p></li>
<li><p>Rebuild NIMU driver</p></li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
</div>
<div class="section" id="cclink-example">
<h3>4.10.2.6. CCLink Example<a class="headerlink" href="#cclink-example" title="Permalink to this headline">¶</a></h3>
<p>Refer
<a class="reference external" href="index_Foundational_Components.html#cclink">Processor_SDK_RTOS_CCLINK</a> for
details on steps for running cclink master and slave examples on NDK.</p>
</div>
<div class="section" id="faq">
<h3>4.10.2.7. FAQ<a class="headerlink" href="#faq" title="Permalink to this headline">¶</a></h3>
<div class="section" id="how-to-check-which-versions-of-nimu-driver-is-for-my-soc">
<h4>4.10.2.7.1. How to check which versions of NIMU driver is for my SOC?<a class="headerlink" href="#how-to-check-which-versions-of-nimu-driver-is-for-my-soc" title="Permalink to this headline">¶</a></h4>
<p>There are several versions of NIMU driver for different SOCs. Please
check packagestitransportndknimubuildmakefile.mk</p>
<ul class="simple">
<li><p>V0: C6657</p></li>
<li><p>V1: C6678</p></li>
<li><p>V2: K2H, K2K</p></li>
<li><p>V3: K2L, K2E</p></li>
<li><p>V4: AM572x, AM571x, AM437x, AM335x</p></li>
<li><p>V5: K2G</p></li>
<li><p>V6: OMAP-L137/138</p></li>
<li><p>V7: AM65x, J7</p></li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="is-there-any-multicast-streams-limitation-using-the-ndk">
<h4>4.10.2.7.2. Is there any multicast streams limitation using the NDK?<a class="headerlink" href="#is-there-any-multicast-streams-limitation-using-the-ndk" title="Permalink to this headline">¶</a></h4>
<p>In the NDK, the limit is defined by a macro at ti/ndk/stack/igmp/igmp.c:
#define IGMP_MAX_GROUP 32 It is then used to create an array of IGMP
records: static IGMP_REC igmp[IGMP_MAX_GROUP]; The IGMP_MAX_GROUP value
can be increased, then rebuild the NDK stack.</p>
</div>
<div class="section" id="how-to-share-a-tcp-ip-socket-across-tasks">
<h4>4.10.2.7.3. How to share a TCP/IP socket across tasks?<a class="headerlink" href="#how-to-share-a-tcp-ip-socket-across-tasks" title="Permalink to this headline">¶</a></h4>
<p>The basic building block of NDK stack code internally is an object handle.
Internally to the stack, both sockets and pipes are addressed by object handles.
However, at the application level, sockets and pipes are treated as file
descriptors. To share a SOCKET, i.e. a file descriptor, a task must first
allocate a file descriptor table by calling the function fdOpenSession(), then
use the function fdShare() to share the file descriptor among multiple tasks.
As described in NDK API reference guide, fdShare() is useful in a case where
Task A opens a session and calls recv() in a loop on a socket. Task B has a
loop that calls send() on the same socket. The call to send() from Task B will
fail and then fdError() will return -1 if you do not call fdOpenSession() and
then fdShare() from the second Task after the first Task has opened the socket.
For an example that calls fdShare(), see the contest.c file in the
&lt;NDK_INSTALL_DIR&gt;/packages/ti/ndk/tools/console directory.</p>
</div>
<div class="section" id="how-to-tune-tcp-buffer-size-for-an-optimal-throughput">
<h4>4.10.2.7.4. How to tune TCP buffer size for an optimal throughput?<a class="headerlink" href="#how-to-tune-tcp-buffer-size-for-an-optimal-throughput" title="Permalink to this headline">¶</a></h4>
<p>The default TCP buffer size, CFGITEM_IP_SOCKTCPTXBUF/CFGITEM_IP_SOCKTCPRXBUF
is 8192 defined in packages/ti/ndk/inc/stack/inc/resif.h of NDK package and
can be re-configured in RTOS config file,e.g.
Tcp.transmitBufSize = 16384;
Tcp.receiveBufSize = 65536;
NDK also provides a global TCP statistics counter structure NDK_tcps
(ti/ndk/inc/stack/inc/tcpif.h) that can be analyzed in CCS View Expressions
window, similaly, there is a global IP statistics counter structure NDK_ips
(ti/ndk/inc/stack/inc/ipif.h).</p>
</div>
<div class="section" id="why-a-pipe-creation-fails-and-fderror-returns-1">
<h4>4.10.2.7.5. Why a pipe creation fails and fdError() returns -1?<a class="headerlink" href="#why-a-pipe-creation-fails-and-fderror-returns-1" title="Permalink to this headline">¶</a></h4>
<p>Although sockets can be used for inter-task communications, it is not the most
efficient method. The stack provides a second data communications model called
pipes, which allow for local connection oriented communications.
As a pipe is a full duplex connection oriented file descriptor, fdOpenSession()
needs to be called, which opens a file descriptor session on a task thread so
that the task can begin using file descriptor and other stream IO functions.</p>
</div>
<div class="section" id="how-do-i-change-the-pbm-buffer">
<h4>4.10.2.7.6. How do I change the PBM buffer?<a class="headerlink" href="#how-do-i-change-the-pbm-buffer" title="Permalink to this headline">¶</a></h4>
<p>You can configure the PBM buffer used by the NDK by opening the .cfg file with XGCONF, then clicking the Buffers button. This page lets you configure the buffer size, number of buffers and locations of the NDK Packet Buffer Manager (PBM) and the Memory Manager Buffer. Or, you can edit ndk_3_xx_xx_xxpackagestindkstackpbmpbm_data.c (PKT_NUM_FRAMEBUF and PKT_SIZE_FRAMEBUF) and rebuild the NDK.</p>
</div>
<div class="section" id="do-you-have-any-raw-packet-example">
<h4>4.10.2.7.7. Do you have any raw packet example?<a class="headerlink" href="#do-you-have-any-raw-packet-example" title="Permalink to this headline">¶</a></h4>
<p>A raw socket is used to receive raw packets. This means packets received at the Ethernet layer will directly pass to the raw socket. Stating it precisely, a raw socket bypasses the normal TCP/IP processing and sends the packets to the specific user application. Please check the TI Network Developer’s Kit (NDK) API Reference Guide <a class="reference external" href="http://www-s.ti.com/sc/techlit/spru524.pdf">http://www-s.ti.com/sc/techlit/spru524.pdf</a> A.15 Raw Ethernet Module for details. Code example available in NIMU_emacClientExample_evmXXXX_&lt;CPU&gt;ExampleProject</p>
</div>
<div class="section" id="how-do-i-enable-the-jumbo-packet-support">
<h4>4.10.2.7.8. How do I enable the jumbo packet support?<a class="headerlink" href="#how-do-i-enable-the-jumbo-packet-support" title="Permalink to this headline">¶</a></h4>
<p>Jumbo frames have packet sizes larger than 1500 bytes. Jumbo frame support can be built into an application by linking with libraries compiled for Jumbo frame support.  Two parts of changes are needed for NDK/NIMU example:
1. NDK libraries: The NDK libraries would have to be recompiled with the following pre-processor definition added: _INCLUDE_JUMBOFRAME_SUPPORT.
2. NIMU library: the CPSW switch has to be configured to support jumbo packet size and rebuilt. The coding is SOC specific, V0, V4, V5, V6 and V7 NIMU drivers use structure EMAC_OpenConfigInfo and pass the maximum packet size into max_pkt_size field. V1, V2 and V3 NIMU drivers use structure NETIF_DEVICE and pass the maximum packet size into mtu field.
Finally, please rebuild the test application with updated NDK and NIMU libraries. A reference example for C6678 is available at: <a class="reference external" href="http://processors.wiki.ti.com/index.php/Enabling_Jumbo_Packet_Support_for_C6678">http://processors.wiki.ti.com/index.php/Enabling_Jumbo_Packet_Support_for_C6678</a>. Note the work was implemented on earlier BIOS MCSDK package which was obsolete.</p>
</div>
<div class="section" id="keystone-pa-or-ndk-example-doesnt-work-in-other-boot-mode-than-no-boot-mode-using-ccs-jtag">
<h4>4.10.2.7.9. Keystone PA or NDK example doesn’t work in other boot mode than no-boot mode using CCS/JTAG?<a class="headerlink" href="#keystone-pa-or-ndk-example-doesnt-work-in-other-boot-mode-than-no-boot-mode-using-ccs-jtag" title="Permalink to this headline">¶</a></h4>
<p>When running the program with CCS/JTAG, the default GEL file initializes the SOC. Same initialization, like turning on all the relevant power domains, and configuring the SGMII, Serdes, may not be implemented in other boot modes. First check GEL file under ccs_baseemulationboards&lt;boards&gt;gel, function Global_Default_Setup() function to add the missing initializations into the application. Next, look for any boot mode dependent code in the application.  For example, passPowerUp() is called in no_boot mode to turn on PA, this has to be executed in your application when booting from other boot modes as well.</p>
</div>
</div>
<div class="section" id="additional-documentation-references">
<h3>4.10.2.8. Additional Documentation References<a class="headerlink" href="#additional-documentation-references" title="Permalink to this headline">¶</a></h3>
<table class="docutils align-default">
<colgroup>
<col style="width: 44%" />
<col style="width: 56%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Document</strong></p></td>
<td><p><strong>Location</strong></p></td>
</tr>
<tr class="row-even"><td><p>NDK Programmer’s Reference Guide</p></td>
<td><p><a class="reference external" href="http://www-s.ti.com/sc/techlit/spru524.pdf">http://www-s.ti.com/sc/techlit/spru524.pdf</a></p></td>
</tr>
<tr class="row-odd"><td><p>NDK User’s Guide</p></td>
<td><p><a class="reference external" href="http://www-s.ti.com/sc/techlit/spru523.pdf">http://www-s.ti.com/sc/techlit/spru523.pdf</a></p></td>
</tr>
<tr class="row-even"><td><p>Network Developers Kit FAQ</p></td>
<td><p><a class="reference external" href="http://processors.wiki.ti.com/index.php/Network_Developers_Kit_FAQ">Network Developers Kit FAQ</a></p></td>
</tr>
<tr class="row-odd"><td><p>NDK Support Package Ethernet
Driver Design Guide</p></td>
<td><p><a class="reference external" href="http://www-s.ti.com/sc/techlit/sprufp2.pdf">http://www-s.ti.com/sc/techlit/sprufp2.pdf</a></p></td>
</tr>
<tr class="row-even"><td><p>Rebuilding_the_NDK_Core
Rebuilding NDK Core</p></td>
<td><p><a class="reference external" href="http://processors.wiki.ti.com/index.php/">http://processors.wiki.ti.com/index.php/</a>
Rebuilding_the_NDK_Core</p></td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p class="rubric" id="id161">Introduction</p>
<div class="line-block">
<div class="line">The NWAL (Network Adaptation Layer) driver provides a well-defined set
of APIs which could be used for applications interfacing with NetCP
(Network Coprocessor) module in Keystone family of SOCs (C66x, K2x).</div>
</div>
<p class="rubric" id="driver-features">Driver Features</p>
<ul class="simple">
<li><p>Initialization of NetCP low level driver resources</p></li>
<li><p>Initialization of Packet DMA related resources associated with NetCP</p></li>
<li><p>Classification of incoming packets based on L2: MAC header fields</p></li>
<li><p>Classification of incoming packets based on L3: IPv4/IPv6 header
fields</p></li>
<li><p>Routing of packets to host based on L4: UDP/TCP/GTP-U</p></li>
<li><p>Unidirectional IPSec SA creation and deletion</p></li>
<li><p>In band offload of IPSec encryption/decryption for the outgoing
packets</p></li>
<li><p>Access to SA data mode acceleration for data plane applications.</p></li>
<li><p>Supports offload of the following features to NETCP Hardware during
transmission of packets:</p>
<ul>
<li><p>IPv4 checksum/L4:TCP/UDP checksum/IPSec Encryption</p></li>
<li><p>Redirection of packets through a specific MAC port</p></li>
<li><p>Software Insertion of L2/L3/L4 header</p></li>
</ul>
</li>
<li><p>Upon reception of packet, module provides additional meta data
details including:</p>
<ul>
<li><p>Status of IP checksum/UDP/TCP checksum results</p></li>
<li><p>Offset to L2/L3/L4 protocol offsets. Appropriate layer offset will
be valid only if classification or routing is enabled at NETCP</p></li>
<li><p>Ingress MAC port information</p></li>
</ul>
</li>
</ul>
<p class="rubric" id="id162">Modes of Operation</p>
<p>Following modes of operations are supported by NWAL when sending control
configuration request to configure NetCP firmware. <strong>BLOCKING Mode</strong>: In
this mode, status of API request used to configure NetCP is returned
back in API call context.</p>
<p><strong>Non-BLOCKING Mode</strong>: In this mode, application can invoke a separate
poll routine to retrieve status response result.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p class="rubric" id="driver-configuration-nwal">Driver Configuration</p>
<p>The driver configures the NWAL subsystem using the nwalGlobCfg_t
structure.</p>
<p>This structure must be initialized before the nwal_create() function API
is called and cannot be changed afterwards. For details regarding
individual fields of this structure, see the Doxygen help by opening
PDK_INSTALL_DIRpackagestidrvnwaldocsdoxygenhtmlindex.html.</p>
<p class="rubric" id="id163"><strong>APIs</strong></p>
<p>API reference for application can be found in below file:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;ti/drv/nwal/nwal.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p class="rubric" id="id164">Example</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Expected Results</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>nwalUnitTest
Application</p></td>
<td><div class="line-block">
<div class="line">Unit Test
application to test
all APIs</div>
</div>
</td>
<td><div class="line-block">
<div class="line">User observes the
output printed over
the CCS console</div>
</div>
</td>
</tr>
</tbody>
</table>
<p class="rubric" id="id165">Additional References</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Document</strong></p></td>
<td><p><strong>Location</strong></p></td>
</tr>
<tr class="row-even"><td><p>API Reference Manual</p></td>
<td><p>$(TI_PDK_INSTALL_DIR)packagesti
drvnwaldocsdoxygenhtmlindex
.html</p></td>
</tr>
<tr class="row-odd"><td><p>Release Notes</p></td>
<td><p>$(TI_PDK_INSTALL_DIR)packagesti
drvnwaldocsReleaseNotes_NWAL_
LLD.pdf</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="section" id="transport">
<h1>4.11. Transport<a class="headerlink" href="#transport" title="Permalink to this headline">¶</a></h1>
<div class="section" id="timesync-ptp">
<h2>4.11.1. TimeSync (PTP)<a class="headerlink" href="#timesync-ptp" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id166">
<h3>4.11.1.1. Overview<a class="headerlink" href="#id166" title="Permalink to this headline">¶</a></h3>
<div class="section" id="terms-and-abbreviations">
<h4>4.11.1.1.1. Terms and Abbreviations<a class="headerlink" href="#terms-and-abbreviations" title="Permalink to this headline">¶</a></h4>
<table class="docutils align-default">
<colgroup>
<col style="width: 48%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Acronym</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>PTP</p></td>
<td><p>Precision Time Protocol</p></td>
</tr>
<tr class="row-odd"><td><p>P2P</p></td>
<td><p>Peer to Peer</p></td>
</tr>
<tr class="row-even"><td><p>E2E</p></td>
<td><p>End to End</p></td>
</tr>
<tr class="row-odd"><td><p>TC</p></td>
<td><p>Transparent Clock</p></td>
</tr>
<tr class="row-even"><td><p>OC</p></td>
<td><p>Ordinary Clock</p></td>
</tr>
<tr class="row-odd"><td><p>BC</p></td>
<td><p>Boundary Clock</p></td>
</tr>
<tr class="row-even"><td><p>Master</p></td>
<td><p>PTP master</p></td>
</tr>
<tr class="row-odd"><td><p>Slave</p></td>
<td><p>PTP Slave</p></td>
</tr>
<tr class="row-even"><td><p>BMCA</p></td>
<td><p>Best Master Clock Algorithm</p></td>
</tr>
<tr class="row-odd"><td><p>RCF</p></td>
<td><p>Synchronization/(Frequency
Compensation) Factor</p></td>
</tr>
<tr class="row-even"><td><p>IEC 61558</p></td>
<td><p>PTP profile for network control
systems</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id167">
<h4>4.11.1.1.2. Introduction<a class="headerlink" href="#id167" title="Permalink to this headline">¶</a></h4>
<p>This document details the user guide aspects of PTP/1588 v2 master/slave implementation on PRU-ICSS.</p>
<p>Dual EMAC firmware implementation supports P2P and the implementation is unique to Emac.
The master capability added to the TimeSync driver is currently limitted to sending Sync and
Announce frames. The BMCA/Management part of PTP master is not implemented.</p>
<p>TimeSync (PTP) driver does the task of</p>
<ol class="arabic simple">
<li><p>Running BMCA</p></li>
<li><p>Calculating RCF and Sync packet interval.</p></li>
<li><p>Performing clock synchronization</p></li>
<li><p>Calculating peer and line delay</p></li>
<li><p>Sending Delay Request and Delay Response frames (includes Pdelay Req and Pdelay Res)</p></li>
</ol>
<p class="rubric" id="driver-configuration-timesync">Driver Configuration</p>
<p class="rubric" id="board-specific-configuration"><strong>Board Specific Configuration</strong></p>
<p>All board specific configurations like enabling clock and pin-mux are
required before calling any driver APIs. By default Board_Init() API
available under board module supports all initialization sequence for TI
supported EVMs. In addition it initializes UART instance for
Console/STDIO. Refer <a class="reference external" href="index_board.html#board-support">Processor SDK RTOS Board
Support</a> for additional
details.</p>
<p class="rubric" id="timesync-configuration-structure"><strong>TimeSync Configuration Structure</strong></p>
<p>The TimeSync driver needs to be initialized/configured with initial parameters during the driver initialization.</p>
<p>icss_timeSync_init.c binds driver with TimeSync parameters.</p>
<p>TimeSync_drvInit() API triggers all static configuration information available through parameters. Once initialization is complete the driver is ready for use.</p>
<p>Please refer to TimeSync_ParamsHandle structure defined under ‘&lt;pdk&gt;/packages/ti/transport/timeSync/include/icss_timeSyncApi.h’</p>
</div>
<div class="section" id="id168">
<h4>4.11.1.1.3. APIs<a class="headerlink" href="#id168" title="Permalink to this headline">¶</a></h4>
<p>API reference for Application:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;ti/transport/timeSync/icss_timeSync.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>Below sequence indicates API calling sequence for a simple use case of
timeSync master operation</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">Board_init</span><span class="p">(</span><span class="n">boardCfg</span><span class="p">);</span>
<span class="n">timeSync_example_configureInterrupts</span><span class="p">(</span><span class="n">EMAC_PORT_NUM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">emacCfg</span><span class="p">);</span>
<span class="n">ICSS_EmacSocSetInitCfg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">emacBaseAddr</span><span class="p">);</span>
<span class="n">ICSS_EmacInit</span><span class="p">();</span>
<span class="cm">/* Assumption: firmware is downloaded and ICSS_EMAC driver is initialized */</span>
<span class="n">TimeSync_drvInit</span><span class="p">(</span><span class="n">timeSyncHandle</span><span class="p">);</span>
<span class="n">TimeSync_drvEnable</span><span class="p">(</span><span class="n">timeSyncHandle</span><span class="p">);</span>
<span class="n">TimeSync_enableMaster</span><span class="p">();</span>
<span class="n">While</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Delay</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Below sequence indicates API calling sequence for a simple use case of
timeSync slave operation</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">Board_init</span><span class="p">(</span><span class="n">boardCfg</span><span class="p">);</span>
<span class="n">timeSync_example_configureInterrupts</span><span class="p">(</span><span class="n">EMAC_PORT_NUM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">emacCfg</span><span class="p">);</span>
<span class="n">ICSS_EmacSocSetInitCfg</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">emacBaseAddr</span><span class="p">);</span>
<span class="n">ICSS_EmacInit</span><span class="p">();</span>
<span class="cm">/* Assumption: firmware is downloaded and ICSS_EMAC driver is initialized */</span>
<span class="n">TimeSync_drvInit</span><span class="p">(</span><span class="n">timeSyncHandle</span><span class="p">);</span>
<span class="n">TimeSync_drvEnable</span><span class="p">(</span><span class="n">timeSyncHandle</span><span class="p">);</span>
<span class="n">TimeSync_disableMaster</span><span class="p">();</span>
<span class="n">While</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Delay</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>NOTE</strong>
:</p>
<ol class="arabic simple">
<li><p>The TimeSync Tx callback interrupt is mapped to the ISR TimeSync_txTSIsr(), where the two PRU interrupts configured to ARM interrupt txIntNum are PRU_ARM_EVENT_6 and PRU_ARM_EVENT_7.</p></li>
<li><p>The PTP frames are received via the Real Time (RT) call back from ICSS_EMAC driver and hence RT call back needs to be implemented at the application for ICSS-EMAC driver.</p></li>
</ol>
</div>
<div class="section" id="tasks-internally-created-from-timesync-drvinit">
<h4>4.11.1.1.4. Tasks Internally created from TimeSync_drvInit()<a class="headerlink" href="#tasks-internally-created-from-timesync-drvinit" title="Permalink to this headline">¶</a></h4>
<p>Below tasks would be created after Application calls TimeSync_drvInit() function. The sample osal implementation is provided under &lt;pdk&gt;/packages/ti/transport/timeSync/example/src/common/timeSync_example_osal.c implementing these tasks.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 24%" />
<col style="width: 26%" />
<col style="width: 18%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Handle Name</p></th>
<th class="head"><div class="line-block">
<div class="line">Function Name</div>
</div>
</th>
<th class="head" colspan="2"><div class="line-block">
<div class="line">What it does</div>
</div>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>timeSync_pDelayReqSendTask</p></td>
<td><p>TimeSync_PdelayReqSendTask()</p></td>
<td colspan="2"><div class="line-block">
<div class="line">Send Peer Delay Requests periodically on both ports.
Delay is configurable. Only applicable for P2P configuration</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>timeSync_delayReqSendTask</p></td>
<td><p>TimeSync_delayReqSendTask()</p></td>
<td colspan="2"><div class="line-block">
<div class="line">Send Delay requests to PTP Master. This is currently done for
every Sync frame. Pends indefinitely on a semaphore.</div>
</div>
</td>
</tr>
<tr class="row-even"><td rowspan="2"><p>timeSync_TxTSTaskP1</p></td>
<td rowspan="2"><p>TimeSync_TxTSTask_P1()</p></td>
<td colspan="2" rowspan="2"><div class="line-block">
<div class="line">Process Tx timestamp for Port 1. Pends on an event posted by
Tx ISR indefinitely.</div>
</div>
</td>
</tr>
<tr class="row-odd"></tr>
<tr class="row-even"><td rowspan="2"><p>timeSync_TxTSTaskP2</p></td>
<td rowspan="2"><p>TimeSync_TxTSTask_P2()</p></td>
<td colspan="2" rowspan="2"><div class="line-block">
<div class="line">Process Tx timestamp for Port 2. Pends on an event posted by
Tx ISR indefinitely.</div>
</div>
</td>
</tr>
<tr class="row-odd"></tr>
<tr class="row-even"><td rowspan="2"><p>timeSync_syncTxTask</p></td>
<td rowspan="2"><p>TimeSync_SyncTxTask()</p></td>
<td colspan="2" rowspan="2"><div class="line-block">
<div class="line">Sends Sync frames on both ports in Master mode.
Pends indefinitely on a semaphore posted by the DM Timer ISR</div>
</div>
</td>
</tr>
<tr class="row-odd"></tr>
<tr class="row-even"><td><p>timeSync_announceTxTask</p></td>
<td><p>TimeSync_AnnounceTxTask()</p></td>
<td colspan="2"><div class="line-block">
<div class="line">Sends Announce frames on both ports periodically</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>timeSync_NRT_Task</p></td>
<td><p>TimeSync_NRT_Task()</p></td>
<td colspan="2"><div class="line-block">
<div class="line">NRT stands for non real time. Processes Peer delay frames in
the background and calculate peer delay.</div>
</div>
</td>
</tr>
<tr class="row-even"><td><p>timeSync_backgroundTask</p></td>
<td><p>TimeSync_BackgroundTask()</p></td>
<td colspan="2"><div class="line-block">
<div class="line">Checks for Sync timeout and performs offset stabilization.</div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="building-timesync-examples-unit-test">
<h4>4.11.1.1.5. Building timeSync Examples/Unit Test<a class="headerlink" href="#building-timesync-examples-unit-test" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>Setup the build environment <a class="reference external" href="http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/index_overview.html#setup-environment">SetupBuildEnvironment</a></p></li>
<li><p>Follow the steps as mentioned under <a class="reference external" href="http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/index_overview.html#pdk-example-and-test-project-creation">SDK example and test CCS Project Creation</a>  for creating the CCS based example and test projects creation</p></li>
</ul>
</div>
<div class="section" id="sample-examples">
<h4>4.11.1.1.6. Sample Examples<a class="headerlink" href="#sample-examples" title="Permalink to this headline">¶</a></h4>
<table class="docutils align-default">
<colgroup>
<col style="width: 36%" />
<col style="width: 32%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><div class="line-block">
<div class="line">Expected Results</div>
</div>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>timeSync_BasicExample</p></td>
<td><p>Simple timeSync
example demonstrating
sync between Master
and Slave</p></td>
<td><div class="line-block">
<div class="line">Clock Sync
results at Slave</div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id169">
<h3>4.11.1.2. Additional References<a class="headerlink" href="#id169" title="Permalink to this headline">¶</a></h3>
<table class="docutils align-default">
<colgroup>
<col style="width: 38%" />
<col style="width: 62%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Document</strong></p></td>
<td><p><strong>Location</strong></p></td>
</tr>
<tr class="row-even"><td><p>API Reference Manual</p></td>
<td><p>$(TI_PDK_INSTALL_DIR)/packages/ti
/transport/timeSync/docs/doxygen/html/index
.html</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="section" id="id170">
<h1>4.12. Tools<a class="headerlink" href="#id170" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p><a class="reference external" href="http://processors.wiki.ti.com/index.php/Processor_SDK_RTOS_Tools">Processor SDK RTOS Tools</a></p></li>
</ul>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><img alt="../_images/E2e.jpg" src="../_images/E2e.jpg" />
</td>
<td><p>For technical support please post your questions at <a class="reference external" href="http://e2e.ti.com/">http://e2e.ti.com</a>.</p></td>
</tr>
</tbody>
</table>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="DSP_Software.html" class="btn btn-neutral float-right" title="5. DSP Software" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Foundational_Components.html" class="btn btn-neutral" title="4. Foundational Components" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
      <a href="http://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyright 1995-2019</a>, Texas Instruments Incorporated. All rights reserved. <br>
      <a href="http://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="http://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="http://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="http://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'06_01_00',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/language_data.js"></script>

    <script src="http://www.ti.com/assets/js/headerfooter/analytics.js" type="text/javascript" charset="utf-8"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
        });

      var menuHeight = window.innerHeight;

      var contentOffset = $(".wy-nav-content-wrap").offset();
      var contentHeight = $(".wy-nav-content-wrap").height();
      var contentBottom = contentOffset.top + contentHeight;

      function setNavbarTop() {
          var scrollTop = $(window).scrollTop();
          var maxTop = scrollTop + menuHeight;

          // If past the header
          if (scrollTop > contentOffset.top && maxTop < contentBottom) {
            stickyTop = scrollTop - contentOffset.top;
          } else if (maxTop > contentBottom) {
            stickyTop = scrollTop - contentOffset.top - (maxTop - contentBottom);
          } else {
            stickyTop = 0;
          }

          $(".wy-nav-side").css("top", stickyTop);
      }

      $(document).ready(function() {
        setNavbarTop();
        $(window).scroll(function () {
          setNavbarTop();
        });
      });
  </script>
   

</body>
</html>